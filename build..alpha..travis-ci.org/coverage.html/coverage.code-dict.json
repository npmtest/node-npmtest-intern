{"/home/travis/build/npmtest/node-npmtest-intern/test.js":"/* istanbul instrument in package npmtest_intern */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-intern/lib.npmtest_intern.js":"/* istanbul instrument in package npmtest_intern */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_intern = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_intern = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-intern/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-intern && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_intern */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_intern\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_intern.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_intern.rollup.js'] =\n            local.assetsDict['/assets.npmtest_intern.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_intern.__dirname + '/lib.npmtest_intern.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/main.js":"define([\n\t'require'\n], function (require) {\n\treturn {\n\t\t/**\n\t\t * The arguments Intern was started with, post-processing (e.g.,\n\t\t * repeated arguments are converted to arrays).\n\t\t */\n\t\targs: null,\n\n\t\t/**\n\t\t * The executor for the current test run.\n\t\t */\n\t\texecutor: null,\n\n\t\t/**\n\t\t * AMD plugin API interface for easy loading of test interfaces.\n\t\t */\n\t\tload: function (id, parentRequire, callback) {\n\t\t\trequire([ './lib/interfaces/' + id ], callback);\n\t\t},\n\n\t\tnormalize: function (interfaceId) {\n\t\t\t// The loader should not attempt to normalize values passed to the\n\t\t\t// loader plugin as module IDs, since they are not module IDs.\n\t\t\treturn interfaceId;\n\t\t},\n\n\t\t/**\n\t\t * The planned execution mode. One of 'client', 'runner', or 'custom'.\n\t\t */\n\t\tmode: null\n\t};\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/chai.js":"define([ 'chai' ], function (chai) {\n\t// ensure that chai-generated errors always include a stack\n\tchai.config.includeStack = true;\n\n\treturn {\n\t\t/**\n\t\t * AMD plugin API interface for easy loading of chai assertion interfaces.\n\t\t */\n\t\tload: function (id, parentRequire, callback) {\n\t\t\tif (!id) {\n\t\t\t\tcallback(chai);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!chai[id]) {\n\t\t\t\tthrow new Error('Invalid chai interface \"' + id + '\"');\n\t\t\t}\n\n\t\t\tif (!chai[id].AssertionError) {\n\t\t\t\tchai[id].AssertionError = chai.AssertionError;\n\t\t\t}\n\n\t\t\tcallback(chai[id]);\n\t\t},\n\n\t\tnormalize: function (id) {\n\t\t\treturn id;\n\t\t}\n\t};\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/client.js":"/* jshint node:true, es3:false */\nif (typeof process !== 'undefined' && typeof define === 'undefined') {\n\t(function () {\n\t\trequire('dojo/loader')((this.__internConfig = {\n\t\t\tbaseUrl: process.cwd().replace(/\\\\/g, '/'),\n\t\t\tpackages: [\n\t\t\t\t{ name: 'intern', location: __dirname.replace(/\\\\/g, '/') }\n\t\t\t],\n\t\t\tmap: {\n\t\t\t\tintern: {\n\t\t\t\t\tdojo: 'intern/browser_modules/dojo',\n\t\t\t\t\tchai: 'intern/browser_modules/chai/chai',\n\t\t\t\t\tdiff: 'intern/browser_modules/diff/diff',\n\t\t\t\t\t// benchmark requires lodash and platform\n\t\t\t\t\tbenchmark: 'intern/browser_modules/benchmark/benchmark',\n\t\t\t\t\tlodash: 'intern/browser_modules/lodash-amd/main',\n\t\t\t\t\tplatform: 'intern/browser_modules/platform/platform'\n\t\t\t\t},\n\t\t\t\t'*': {\n\t\t\t\t\t'intern/dojo': 'intern/browser_modules/dojo'\n\t\t\t\t}\n\t\t\t}\n\t\t}), [ 'intern/client' ]);\n\t})();\n}\nelse {\n\tdefine([\n\t\t'./lib/executors/PreExecutor',\n\t\t'dojo/has!host-node?./lib/exitHandler'\n\t], function (PreExecutor, exitHandler) {\n\t\tvar executor = new PreExecutor({\n\t\t\tdefaultLoaderOptions: (function () {\n\t\t\t\treturn this;\n\t\t\t})().__internConfig,\n\t\t\texecutorId: 'client'\n\t\t});\n\n\t\tvar promise = executor.run();\n\n\t\tif (exitHandler) {\n\t\t\texitHandler(process, promise, 10000);\n\t\t}\n\t});\n}\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/order.js":"define([\n\t'./lib/util',\n\t'dojo/Promise'\n], function (util, Promise) {\n\tvar queue = util.createQueue(1);\n\n\treturn {\n\t\t/**\n\t\t * AMD plugin for in-order loading of non-AMD JavaScript. Use this when you need to test modules that do not\n\t\t * have proper dependency management.\n\t\t *\n\t\t * @example\n\t\t * define([ 'intern!object', 'intern/order!jquery.js', 'intern/order!plugin.jquery.js', ... ], ...)\n\t\t */\n\t\tload: function (id, parentRequire, callback) {\n\t\t\tqueue(function () {\n\t\t\t\treturn new Promise(function (resolve) {\n\t\t\t\t\tparentRequire([ id ], function (value) {\n\t\t\t\t\t\tcallback(value);\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t})();\n\t\t},\n\n\t\tnormalize: function (id, normalize) {\n\t\t\treturn normalize(id.replace(/\\.js$/, ''));\n\t\t}\n\t};\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/runner.js":"/* jshint node:true */\nif (typeof process !== 'undefined' && typeof define === 'undefined') {\n\t(function () {\n\t\trequire('dojo/loader')((this.__internConfig = {\n\t\t\tbaseUrl: process.cwd().replace(/\\\\/g, '/'),\n\t\t\tpackages: [\n\t\t\t\t{ name: 'intern', location: __dirname.replace(/\\\\/g, '/') }\n\t\t\t],\n\t\t\tmap: {\n\t\t\t\tintern: {\n\t\t\t\t\tdojo: 'intern/browser_modules/dojo',\n\t\t\t\t\tbenchmark: 'intern/browser_modules/benchmark/benchmark',\n\t\t\t\t\tchai: 'intern/browser_modules/chai/chai',\n\t\t\t\t\tdiff: 'intern/browser_modules/diff/diff',\n\t\t\t\t\tlodash: 'intern/browser_modules/lodash-amd/main',\n\t\t\t\t\tplatform: 'intern/browser_modules/platform/platform'\n\t\t\t\t},\n\t\t\t\t'*': {\n\t\t\t\t\t'intern/dojo': 'intern/browser_modules/dojo'\n\t\t\t\t}\n\t\t\t}\n\t\t}), [ 'intern/runner' ]);\n\t})();\n}\nelse {\n\tdefine([\n\t\t'./lib/executors/PreExecutor',\n\t\t'./lib/exitHandler'\n\t], function (PreExecutor, exitHandler) {\n\t\tvar executor = new PreExecutor({\n\t\t\tdefaultLoaderOptions: (function () {\n\t\t\t\treturn this;\n\t\t\t})().__internConfig,\n\t\t\texecutorId: 'runner'\n\t\t});\n\n\t\texitHandler(process, executor.run(), 10000);\n\t});\n}\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/bin/intern-client.js":"#!/usr/bin/env node\nrequire('../client');\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/bin/intern-runner.js":"#!/usr/bin/env node\nrequire('../runner');\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/lib/BenchmarkTest.js":"/**\n * A wrapper around a Benchmark.js Benchmark that maps its API to that used by Test.\n */\ndefine([\n\t'./Test',\n\t'benchmark',\n\t'dojo/Promise',\n\t'dojo/lang',\n\t'dojo/string'\n], function (\n\tTest,\n\tBenchmark,\n\tPromise,\n\tlang,\n\tstring\n) {\n\tvar createLifecycle = (function () {\n\t\tvar template = [\n\t\t\t'(function (benchmark) {',\n\t\t\t\t'\\tvar queue = benchmark.intern${queueName}EachLoopQueue;',\n\t\t\t\t'\\tvar suite;',\n\t\t\t\t'\\tif (!queue) {',\n\t\t\t\t\t'\\t\\tsuite = benchmark.internTest;',\n\t\t\t\t\t'\\t\\tbenchmark.intern${queueName}EachLoopQueue = queue = [];',\n\t\t\t\t\t'\\t\\twhile ((suite = suite.parent)) {',\n\t\t\t\t\t\t'\\t\\t\\tif (suite.${methodName}EachLoop) {',\n\t\t\t\t\t\t\t'\\t\\t\\tqueue.${queueMethod}(suite);',\n\t\t\t\t\t\t'\\t\\t\\t}',\n\t\t\t\t\t'\\t\\t}',\n\t\t\t\t'\\t}',\n\t\t\t\t'\\tvar i = queue.length;',\n\t\t\t\t'\\twhile((suite = queue[--i])) {',\n\t\t\t\t\t'\\t\\tsuite.${methodName}EachLoop();',\n\t\t\t\t'\\t}',\n\t\t\t'})(this.benchmark || this);\\n'\n\t\t].join('\\n');\n\n\t\tfunction createLifecycle(before) {\n\t\t\treturn string.substitute(template, {\n\t\t\t\tqueueName: before ? 'Before' : 'After',\n\t\t\t\tqueueMethod: before ? 'push' : 'unshift',\n\t\t\t\tmethodName: before ? 'before' : 'after'\n\t\t\t});\n\t\t}\n\t\treturn createLifecycle;\n\t})();\n\n\tfunction BenchmarkTest(kwArgs) {\n\t\t// `options`, if present, will be a property on the test function\n\t\tthis.test = (kwArgs && kwArgs.test) || /* istanbul ignore next */ function () {};\n\t\tvar self = this;\n\t\tvar options = lang.mixin({}, this.test.options, {\n\t\t\tasync: true,\n\t\t\tsetup: createLifecycle(true),\n\t\t\tteardown: createLifecycle(false)\n\t\t});\n\n\t\tif ('skip' in options) {\n\t\t\tthis.skipped = options.skip;\n\t\t}\n\t\telse {\n\t\t\tif (options.defer) {\n\t\t\t\tthis.test = (function (testFunction) {\n\t\t\t\t\treturn function (deferred) {\n\t\t\t\t\t\tvar dfd = createDeferred(this.benchmark, deferred, options.numCallsUntilResolution);\n\t\t\t\t\t\ttestFunction.call(this, dfd);\n\t\t\t\t\t};\n\t\t\t\t})(this.test);\n\t\t\t}\n\n\t\t\tthis.benchmark = new Benchmark(\n\t\t\t\tkwArgs.name,\n\t\t\t\toptions.defer ?\n\t\t\t\t\t'this.benchmark.internTest.test.call(this.benchmark.internTest, deferred);' :\n\t\t\t\t\t'this.internTest.test.call(this.internTest);',\n\t\t\t\toptions\n\t\t\t); \n\n\t\t\tObject.defineProperty(this.benchmark, 'name', {\n\t\t\t\tget: function () {\n\t\t\t\t\treturn self.name;\n\t\t\t\t},\n\t\t\t\tset: function (name) {\n\t\t\t\t\tself.name = name;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tthis.benchmark.internTest = this;\n\t\t}\n\n\t\t// Call the superclass constructor with the set of kwArgs not specific to BenchmarkTest\n\t\tvar args = {};\n\t\tfor (var key in kwArgs) {\n\t\t\tswitch (key) {\n\t\t\tcase 'test':\n\t\t\tcase 'options':\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\targs[key] = kwArgs[key];\n\t\t\t}\n\t\t}\n\t\tTest.call(this, args);\n\t}\n\n\tBenchmarkTest.prototype = Object.create(Test.prototype, {\n\t\tconstructor: { value: BenchmarkTest },\n\n\t\terror: {\n\t\t\tget: function () {\n\t\t\t\tif (this.benchmark) {\n\t\t\t\t\treturn this.benchmark.error;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t},\n\n\t\ttimeElapsed: {\n\t\t\tget: function () {\n\t\t\t\tif (this.benchmark && this.benchmark.times) {\n\t\t\t\t\treturn this.benchmark.times.elapsed;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t},\n\n\t\tasync: {\n\t\t\tvalue: function () {\n\t\t\t\tthrow new Error('Benchmark tests must be marked as asynchronous and use the deferred passed to them rather than call `this.async()`.');\n\t\t\t}\n\t\t},\n\n\t\tskip: {\n\t\t\tvalue: function () {\n\t\t\t\tthrow new Error('Benchmark tests must be marked as skipped rather than call `this.skip()`.');\n\t\t\t}\n\t\t},\n\n\t\trun: {\n\t\t\tvalue: function () {\n\t\t\t\tfunction report(eventName) {\n\t\t\t\t\tif (reporterManager) {\n\t\t\t\t\t\tvar args = [ eventName, self ].concat(Array.prototype.slice.call(arguments, 1));\n\t\t\t\t\t\treturn reporterManager.emit.apply(reporterManager, args).catch(function () {});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\treturn Promise.resolve();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar reporterManager = this.reporterManager;\n\n\t\t\t\tthis.hasPassed = false;\n\n\t\t\t\tvar self = this;\n\t\t\t\tvar benchmark = this.benchmark;\n\n\t\t\t\treturn new Promise(function (resolve, reject, progress, setCanceler) {\n\t\t\t\t\tsetCanceler(function (reason) {\n\t\t\t\t\t\tbenchmark.error = reason;\n\t\t\t\t\t\tbenchmark.abort();\n\n\t\t\t\t\t\tthrow reason;\n\t\t\t\t\t});\n\n\t\t\t\t\tbenchmark.on('abort', function () {\n\t\t\t\t\t\treject(benchmark.error);\n\t\t\t\t\t});\n\n\t\t\t\t\tbenchmark.on('error', function () {\n\t\t\t\t\t\treject(benchmark.error);\n\t\t\t\t\t});\n\n\t\t\t\t\tbenchmark.on('complete', function () {\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t});\n\n\t\t\t\t\treport('testStart').then(function () {\n\t\t\t\t\t\tbenchmark.run();\n\t\t\t\t\t});\n\t\t\t\t}).finally(function () {\n\t\t\t\t\t// Stop listening for benchmark events once the test is finished\n\t\t\t\t\tbenchmark.off();\n\t\t\t\t}).then(function () {\n\t\t\t\t\tself.hasPassed = true;\n\n\t\t\t\t\treturn report('testPass', {\n\t\t\t\t\t\ttimes: self.benchmark.times,\n\t\t\t\t\t\thz: self.benchmark.hz,\n\t\t\t\t\t\tstats: self.benchmark.stats\n\t\t\t\t\t});\n\t\t\t\t}, function (error) {\n\t\t\t\t\treturn report('testFail', error).then(function () {\n\t\t\t\t\t\tthrow error;\n\t\t\t\t\t});\n\t\t\t\t}).finally(function () {\n\t\t\t\t\treturn report('testEnd');\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t});\n\n\t/* istanbul ignore next */\n\tfunction noop() {}\n\n\tfunction createDeferred(benchmark, deferred, numCallsUntilResolution) {\n\t\tif (!numCallsUntilResolution) {\n\t\t\tnumCallsUntilResolution = 1;\n\t\t}\n\n\t\treturn {\n\t\t\tresolve: function () {\n\t\t\t\t--numCallsUntilResolution;\n\t\t\t\tif (numCallsUntilResolution === 0) {\n\t\t\t\t\tdeferred.resolve();\n\t\t\t\t}\n\t\t\t\telse if (numCallsUntilResolution < 0) {\n\t\t\t\t\tthrow new Error('resolve called too many times');\n\t\t\t\t}\n\t\t\t},\n\n\t\t\treject: function (error) {\n\t\t\t\tbenchmark.error = error;\n\t\t\t\tbenchmark.abort();\n\t\t\t\tdeferred.resolve();\n\t\t\t},\n\n\t\t\tprogress: noop,\n\n\t\t\trejectOnError: function (callback) {\n\t\t\t\tvar self = this;\n\t\t\t\treturn function () {\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn callback.apply(this, arguments);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (error) {\n\t\t\t\t\t\tself.reject(error);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t},\n\n\t\t\tcallback: function (callback) {\n\t\t\t\tvar self = this;\n\t\t\t\treturn self.rejectOnError(function () {\n\t\t\t\t\tvar returnValue = callback.apply(this, arguments);\n\t\t\t\t\tself.resolve();\n\t\t\t\t\treturn returnValue;\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\t}\n\n\tBenchmarkTest.async = function (testFunction, numCallsUntilResolution) {\n\t\ttestFunction.options = lang.mixin({}, testFunction.options, {\n\t\t\tdefer: true,\n\t\t\tnumCallsUntilResolution: numCallsUntilResolution\n\t\t});\n\n\t\treturn testFunction;\n\t};\n\n\tBenchmarkTest.skip = function (testFunction, reason) {\n\t\tif (reason == null) {\n\t\t\treason = 'skipped';\n\t\t}\n\n\t\ttestFunction.options = lang.mixin({}, testFunction.options, {\n\t\t\tskip: reason\n\t\t});\n\n\t\treturn testFunction;\n\t};\n\n\treturn BenchmarkTest;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/lib/ClientSuite.js":"/* jshint node:true */\ndefine([\n\t'dojo/lang',\n\t'dojo/Promise',\n\t'dojo/node!url',\n\t'dojo/node!path',\n\t'dojo/aspect',\n\t'dojo/io-query',\n\t'./Suite'\n], function (lang, Promise, urlUtil, pathUtil, aspect, ioQuery, Suite) {\n\tfunction ClientSuite() {\n\t\tthis.config = {};\n\n\t\tSuite.apply(this, arguments);\n\t}\n\n\tvar _super = Suite.prototype;\n\tClientSuite.prototype = lang.mixin(Object.create(_super), /** @lends module:intern/lib/ClientSuite# */ {\n\t\tconstructor: ClientSuite,\n\t\tname: 'unit tests',\n\t\ttimeout: Infinity,\n\t\targs: null,\n\t\tconfig: null,\n\t\tproxy: null,\n\n\t\t// TODO: Change this from using Selenium-provided sessionId to self-generated constant identifier so that\n\t\t// sessions can be safely reset in the middle of a test run\n\t\trun: function () {\n\t\t\tvar self = this;\n\t\t\tvar reporterManager = this.reporterManager;\n\t\t\tvar config = this.config;\n\t\t\tvar remote = this.remote;\n\t\t\tvar sessionId = remote.session.sessionId;\n\n\t\t\tvar handle = this.proxy.subscribeToSession(sessionId, receiveEvent);\n\t\t\tvar dfd = new Promise.Deferred(function (reason) {\n\t\t\t\thandle.remove();\n\t\t\t\treturn remote.setHeartbeatInterval(0).then(function () {\n\t\t\t\t\tthrow reason;\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tfunction receiveEvent(name) {\n\t\t\t\tvar args = arguments;\n\t\t\t\tfunction forward() {\n\t\t\t\t\treturn reporterManager.emit.apply(reporterManager, args);\n\t\t\t\t}\n\n\t\t\t\tvar suite;\n\t\t\t\tswitch (name) {\n\t\t\t\t\tcase 'suiteStart':\n\t\t\t\t\t\tsuite = arguments[1];\n\t\t\t\t\t\t// The suite sent by the server is the root suite for the client-side unit tests; add its tests\n\t\t\t\t\t\t// to the runner-side client suite\n\t\t\t\t\t\tif (!suite.hasParent) {\n\t\t\t\t\t\t\tsuite.tests.forEach(function (test) {\n\t\t\t\t\t\t\t\tself.tests.push(test);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\treturn reporterManager.emit('suiteStart', self);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn forward();\n\n\t\t\t\t\tcase 'suiteEnd':\n\t\t\t\t\t\tsuite = arguments[1];\n\t\t\t\t\t\tself.skipped = suite.skipped;\n\n\t\t\t\t\t\t// The suite sent by the server is the root suite for the client-side unit tests; update the\n\t\t\t\t\t\t// existing test objects with the new ones from the server that reflect all the test results\n\t\t\t\t\t\tif (!suite.hasParent) {\n\t\t\t\t\t\t\tsuite.tests.forEach(function (test, index) {\n\t\t\t\t\t\t\t\tself.tests[index] = test;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn forward();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'suiteError':\n\t\t\t\t\t\tsuite = arguments[1];\n\t\t\t\t\t\tif (!suite.hasParent) {\n\t\t\t\t\t\t\thandle.remove();\n\t\t\t\t\t\t\treturn handleError(arguments[2]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn forward();\n\n\t\t\t\t\tcase 'runStart':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'runEnd':\n\t\t\t\t\t\thandle.remove();\n\t\t\t\t\t\tvar promise = remote.setHeartbeatInterval(0);\n\t\t\t\t\t\tif (config.excludeInstrumentation !== true) {\n\t\t\t\t\t\t\t// get about:blank to always collect code coverage data from the page in case it is\n\t\t\t\t\t\t\t// navigated away later by some other process; this happens during self-testing when\n\t\t\t\t\t\t\t// Leadfoot takes over\n\t\t\t\t\t\t\tpromise = promise.get('about:blank');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpromise.then(function () {\n\t\t\t\t\t\t\treturn reporterManager.emit('suiteEnd', self);\n\t\t\t\t\t\t}).then(function () {\n\t\t\t\t\t\t\tdfd.resolve();\n\t\t\t\t\t\t}, handleError);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'fatalError':\n\t\t\t\t\t\t// A fatalError in a suite is only fatal to the suite, so it's still basically a suiteError\n\t\t\t\t\t\thandle.remove();\n\t\t\t\t\t\tvar error = arguments[1];\n\t\t\t\t\t\treturn handleError(error);\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn forward();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction handleError(error) {\n\t\t\t\tself.error = error;\n\t\t\t\treturn self.reporterManager.emit('suiteError', self, error).then(function () {\n\t\t\t\t\tdfd.reject(error);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tvar proxyBasePath = urlUtil.parse(config.proxyUrl).pathname;\n\n\t\t\tvar clientReporter = this.config.runnerClientReporter;\n\t\t\tif (typeof clientReporter === 'object') {\n\t\t\t\t// Need to mixin the properties of `clientReporter` to a new object before stringify because\n\t\t\t\t// stringify only serialises an objectâ€™s own properties\n\t\t\t\tclientReporter = JSON.stringify(lang.mixin({}, clientReporter));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tclientReporter = 'WebDriver';\n\t\t\t}\n\n\t\t\tvar options = lang.mixin({}, this.args, {\n\t\t\t\t// the proxy always serves the baseUrl from the loader configuration as the root of the proxy,\n\t\t\t\t// so ensure that baseUrl is always set to that root on the client\n\t\t\t\tbasePath: proxyBasePath,\n\t\t\t\tinitialBaseUrl: proxyBasePath + pathUtil.relative(config.basePath, process.cwd()),\n\t\t\t\treporters: clientReporter,\n\t\t\t\trootSuiteName: self.id,\n\t\t\t\tsessionId: sessionId\n\t\t\t});\n\n\t\t\t// Intern runs unit tests on the remote Selenium server by navigating to the client runner HTML page. No\n\t\t\t// real commands are issued after the call to remote.get() below until all unit tests are complete, so\n\t\t\t// we need to make sure that we periodically send no-ops through the channel to ensure the remote server\n\t\t\t// does not treat the session as having timed out\n\t\t\tvar timeout = config.capabilities['idle-timeout'];\n\t\t\tif (timeout >= 1 && timeout < Infinity) {\n\t\t\t\tremote.setHeartbeatInterval((timeout - 1) * 1000);\n\t\t\t}\n\n\t\t\tremote\n\t\t\t\t.get(config.proxyUrl + '__intern/client.html?' + ioQuery.objectToQuery(options))\n\t\t\t\t.catch(function (error) {\n\t\t\t\t\thandle.remove();\n\t\t\t\t\tremote.setHeartbeatInterval(0).then(function () {\n\t\t\t\t\t\thandleError(error);\n\t\t\t\t\t});\n\t\t\t\t});\n\n\t\t\treturn dfd.promise;\n\t\t}\n\t});\n\n\treturn ClientSuite;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/lib/EnvironmentType.js":"define([], function () {\n\tfunction EnvironmentType(kwArgs) {\n\t\tfor (var k in kwArgs) {\n\t\t\tthis[k] = kwArgs[k];\n\t\t}\n\t}\n\n\tEnvironmentType.prototype = {\n\t\tconstructor: EnvironmentType,\n\t\tbrowserName: undefined,\n\t\tversion: undefined,\n\t\tplatform: undefined,\n\t\tplatformVersion: undefined,\n\t\ttoString: function () {\n\t\t\tvar parts = [];\n\n\t\t\tparts.push(this.browserName || 'Any browser');\n\t\t\tthis.version && parts.push(this.version);\n\t\t\tparts.push('on ' + (this.platform || 'any platform'));\n\t\t\tthis.platformVersion && parts.push(this.platformVersion);\n\n\t\t\treturn parts.join(' ');\n\t\t}\n\t};\n\n\treturn EnvironmentType;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/lib/exitHandler.js":"define([], function () {\n\treturn function (process, task, timeout) {\n\t\tvar cancelled = false;\n\n\t\tprocess.on('SIGINT', (function () {\n\t\t\tvar hurry = false;\n\t\t\treturn function () {\n\t\t\t\tcancelled = true;\n\n\t\t\t\tif (hurry) {\n\t\t\t\t\tconsole.warn('\\nShutting down immediately. You monster');\n\t\t\t\t\tprocess.exit(1);\n\t\t\t\t}\n\n\t\t\t\thurry = true;\n\t\t\t\tvar reason = new Error('SIGINT received');\n\t\t\t\treason.name = 'CancelError';\n\t\t\t\tconsole.warn('\\nShutting down gracefully; please wait or hit CTRL+C again to quit immediately');\n\t\t\t\ttask.cancel(reason);\n\t\t\t};\n\t\t})());\n\n\t\ttask.then(function (numFailedTests) {\n\t\t\tprocess.once('exit', function () {\n\t\t\t\tprocess.exit(cancelled || numFailedTests ? 1 : 0);\n\t\t\t});\n\t\t},\n\t\tfunction () {\n\t\t\tprocess.once('exit', function () {\n\t\t\t\tprocess.exit(2);\n\t\t\t});\n\t\t})\n\t\t.finally(function () {\n\t\t\tvar ref = setTimeout(function () {\n\t\t\t\tconsole.warn('Node.js hang detected; make sure to close all sockets, timers, and ' +\n\t\t\t\t\t'servers you opened during testing!');\n\t\t\t\tprocess.exit();\n\t\t\t}, timeout);\n\t\t\tref.unref();\n\t\t});\n\t};\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/lib/parseArgs.js":"define([], function () {\n\tfunction parseArguments(rawArgs, decode) {\n\t\tvar args = {};\n\t\trawArgs.forEach(function (arg) {\n\t\t\targ = arg.split('=');\n\n\t\t\tvar key = arg[0].replace(/^--?/, '');\n\t\t\tvar value;\n\n\t\t\t// Support boolean flags\n\t\t\tif (arg.length < 2) {\n\t\t\t\tvalue = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalue = decode(arg[1]);\n\n\t\t\t\t// Support JSON-encoded properties for reporter configuration\n\t\t\t\tif (value.charAt(0) === '{') {\n\t\t\t\t\tvalue = JSON.parse(value);\n\t\t\t\t}\n\t\t\t\telse if (value.slice(0, 2) === '\\\\{') {\n\t\t\t\t\tvalue = value.slice(1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Support multiple arguments with the same name\n\t\t\tif (key in args) {\n\t\t\t\tif (!Array.isArray(args[key])) {\n\t\t\t\t\targs[key] = [ args[key] ];\n\t\t\t\t}\n\n\t\t\t\targs[key].push(value);\n\t\t\t}\n\t\t\telse {\n\t\t\t\targs[key] = value;\n\t\t\t}\n\t\t});\n\n\t\treturn args;\n\t}\n\n\treturn {\n\t\tfromCommandLine: function (rawArgs) {\n\t\t\t/* globals process */\n\t\t\treturn parseArguments(rawArgs || process.argv.slice(2), function (string) {\n\t\t\t\treturn string;\n\t\t\t});\n\t\t},\n\t\tfromQueryString: function (query) {\n\t\t\treturn parseArguments(query.replace(/^\\?/, '').split('&'), function (string) {\n\t\t\t\t// Boolean properties should not be coerced into strings, but will be if they are passed to\n\t\t\t\t// decodeURIComponent\n\t\t\t\tif (typeof string === 'boolean') {\n\t\t\t\t\treturn string;\n\t\t\t\t}\n\n\t\t\t\treturn decodeURIComponent(string);\n\t\t\t});\n\t\t}\n\t};\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/lib/ProxiedSession.js":"define([\n\t'dojo/lang',\n\t'dojo/Promise',\n\t'dojo/node!leadfoot/Session'\n], function (lang, Promise, Session) {\n\t/* istanbul ignore next: client-side code */\n\tfunction getCoverageData(coverageVariable) {\n\t\tvar coverageData = (function () { return this; })()[coverageVariable];\n\t\treturn coverageData && JSON.stringify(coverageData);\n\t}\n\n\t/**\n\t * A ProxiedSession object represents a WebDriver session that interacts with the Intern instrumenting proxy. It\n\t * collects code instrumentation data from pages and converts local filesystem paths into URLs for use with\n\t * {@link module:leadfoot/Session#get}.\n\t *\n\t * @constructor module:intern/lib/ProxiedSession\n\t * @extends module:leadfoot/Session\n\t * @param {string} sessionId The ID of the session, as provided by the remote.\n\t * @param {module:leadfoot/Server} server The server that the session belongs to.\n\t * @param {Object} capabilities A map of bugs and features that the remote environment exposes.\n\t */\n\tfunction ProxiedSession() {\n\t\tSession.apply(this, arguments);\n\t}\n\n\tvar _super = Session.prototype;\n\tProxiedSession.prototype = lang.mixin(Object.create(_super), /** @lends module:intern/lib/ProxiedSession# */ {\n\t\tconstructor: ProxiedSession,\n\n\t\t/**\n\t\t * Indicate whether coverage data should be requested before performing a request.\n\t\t *\n\t\t * @type {boolean}\n\t\t */\n\t\tcoverageEnabled: false,\n\n\t\t/**\n\t\t * The name of the global variable used to store coverage data.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tcoverageVariable: '',\n\n\t\t_heartbeatIntervalHandle: null,\n\n\t\t/**\n\t\t * The number of characters that need to be truncated from the front of file paths to get a working path-part\n\t\t * for a URL.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tproxyBasePathLength: 0,\n\n\t\t/**\n\t\t * The base URL of the proxy server in use.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tproxyUrl: '',\n\n\t\treporterManager: null,\n\n\t\t/**\n\t\t * Navigates the browser to a new URL like {@link module:leadfoot/Session#get}, but retrieves any code coverage\n\t\t * data recorded by the browser prior to navigation.\n\t\t *\n\t\t * @param {string} url\n\t\t * @returns {Promise.<void>}\n\t\t */\n\t\tget: function () {\n\t\t\tvar self = this;\n\t\t\tvar args = Array.prototype.slice.call(arguments, 0);\n\n\t\t\t// At least two letters are required in the scheme to avoid Windows paths being misinterpreted as URLs\n\t\t\tif (!/^[A-Za-z][A-Za-z0-9+.-]+:/.test(args[0])) {\n\t\t\t\targs[0] = this.proxyUrl + args[0].slice(this.proxyBasePathLength);\n\t\t\t}\n\n\t\t\tif (this.coverageEnabled) {\n\t\t\t\tvar promise;\n\n\t\t\t\t// At least Safari will not inject user scripts for non http/https URLs, so we can't get coverage data.\n\t\t\t\tif (this.capabilities.brokenExecuteForNonHttpUrl) {\n\t\t\t\t\tpromise = this.getCurrentUrl().then(function (url) {\n\t\t\t\t\t\treturn (/^https?:/i).test(url);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpromise = Promise.resolve(true);\n\t\t\t\t}\n\n\t\t\t\treturn promise.then(function (shouldGetCoverage) {\n\t\t\t\t\tif (shouldGetCoverage) {\n\t\t\t\t\t\treturn self.execute(getCoverageData, [ self.coverageVariable ])\n\t\t\t\t\t\t\t.then(function (coverageData) {\n\t\t\t\t\t\t\t\treturn coverageData &&\n\t\t\t\t\t\t\t\tself.reporterManager.emit('coverage', self.sessionId, JSON.parse(coverageData));\n\t\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}).finally(function () {\n\t\t\t\t\treturn _super.get.apply(self, args);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn _super.get.apply(self, args);\n\t\t},\n\n\t\t/**\n\t\t * Quits the browser like {@link module:leadfoot/Session#quit}, but retrieves any code coverage data recorded\n\t\t * by the browser prior to quitting.\n\t\t *\n\t\t * @returns {Promise.<void>}\n\t\t */\n\t\tquit: function () {\n\t\t\tvar self = this;\n\t\t\treturn this\n\t\t\t\t.setHeartbeatInterval(0)\n\t\t\t\t.then(function () {\n\t\t\t\t\tif (self.coverageEnabled) {\n\t\t\t\t\t\treturn self.execute(getCoverageData, [ self.coverageVariable ]).then(function (coverageData) {\n\t\t\t\t\t\t\treturn coverageData &&\n\t\t\t\t\t\t\t\tself.reporterManager.emit('coverage', self.sessionId, JSON.parse(coverageData));\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.finally(function () {\n\t\t\t\t\treturn _super.quit.call(self);\n\t\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Sets up a timer to send no-op commands to the remote server on an interval to prevent long-running unit tests\n\t\t * from causing the session to time out.\n\t\t *\n\t\t * @param {number} delay\n\t\t * Amount of time to wait between heartbeats. Setting the delay to 0 will disable heartbeats.\n\t\t *\n\t\t * @returns {Promise.<void>}\n\t\t */\n\t\tsetHeartbeatInterval: function (delay) {\n\t\t\tthis._heartbeatIntervalHandle && this._heartbeatIntervalHandle.remove();\n\n\t\t\tif (delay) {\n\t\t\t\t// A heartbeat command is sent immediately when the interval is set because it is unknown how long ago\n\t\t\t\t// the last command was sent and it simplifies the implementation by requiring only one call to\n\t\t\t\t// `setTimeout`\n\t\t\t\tvar self = this;\n\t\t\t\t(function sendHeartbeat() {\n\t\t\t\t\tvar timeoutId;\n\t\t\t\t\tvar cancelled = false;\n\t\t\t\t\tvar startTime = Date.now();\n\n\t\t\t\t\tself._heartbeatIntervalHandle = {\n\t\t\t\t\t\tremove: function () {\n\t\t\t\t\t\t\tcancelled = true;\n\t\t\t\t\t\t\tclearTimeout(timeoutId);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tself.getCurrentUrl().then(function () {\n\t\t\t\t\t\tif (!cancelled) {\n\t\t\t\t\t\t\ttimeoutId = setTimeout(sendHeartbeat, delay - (Date.now() - startTime));\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t})();\n\t\t\t}\n\n\t\t\treturn Promise.resolve();\n\t\t}\n\t});\n\n\treturn ProxiedSession;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/lib/Proxy.js":"define([\n\t'require',\n\t'dojo/lang',\n\t'dojo/Promise',\n\t'dojo/node!http',\n\t'dojo/node!path',\n\t'dojo/node!fs',\n\t'dojo/node!mimetype',\n\t'dojo/node!url',\n\t'dojo/aspect',\n\t'./util'\n], function (require, lang, Promise, http, path, fs, mimetype, url, aspect, util) {\n\t/* jshint node:true */\n\n\tfunction Proxy(config) {\n\t\tthis.config = config;\n\t}\n\n\tProxy.prototype = {\n\t\tconstructor: Proxy,\n\n\t\t_codeCache: null,\n\t\t_sessions: null,\n\n\t\t_getSession: function (sessionId) {\n\t\t\tvar session = this._sessions[sessionId];\n\t\t\tif (!session) {\n\t\t\t\tsession = this._sessions[sessionId] = { lastSequence: -1, queue: {}, listeners: [] };\n\t\t\t}\n\n\t\t\treturn session;\n\t\t},\n\n\t\t_handler: function (request, response) {\n\t\t\tif (request.method === 'GET') {\n\t\t\t\tif (/\\/__resolveSuites__\\?/.test(request.url)) {\n\t\t\t\t\tthis._resolveSuites(request, response);\n\t\t\t\t}\n\t\t\t\telse if (/\\.js(?:$|\\?)/.test(request.url)) {\n\t\t\t\t\tthis._handleFile(request, response, this.config.instrument);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis._handleFile(request, response);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (request.method === 'HEAD') {\n\t\t\t\tthis._handleFile(request, response, false, true);\n\t\t\t}\n\t\t\telse if (request.method === 'POST') {\n\t\t\t\trequest.setEncoding('utf8');\n\n\t\t\t\tvar data = '';\n\t\t\t\trequest.on('data', function (chunk) {\n\t\t\t\t\tdata += chunk;\n\t\t\t\t});\n\n\t\t\t\tvar self = this;\n\t\t\t\trequest.on('end', function () {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvar messages = JSON.parse(data).map(function (messageString) {\n\t\t\t\t\t\t\treturn JSON.parse(messageString);\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tvar runnerReporterPromise = Promise.all(messages.map(function (message) {\n\t\t\t\t\t\t\treturn self._publishInSequence(message);\n\t\t\t\t\t\t}));\n\n\t\t\t\t\t\tvar shouldWait = messages.some(function (message) {\n\t\t\t\t\t\t\treturn util.getShouldWait(self.config.waitForRunner, message.payload);\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tif (shouldWait) {\n\t\t\t\t\t\t\trunnerReporterPromise.then(function () {\n\t\t\t\t\t\t\t\tresponse.statusCode = 204;\n\t\t\t\t\t\t\t\tresponse.end();\n\t\t\t\t\t\t\t}, function () {\n\t\t\t\t\t\t\t\tresponse.statusCode = 500;\n\t\t\t\t\t\t\t\tresponse.end();\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tresponse.statusCode = 204;\n\t\t\t\t\t\t\tresponse.end();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (error) {\n\t\t\t\t\t\tresponse.statusCode = 500;\n\t\t\t\t\t\tresponse.end();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresponse.statusCode = 501;\n\t\t\t\tresponse.end();\n\t\t\t}\n\t\t},\n\n\t\t_handleFile: function (request, response, instrument, omitContent) {\n\t\t\tfunction send(contentType, data) {\n\t\t\t\tresponse.writeHead(200, {\n\t\t\t\t\t'Content-Type': contentType,\n\t\t\t\t\t'Content-Length': Buffer.byteLength(data)\n\t\t\t\t});\n\t\t\t\tresponse.end(data);\n\t\t\t}\n\n\t\t\tvar file = /^\\/+([^?]*)/.exec(request.url)[1];\n\t\t\tvar wholePath;\n\t\t\tvar self = this;\n\n\t\t\tif (/^__intern\\//.test(file)) {\n\t\t\t\twholePath = path.join(require.toUrl('intern/'), file.replace(/^__intern\\//, ''));\n\t\t\t\tinstrument = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\twholePath = path.join(this.config.basePath, file);\n\t\t\t}\n\n\t\t\twholePath = util.normalizePath(wholePath);\n\n\t\t\tif (wholePath.charAt(wholePath.length - 1) === '/') {\n\t\t\t\twholePath += 'index.html';\n\t\t\t}\n\n\t\t\t// if the string passed to `excludeInstrumentation` changes here, it must also change in\n\t\t\t// `lib/executors/Executor.js`\n\t\t\tif (\n\t\t\t\tthis.config.excludeInstrumentation === true ||\n\t\t\t\t(\n\t\t\t\t\tthis.config.excludeInstrumentation &&\n\t\t\t\t\tthis.config.excludeInstrumentation.test(file)\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tinstrument = false;\n\t\t\t}\n\n\t\t\tvar contentType = mimetype.lookup(path.basename(wholePath)) || 'application/octet-stream';\n\t\t\tfs.stat(wholePath, function (error, stats) {\n\t\t\t\t// The proxy server was stopped before this file was served\n\t\t\t\tif (!self.server) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (error) {\n\t\t\t\t\tself._send404(response);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (instrument) {\n\t\t\t\t\tvar mtime = stats.mtime.getTime();\n\t\t\t\t\tif (self._codeCache[wholePath] && self._codeCache[wholePath].mtime === mtime) {\n\t\t\t\t\t\tsend(contentType, self._codeCache[wholePath].data);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tfs.readFile(wholePath, 'utf8', function (error, data) {\n\t\t\t\t\t\t\t// The proxy server was stopped in the middle of the file read\n\t\t\t\t\t\t\tif (!self.server) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (error) {\n\t\t\t\t\t\t\t\tself._send404(response);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// providing `wholePath` to the instrumenter instead of a partial filename is necessary because\n\t\t\t\t\t\t\t// lcov.info requires full path names as per the lcov spec\n\t\t\t\t\t\t\tdata = util.instrument(\n\t\t\t\t\t\t\t\tdata.toString('utf-8'),\n\t\t\t\t\t\t\t\twholePath,\n\t\t\t\t\t\t\t\tself.config.instrumenterOptions\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tself._codeCache[wholePath] = {\n\t\t\t\t\t\t\t\t// strictly speaking mtime could reflect a previous version, assume those race conditions are rare\n\t\t\t\t\t\t\t\tmtime: mtime,\n\t\t\t\t\t\t\t\tdata: data\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tsend(contentType, data);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tresponse.writeHead(200, {\n\t\t\t\t\t\t'Content-Type': contentType,\n\t\t\t\t\t\t'Content-Length': stats.size\n\t\t\t\t\t});\n\n\t\t\t\t\tif (omitContent) {\n\t\t\t\t\t\tresponse.end();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tfs.createReadStream(wholePath).pipe(response);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\t_publishInSequence: function (message) {\n\t\t\tvar session = this._getSession(message.sessionId);\n\n\t\t\tif (message.sequence <= session.lastSequence) {\n\t\t\t\tthrow new Error('Repeated sequence for session ' + message.sessionId + ': ' + session.lastSequence +\n\t\t\t\t\t' last ' + message.sequence + ' cur');\n\t\t\t}\n\n\t\t\tmessage.resolver = new Promise.Deferred(function (reason) {\n\t\t\t\tmessage.cancelled = true;\n\t\t\t\tthrow reason;\n\t\t\t});\n\n\t\t\tif (message.sequence > session.lastSequence + 1) {\n\t\t\t\tsession.queue[message.sequence] = message;\n\t\t\t\treturn message.resolver.promise;\n\t\t\t}\n\n\t\t\tvar triggerMessage = message;\n\n\t\t\tdo {\n\t\t\t\tsession.lastSequence = message.sequence;\n\t\t\t\tdelete session.queue[session.lastSequence];\n\n\t\t\t\tif (!message.cancelled) {\n\t\t\t\t\tmessage.resolver.resolve(Promise.all(session.listeners.map(function (listener) {\n\t\t\t\t\t\treturn listener.apply(null, message.payload);\n\t\t\t\t\t})));\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile ((message = session.queue[message.sequence + 1]));\n\n\t\t\treturn triggerMessage.resolver.promise;\n\t\t},\n\n\t\t_resolveSuites: function (request, response) {\n\t\t\tvar query = url.parse(request.url, true).query;\n\t\t\tvar suites = JSON.parse(query.suites);\n\t\t\tvar resolvedSuites = JSON.stringify(util.resolveModuleIds(suites));\n\t\t\tresponse.writeHead(200, {\n\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t'Content-Length': resolvedSuites.length\n\t\t\t});\n\t\t\tresponse.end(resolvedSuites);\n\t\t},\n\n\t\t_send404: function (response) {\n\t\t\tresponse.writeHead(404, {\n\t\t\t\t'Content-Type': 'text/html;charset=utf-8'\n\t\t\t});\n\t\t\tresponse.end('<!DOCTYPE html><title>404 Not Found</title><h1>404 Not Found</h1><!-- ' +\n\t\t\t\tnew Array(512).join('.') + ' -->');\n\t\t},\n\n\t\tstart: function () {\n\t\t\treturn new Promise(function (resolve) {\n\t\t\t\tvar server = this.server = http.createServer(lang.bind(this, '_handler'));\n\t\t\t\tthis._sessions = {};\n\t\t\t\tthis._codeCache = {};\n\n\t\t\t\tvar sockets = [];\n\n\t\t\t\t// If sockets are not manually destroyed then Node.js will keep itself running until they all expire\n\t\t\t\taspect.after(server, 'close', function () {\n\t\t\t\t\tvar socket;\n\t\t\t\t\twhile ((socket = sockets.pop())) {\n\t\t\t\t\t\tsocket.destroy();\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tserver.on('connection', function (socket) {\n\t\t\t\t\tsockets.push(socket);\n\n\t\t\t\t\t// Disabling Nagle improves server performance on low-latency connections, which are more common\n\t\t\t\t\t// during testing than high-latency connections\n\t\t\t\t\tsocket.setNoDelay(true);\n\n\t\t\t\t\tsocket.on('close', function () {\n\t\t\t\t\t\tvar index = sockets.indexOf(socket);\n\t\t\t\t\t\tindex !== -1 && sockets.splice(index, 1);\n\t\t\t\t\t});\n\t\t\t\t});\n\n\t\t\t\tserver.listen(this.config.port, resolve);\n\t\t\t}.bind(this));\n\t\t},\n\n\t\tstop: function () {\n\t\t\treturn new Promise(function (resolve) {\n\t\t\t\tif (this.server) {\n\t\t\t\t\tthis.server.close(resolve);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tresolve();\n\t\t\t\t}\n\n\t\t\t\tthis.server = this._codeCache = null;\n\t\t\t}.bind(this));\n\t\t},\n\n\t\tsubscribeToSession: function (sessionId, listener) {\n\t\t\tvar listeners = this._getSession(sessionId).listeners;\n\t\t\tlisteners.push(listener);\n\t\t\treturn {\n\t\t\t\tremove: function () {\n\t\t\t\t\tthis.remove = function () {};\n\t\t\t\t\tlang.pullFromArray(listeners, listener);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t};\n\n\treturn Proxy;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/lib/ReporterManager.js":"define([\n\t'dojo/has',\n\t'dojo/has!host-node?dojo/node!fs',\n\t'dojo/has!host-node?dojo/node!path',\n\t'dojo/has!host-node?dojo/node!istanbul/lib/report/common/defaults',\n\t'dojo/lang',\n\t'dojo/aspect',\n\t'dojo/Promise'\n], function (has, fs, pathUtil, istanbulDefaults, lang, aspect, Promise) {\n\tfunction noop() {}\n\n\t/**\n\t * A Reporter that wraps a legacy reporter definition object.\n\t */\n\tvar LegacyReporter = (function () {\n\t\t// topics that don't directly map to reporter events\n\t\tvar TOPIC_TO_EVENT = {\n\t\t\t'/test/new': 'newTest',\n\t\t\t'/suite/new': 'newSuite',\n\t\t\t'/client/end': 'runEnd',\n\t\t\t'/error': 'fatalError',\n\t\t\t'/runner/end': 'runEnd',\n\t\t\t'/runner/start': 'runStart',\n\t\t\t'/tunnel/stop': 'tunnelEnd',\n\t\t\tstart: 'run',\n\t\t\tstop: 'destroy'\n\t\t};\n\n\t\t/**\n\t\t * Converts a legacy Intern 2 reporter to an Intern 3 reporter instance.\n\t\t */\n\t\tfunction LegacyReporter(reporterMap) {\n\t\t\tvar callback;\n\t\t\tvar eventName;\n\n\t\t\t// add all of the properties on the reporterMap that look like topics or map to a known\n\t\t\t// reporter method (e.g., start)\n\t\t\tfor (var topicId in reporterMap) {\n\t\t\t\tcallback = reporterMap[topicId];\n\t\t\t\teventName = null;\n\n\t\t\t\tif (topicId in TOPIC_TO_EVENT) {\n\t\t\t\t\teventName = TOPIC_TO_EVENT[topicId];\n\t\t\t\t}\n\t\t\t\t// programmatically transform legacy topic ID to event name\n\t\t\t\telse if (topicId.charAt(0) === '/') {\n\t\t\t\t\teventName = topicId.slice(1).replace(/\\/(\\w)/g, function (_, firstLetter) {\n\t\t\t\t\t\treturn firstLetter.toUpperCase();\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\taspect.before(this, eventName, (function (callback) {\n\t\t\t\t\treturn function () {\n\t\t\t\t\t\treturn callback.apply(reporterMap, arguments);\n\t\t\t\t\t};\n\t\t\t\t})(callback));\n\t\t\t}\n\t\t}\n\n\t\treturn LegacyReporter;\n\t})();\n\n\t/**\n\t * A class that manages a set of reporters\n\t *\n\t * Standard events:\n\t *     coverage\n\t *     fatalError\n\t *     newSuite\n\t *     newTest\n\t *     proxyEnd\n\t *     proxyStart\n\t *     runEnd\n\t *     runStart\n\t *     start\n\t *     stop\n\t *     suiteEnd\n\t *     suiteError\n\t *     suiteStart\n\t *     testEnd\n\t *     testPass\n\t *     testSkip\n\t *     testStart\n\t *     tunnelDownloadProgress\n\t *     tunnelEnd\n\t *     tunnelStart\n\t *     tunnelStatus\n\t */\n\tfunction ReporterManager() {\n\t\tthis._earlyEvents = [];\n\t\tthis._reporters = [];\n\t}\n\n\tfunction defineLazyProperty(object, property, getter) {\n\t\tObject.defineProperty(object, property, {\n\t\t\tget: function () {\n\t\t\t\tvar value = getter.apply(this, arguments);\n\t\t\t\tObject.defineProperty(object, property, {\n\t\t\t\t\tvalue: value,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tenumerable: true\n\t\t\t\t});\n\t\t\t\treturn value;\n\t\t\t},\n\t\t\tconfigurable: true,\n\t\t\tenumerable: true\n\t\t});\n\t}\n\n\tReporterManager.prototype = {\n\t\tconstructor: ReporterManager,\n\t\t_earlyEvents: null,\n\t\t_reporters: null,\n\n\t\t/**\n\t\t * Add a reporter to the list of managed reporters.\n\t\t *\n\t\t * @param {string} name event name to emit\n\t\t */\n\t\tadd: function (Reporter, config) {\n\t\t\tfunction mkdir(dirname) {\n\t\t\t\tfunction isDirectory(pathname) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn fs.statSync(pathname).isDirectory();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (error) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdirname.split(pathUtil.sep).reduce(function (currentPath, part) {\n\t\t\t\t\tcurrentPath = pathUtil.join(currentPath, part);\n\t\t\t\t\tif (!isDirectory(currentPath)) {\n\t\t\t\t\t\tfs.mkdirSync(currentPath);\n\t\t\t\t\t}\n\t\t\t\t\treturn currentPath;\n\t\t\t\t}, '');\n\t\t\t}\n\n\t\t\tvar reporter;\n\n\t\t\tif (typeof Reporter === 'object') {\n\t\t\t\treporter = new LegacyReporter(Reporter);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconfig = Object.create(config);\n\t\t\t\tconfig.console = this._getConsole();\n\n\t\t\t\t// https://github.com/gotwarlost/istanbul/issues/358\n\t\t\t\tif ('watermarks' in config) {\n\t\t\t\t\tconfig.watermarks = lang.mixin(istanbulDefaults.watermarks(), config.watermarks);\n\t\t\t\t}\n\n\t\t\t\tif (has('host-node')) {\n\t\t\t\t\t/* jshint node:true */\n\t\t\t\t\tif (config.filename) {\n\t\t\t\t\t\tif (pathUtil.dirname(config.filename) !== '.') {\n\t\t\t\t\t\t\tmkdir(pathUtil.dirname(config.filename));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Lazily create the writable stream so we do not open an extra fd for reporters that use\n\t\t\t\t\t\t// `filename` directly and never touch `config.output`\n\t\t\t\t\t\tdefineLazyProperty(config, 'output', function () {\n\t\t\t\t\t\t\treturn fs.createWriteStream(config.filename);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// See theintern/intern#454; all \\r must be replaced by \\x1b[1G (cursor move to column 1)\n\t\t\t\t\t\t// on Windows due to a libuv bug\n\t\t\t\t\t\tvar write;\n\t\t\t\t\t\tif (process.platform === 'win32') {\n\t\t\t\t\t\t\twrite = function (data) {\n\t\t\t\t\t\t\t\tvar args;\n\t\t\t\t\t\t\t\tif (typeof data === 'string' && data.indexOf('\\r') !== -1) {\n\t\t\t\t\t\t\t\t\tdata = data.replace(/\\r/g, '\\x1b[1G');\n\t\t\t\t\t\t\t\t\targs = [ data ].concat(Array.prototype.slice.call(arguments, 1));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\targs = arguments;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treturn process.stdout.write.apply(process.stdout, args);\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\twrite = process.stdout.write.bind(process.stdout);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconfig.output = lang.delegate(process.stdout, {\n\t\t\t\t\t\t\twrite: write,\n\t\t\t\t\t\t\t// Allow reporters to call `end` regardless of whether or not they are outputting to file,\n\t\t\t\t\t\t\t// without an error for stdout (which cannot be closed)\n\t\t\t\t\t\t\tend: write\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (has('host-browser')) {\n\t\t\t\t\tdefineLazyProperty(config, 'output', function () {\n\t\t\t\t\t\tvar element = document.createElement('pre');\n\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\twrite: function (chunk, encoding, callback) {\n\t\t\t\t\t\t\t\telement.appendChild(document.createTextNode(chunk));\n\t\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tend: function (chunk, encoding, callback) {\n\t\t\t\t\t\t\t\telement.appendChild(document.createTextNode(chunk));\n\t\t\t\t\t\t\t\tdocument.body.appendChild(element);\n\t\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\treporter = new Reporter(config);\n\t\t\t}\n\n\t\t\tvar reporters = this._reporters;\n\t\t\treporters.push(reporter);\n\n\t\t\treturn {\n\t\t\t\tremove: function () {\n\t\t\t\t\tthis.remove = noop;\n\t\t\t\t\tlang.pullFromArray(reporters, reporter);\n\t\t\t\t\treturn reporter.destroy && reporter.destroy();\n\t\t\t\t}\n\t\t\t};\n\t\t},\n\n\t\tempty: function () {\n\t\t\tthis._reporters.forEach(function (reporter) {\n\t\t\t\treporter.destroy && reporter.destroy();\n\t\t\t});\n\t\t\tthis._reporters = [];\n\t\t},\n\n\t\t/**\n\t\t * Emit an event to all registered reporters that can respond to it.\n\t\t *\n\t\t * @param {string} name event name to emit\n\t\t * @returns {Promise.<void>}\n\t\t */\n\t\temit: function (name) {\n\t\t\tif (!this._reporters.length) {\n\t\t\t\tthis._earlyEvents.push(Array.prototype.slice.call(arguments, 0));\n\t\t\t\treturn Promise.resolve();\n\t\t\t}\n\n\t\t\tvar self = this;\n\t\t\tvar allArgs = arguments;\n\t\t\tvar args = Array.prototype.slice.call(allArgs, 1);\n\n\t\t\treturn Promise.all(this._reporters.map(function (reporter) {\n\t\t\t\tvar listener = reporter[name];\n\t\t\t\tvar sendArgs = args;\n\n\t\t\t\tif (!listener && reporter.$others) {\n\t\t\t\t\tlistener = reporter.$others;\n\t\t\t\t\tsendArgs = allArgs;\n\t\t\t\t}\n\n\t\t\t\tif (listener) {\n\t\t\t\t\t// In the case that a fatal error occurs and there are no reporters around that care,\n\t\t\t\t\t// the pre-executor will make a hail mary pass to try to get the information out by sending it to\n\t\t\t\t\t// the early error reporter if the error does not have a `reported` property\n\t\t\t\t\tif (name === 'fatalError' && args[0]) {\n\t\t\t\t\t\targs[0].reported = true;\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvar result = listener.apply(reporter, sendArgs);\n\t\t\t\t\t\tif (result && result.then && name !== 'reporterError') {\n\t\t\t\t\t\t\treturn result.then(null, function (error) {\n\t\t\t\t\t\t\t\treturn self.emit('reporterError', reporter, error);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (error) {\n\t\t\t\t\t\tif (name !== 'reporterError') {\n\t\t\t\t\t\t\treturn self.emit('reporterError', reporter, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn Promise.reject(error);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})).then(noop, noop);\n\t\t},\n\n\t\ton: function (eventName, listener) {\n\t\t\tvar reporter = {};\n\t\t\treporter[eventName] = listener;\n\n\t\t\tvar reporters = this._reporters;\n\t\t\treporters.push(reporter);\n\n\t\t\treturn {\n\t\t\t\tremove: function () {\n\t\t\t\t\tthis.remove = function () {};\n\t\t\t\t\tlang.pullFromArray(reporters, reporter);\n\t\t\t\t\treporters = reporter = null;\n\t\t\t\t}\n\t\t\t};\n\t\t},\n\n\t\t_getConsole: function () {\n\t\t\tif (typeof console !== 'undefined') {\n\t\t\t\treturn console;\n\t\t\t}\n\n\t\t\tvar fakeConsole = {};\n\n\t\t\t[\n\t\t\t\t'assert',\n\t\t\t\t'count',\n\t\t\t\t'dir',\n\t\t\t\t'error',\n\t\t\t\t'exception',\n\t\t\t\t'info',\n\t\t\t\t'log',\n\t\t\t\t'table',\n\t\t\t\t'time',\n\t\t\t\t'timeEnd',\n\t\t\t\t'trace',\n\t\t\t\t'warn'\n\t\t\t].forEach(function (key) {\n\t\t\t\tfakeConsole[key] = noop;\n\t\t\t});\n\n\t\t\treturn fakeConsole;\n\t\t},\n\n\t\trun: function () {\n\t\t\tvar self = this;\n\n\t\t\tfunction emitEarlyEvents() {\n\t\t\t\tvar promise = Promise.all(self._earlyEvents.map(function (event) {\n\t\t\t\t\treturn self.emit.apply(self, event);\n\t\t\t\t}));\n\t\t\t\tself._earlyEvents.splice(0, Infinity);\n\t\t\t\treturn promise.then(noop, noop);\n\t\t\t}\n\n\t\t\treturn this\n\t\t\t\t.emit('run')\n\t\t\t\t.then(emitEarlyEvents);\n\t\t}\n\t};\n\n\treturn ReporterManager;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/lib/resolveEnvironments.js":"define([\n\t'dojo/lang',\n\t'./EnvironmentType'\n], function (lang, EnvironmentType) {\n\t/**\n\t * A comparator for sorting numbers in ascending order\n\t */\n\tfunction ascendingNumbers(a, b) {\n\t\treturn a - b;\n\t}\n\n\t/**\n\t * Expands a range of versions using available environments\n\t */\n\tfunction expandVersionRange(left, right, availableVersions) {\n\t\tleft = Number(left);\n\t\tright = Number(right);\n\t\tif (availableVersions.indexOf(left) === -1 || availableVersions.indexOf(right) === -1) {\n\t\t\tthrow new Error('The version range ' + left + '..' + right + ' is unavailable');\n\t\t}\n\t\treturn availableVersions.filter(function (version) {\n\t\t\treturn version >= left && version <= right;\n\t\t});\n\t}\n\n\t/**\n\t * Resolves a version alias from a list of available versions.\n\t *\n\t * Assumes availableVersions is sorted in ascending order. Acceptable versions are:\n\t *\n\t *   - {number}\n\t *   - '{number}'\n\t *   - 'latest'\n\t *   - 'latest-{number}'\n\t *\n\t * @returns {number}\n\t */\n\tfunction resolveVersionAlias(version, availableVersions) {\n\t\tvar pieces = version.split('-');\n\t\tif (pieces.length > 2) {\n\t\t\tthrow new Error('Invalid alias syntax \"' + version + '\"');\n\t\t}\n\t\t\t\n\t\tpieces = pieces.map(function (piece) {\n\t\t\treturn piece.trim();\n\t\t});\n\n\t\tif (\n\t\t\t(pieces.length === 2 && (pieces[0] !== 'latest' || isNaN(pieces[1]))) ||\n\t\t\t(pieces.length === 1 && isNaN(pieces[0] && pieces[0] !== 'latest'))\n\t\t) {\n\t\t\tthrow new Error('invalid alias syntax \"' + version + '\"');\n\t\t}\n\n\t\tif (pieces[0] === 'latest') {\n\t\t\tvar offset = pieces.length === 2 ? Number(pieces[1]) : 0;\n\t\t\tif (offset > availableVersions.length) {\n\t\t\t\tvar message = 'Can\\'t get ' + version + '; ' + availableVersions.length + ' version';\n\t\t\t\tmessage += (availableVersions.length !== 1 ? 's are' : ' is') + ' available';\n\t\t\t\tthrow new Error(message);\n\t\t\t}\n\n\t\t\treturn availableVersions[availableVersions.length - 1 - offset];\n\t\t}\n\t\telse {\n\t\t\treturn Number(pieces[0]);\n\t\t}\n\t}\n\n\t/**\n\t * Splits a version into one or two version strings using the '..' delimiter\n\t *\n\t * @returns {string[]}\n\t */\n\tfunction splitVersions(versions) {\n\t\tversions = versions.split('..');\n\t\tif (versions.length > 2) {\n\t\t\tthrow new Error('Invalid version syntax');\n\t\t}\n\t\t\t\n\t\treturn versions.map(function (version) {\n\t\t\treturn version.trim();\n\t\t});\n\t}\n\n\t/**\n\t * Get a list of versions from a list of available environments filtered by the current environment.\n\t *\n\t * @param {Object} environment the environment for which versions should match\n\t * @param {Object[]} available a list of available environments\n\t * @returns {number[]} a list of version numbers from available filtered by the current environment\n\t */\n\tfunction getVersions(environment, available) {\n\t\tvar versions = {};\n\n\t\tavailable.filter(function (availableEnvironment) {\n\t\t\t// Return true if there are no mismatching keys\n\t\t\treturn !Object.keys(environment).filter(function (key) {\n\t\t\t\treturn key !== 'version';\n\t\t\t}).some(function (key) {\n\t\t\t\treturn (key in availableEnvironment) && availableEnvironment[key] !== environment[key];\n\t\t\t});\n\t\t}).forEach(function (environment) {\n\t\t\tversions[environment.version] = true;\n\t\t});\n\t\t\t\n\t\treturn Object.keys(versions).map(function (version) {\n\t\t\treturn Number(version);\n\t\t}).sort(ascendingNumbers);\n\t}\n\n\t/**\n\t * Resolves version aliases (e.g. latest, latest - 1) and version ranges (e.g. 36 .. latest or latest - 3 .. latest)\n\t * using the environment list returned by tunnel#getEnvironments().\n\t *\n\t * @param {Object} environment an object with an optional version property\n\t * @param {Object[]} available a list of enviornment available on the target service\n\t * @returns {Object} the environment with resolved version aliases\n\t */\n\tfunction resolveVersions(environment, available) {\n\t\tvar versions = environment.version;\n\t\tavailable = available || [];\n\t\t\n\t\tif (versions && isNaN(versions)) {\n\t\t\tvar availableVersions = getVersions(environment, available);\n\t\t\t\n\t\t\tversions = splitVersions(versions).map(function (version) {\n\t\t\t\treturn resolveVersionAlias(version, availableVersions);\n\t\t\t});\n\n\t\t\tif (versions.length === 2) {\n\t\t\t\tif (versions[0] > versions[1]) {\n\t\t\t\t\tthrow new Error('Invalid range [' + versions + '], must be in ascending order');\n\t\t\t\t}\n\t\t\t\n\t\t\t\tversions = expandVersionRange(versions[0], versions[1], availableVersions);\n\t\t\t}\n\t\t}\n\n\t\treturn versions;\n\t}\n\n\t/**\n\t * Builds permutations of an object by flattening properties holding array values into a collection of objects\n\t * representing all combinations of objects for all arrays in the object.\n\t *\n\t * @param base {Object} a base set of properties applied to each source\n\t * @param sources {Array.<Object>} a list of sources to flatten\n\t * @return {Object[]} a flattened collection of sources\n\t */\n\tfunction createPermutations(base, sources) {\n\t\t// If no expansion sources were given, the set of permutations consists of just the base\n\t\tif (!sources || sources.length === 0) {\n\t\t\treturn [ lang.mixin({}, base) ];\n\t\t}\n\n\t\t// Expand the permutation set for each source\n\t\treturn sources.map(function (source) {\n\t\t\treturn Object.keys(source).reduce(function (permutations, key) {\n\t\t\t\tif (Array.isArray(source[key])) {\n\t\t\t\t\t// For array values, create a copy of the permutation set for each array item, then use the\n\t\t\t\t\t// combination of these copies as the new value of `permutations`\n\t\t\t\t\tpermutations = source[key].map(function (value) {\n\t\t\t\t\t\treturn permutations.map(function (permutation) {\n\t\t\t\t\t\t\tvar clone = lang.mixin({}, permutation);\n\t\t\t\t\t\t\tclone[key] = value;\n\t\t\t\t\t\t\treturn clone;\n\t\t\t\t\t\t});\n\t\t\t\t\t}).reduce(function (newPermutations, keyPermutations) {\n\t\t\t\t\t\treturn newPermutations.concat(keyPermutations);\n\t\t\t\t\t}, []);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// For simple values, add the value to all current permutations\n\t\t\t\t\tpermutations.forEach(function (permutation) {\n\t\t\t\t\t\tpermutation[key] = source[key];\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn permutations;\n\t\t\t}, [ lang.mixin({}, base) ]);\n\t\t}).reduce(function (newPermutations, sourcePermutations) {\n\t\t\treturn newPermutations.concat(sourcePermutations);\n\t\t}, []);\n\t}\n\n\t/**\n\t * Resolves a collection of Intern test environments to a list of service environments\n\t *\n\t * @param {Object} capabilities a base set of capabilities for all environments\n\t * @param {Object[]} environments a list of user-requested enviromnents\n\t * @param {Object[]?} available a list of available environments\n\t * @returns {EnvironmentType} a list of flattened service environments\n\t */\n\tfunction resolveEnvironments(capabilities, environments, available) {\n\t\tenvironments = createPermutations(capabilities, environments);\n\n\t\t// Expand any version ranges or aliases in the environments.\n\t\tenvironments.forEach(function (environment) {\n\t\t\tenvironment.version = resolveVersions(environment, available);\n\t\t});\n\n\t\t// Perform a second round of permuting to handle any expanded version ranges\n\t\treturn createPermutations({}, environments).map(function (environment) {\n\t\t\treturn new EnvironmentType(environment);\n\t\t});\n\t}\n\t\n\treturn resolveEnvironments;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/lib/sendData.js":"define([\n\t'dojo/request',\n\t'dojo/Promise',\n\t'exports'\n], function (request, Promise, exports) {\n\t// Send a message, or schedule it to be sent. Return a promise that resolves when the message has been sent.\n\tfunction sendRequest(url) {\n\t\t// Send all buffered messages and empty the buffer. Note that the posted data will always be an array of\n\t\t// objects.\n\t\tfunction send() {\n\t\t\t// Some testing services have problems handling large message POSTs, so limit the maximum size of\n\t\t\t// each POST body to maxPostSize bytes. Always send at least one message, even if it's more than\n\t\t\t// maxPostSize bytes.\n\t\t\tfunction sendNextBlock() {\n\t\t\t\tvar block = [ messages.shift() ];\n\t\t\t\tvar size = block[0].length;\n\t\t\t\twhile (messages.length > 0 && size + messages[0].length < maxPostSize) {\n\t\t\t\t\tsize += messages[0].length;\n\t\t\t\t\tblock.push(messages.shift());\n\t\t\t\t}\n\n\t\t\t\treturn request.post(url, {\n\t\t\t\t\theaders: { 'Content-Type': 'application/json' },\n\t\t\t\t\tdata: JSON.stringify(block)\n\t\t\t\t}).then(function () {\n\t\t\t\t\tif (messages.length > 0) {\n\t\t\t\t\t\treturn sendNextBlock();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tvar messages = messageBuffer;\n\t\t\tmessageBuffer = [];\n\n\t\t\tactiveRequest = new Promise(function (resolve, reject) {\n\t\t\t\treturn sendNextBlock().then(function () {\n\t\t\t\t\tactiveRequest = null;\n\t\t\t\t\tresolve();\n\t\t\t\t}).catch(function (error) {\n\t\t\t\t\tactiveRequest = null;\n\t\t\t\t\treject(error);\n\t\t\t\t});\n\t\t\t});\n\n\t\t\treturn activeRequest;\n\t\t}\n\n\t\tif (activeRequest || pendingRequest) {\n\t\t\tif (!pendingRequest) {\n\t\t\t\t// Schedule another request after the active one completes\n\t\t\t\tpendingRequest = activeRequest.then(function () {\n\t\t\t\t\tpendingRequest = null;\n\t\t\t\t\treturn send();\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn pendingRequest;\n\t\t}\n\t\telse {\n\t\t\treturn send();\n\t\t}\n\t}\n\n\tvar activeRequest;\n\tvar maxPostSize = 50000;\n\tvar messageBuffer = [];\n\tvar pendingRequest;\n\tvar sequence = 0;\n\n\texports.getSequence = function () {\n\t\treturn sequence;\n\t};\n\n\texports.setSequence = function (_sequence) {\n\t\tsequence = _sequence;\n\t};\n\n\texports.setMaxPostSize = function (_maxPostSize) {\n\t\tmaxPostSize = _maxPostSize;\n\t};\n\n\texports.send = function (url, data, sessionId) {\n\t\tdata = data.map(function (item) {\n\t\t\treturn item instanceof Error ?\n\t\t\t\t{ name: item.name, message: item.message, stack: item.stack } : item;\n\t\t});\n\n\t\tmessageBuffer.push(JSON.stringify({\n\t\t\tsequence: sequence,\n\t\t\t// Although sessionId may be passed as part of the payload, it is passed in the message object as well to\n\t\t\t// allow the conduit to be fully separate and encapsulated from the rest of the code\n\t\t\tsessionId: sessionId,\n\t\t\tpayload: data\n\t\t}));\n\n\t\t// The sequence must not be incremented until after the data is successfully serialised, since an error\n\t\t// during serialisation might occur, which would mean the request is never sent, which would mean the\n\t\t// dispatcher on the server-side will stall because the sequence numbering will be wrong\n\t\tsequence++;\n\n\t\treturn sendRequest(url);\n\t};\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/lib/Suite.js":"define([\n\t'dojo/Promise',\n\t'./Test',\n\t'./util'\n], function (Promise, Test, util) {\n\tfunction Suite(kwArgs) {\n\t\tthis.tests = [];\n\t\tfor (var k in kwArgs) {\n\t\t\tthis[k] = kwArgs[k];\n\t\t}\n\n\t\tthis.reporterManager && this.reporterManager.emit('newSuite', this);\n\t}\n\n\t// BAIL_REASON needs to be a string so that Intern can tell when a remote has bailed during unit tests so that it\n\t// can skip functional tests.\n\tvar BAIL_REASON = 'bailed';\n\n\tSuite.prototype = {\n\t\tconstructor: Suite,\n\t\tname: null,\n\t\ttests: [],\n\t\tparent: null,\n\t\tsetup: null,\n\t\tbeforeEach: null,\n\t\tafterEach: null,\n\t\tteardown: null,\n\t\terror: null,\n\t\ttimeElapsed: null,\n\t\t_bail: null,\n\t\t_grep: null,\n\t\t_remote: null,\n\t\t_environmentType: null,\n\t\t_reporterManager: null,\n\n\t\t/**\n\t\t * If true, the suite will only publish its start topic after the setup callback has finished,\n\t\t * and will publish its end topic before the teardown callback has finished.\n\t\t */\n\t\tpublishAfterSetup: false,\n\n\t\t/**\n\t\t * A flag used to indicate whether a test run shoudl stop after a failed test.\n\t\t */\n\t\tget bail() {\n\t\t\treturn this._bail || (this.parent && this.parent.bail);\n\t\t},\n\n\t\tset bail(value) {\n\t\t\tthis._bail = value;\n\t\t},\n\n\t\t/**\n\t\t * A regular expression used to filter, by test ID, which tests are run.\n\t\t */\n\t\tget grep() {\n\t\t\treturn this._grep || (this.parent && this.parent.grep) || /.*/;\n\t\t},\n\n\t\tset grep(value) {\n\t\t\tthis._grep = value;\n\t\t},\n\n\t\t/**\n\t\t * The unique identifier of the suite, assuming all combinations of suite + test are unique.\n\t\t */\n\t\tget id() {\n\t\t\tvar name = [];\n\t\t\tvar object = this;\n\n\t\t\tdo {\n\t\t\t\tobject.name != null && name.unshift(object.name);\n\t\t\t} while ((object = object.parent));\n\n\t\t\treturn name.join(' - ');\n\t\t},\n\n\t\t/**\n\t\t * The unique identifier of the suite's parent.\n\t\t */\n\t\tget parentId() {\n\t\t\tvar parent = this.parent;\n\t\t\tif (parent) {\n\t\t\t\treturn parent.id;\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * The WebDriver interface for driving a remote environment. This value is only guaranteed to exist from the\n\t\t * setup/beforeEach/afterEach/teardown and test methods, since environments are not instantiated until they are\n\t\t * actually ready to be tested against.\n\t\t */\n\t\tget remote() {\n\t\t\treturn (this.parent && this.parent.remote) ? this.parent.remote : this._remote;\n\t\t},\n\n\t\tset remote(value) {\n\t\t\tif (this._remote) {\n\t\t\t\tthrow new Error('remote may only be set once per suite');\n\t\t\t}\n\n\t\t\tObject.defineProperty(this, '_remote', { value: value });\n\t\t},\n\n\t\t/**\n\t\t * The reporter manager that should receive lifecycle events from the Suite.\n\t\t */\n\t\tget reporterManager() {\n\t\t\treturn this._reporterManager || (this.parent && this.parent.reporterManager);\n\t\t},\n\n\t\tset reporterManager(value) {\n\t\t\tif (this._reporterManager) {\n\t\t\t\tthrow new Error('reporterManager may only be set once per suite');\n\t\t\t}\n\n\t\t\tObject.defineProperty(this, '_reporterManager', { value: value });\n\t\t},\n\n\t\t/**\n\t\t * The sessionId of the environment in which the suite executed.\n\t\t */\n\t\tget sessionId() {\n\t\t\treturn this.parent ? this.parent.sessionId :\n\t\t\t\tthis._sessionId ? this._sessionId :\n\t\t\t\tthis.remote ? this.remote.session.sessionId :\n\t\t\t\tnull;\n\t\t},\n\n\t\t/**\n\t\t * The sessionId may need to be overridden for suites proxied from client.js.\n\t\t */\n\t\tset sessionId(value) {\n\t\t\tObject.defineProperty(this, '_sessionId', { value: value });\n\t\t},\n\n\t\t/**\n\t\t * The total number of tests in this suite and any sub-suites. To get only the number of tests for this suite,\n\t\t * look at `this.tests.length`.\n\t\t */\n\t\tget numTests() {\n\t\t\tfunction reduce(numTests, test) {\n\t\t\t\treturn test.tests ? test.tests.reduce(reduce, numTests) : numTests + 1;\n\t\t\t}\n\n\t\t\treturn this.tests.reduce(reduce, 0);\n\t\t},\n\n\t\t/**\n\t\t * The total number of tests in this test suite and any sub-suites that have failed.\n\t\t */\n\t\tget numFailedTests() {\n\t\t\tfunction reduce(numFailedTests, test) {\n\t\t\t\treturn test.tests ?\n\t\t\t\t\ttest.tests.reduce(reduce, numFailedTests) :\n\t\t\t\t\t(test.hasPassed || test.skipped != null ? numFailedTests : numFailedTests + 1);\n\t\t\t}\n\n\t\t\treturn this.tests.reduce(reduce, 0);\n\t\t},\n\n\t\t/**\n\t\t * The total number of tests in this test suite and any sub-suites that were skipped.\n\t\t */\n\t\tget numSkippedTests() {\n\t\t\tfunction reduce(numSkippedTests, test) {\n\t\t\t\treturn test.tests ?\n\t\t\t\t\ttest.tests.reduce(reduce, numSkippedTests) :\n\t\t\t\t\t(test.skipped != null ? numSkippedTests + 1 : numSkippedTests);\n\t\t\t}\n\n\t\t\treturn this.tests.reduce(reduce, 0);\n\t\t},\n\n\t\t/**\n\t\t * Whether or not this suite has a parent (for parity with serialized Suites).\n\t\t */\n\t\tget hasParent() {\n\t\t\treturn Boolean(this.parent);\n\t\t},\n\n\t\tget timeout() {\n\t\t\tif (this._timeout != null) {\n\t\t\t\treturn this._timeout;\n\t\t\t}\n\t\t\telse if (this.parent) {\n\t\t\t\treturn this.parent.timeout;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn 30000;\n\t\t\t}\n\t\t},\n\n\t\tset timeout(value) {\n\t\t\tthis._timeout = value;\n\t\t},\n\n\t\t/**\n\t\t * Runs test suite in order:\n\t\t *\n\t\t * * setup\n\t\t * * for each test:\n\t\t *   * beforeEach\n\t\t *   * test\n\t\t *   * afterEach\n\t\t * * teardown\n\t\t *\n\t\t * If setup, beforeEach, afterEach, or teardown throw, the suite itself will be marked as failed\n\t\t * and no further tests in the suite will be executed.\n\t\t *\n\t\t * @returns {module:dojo/Promise}\n\t\t */\n\t\trun: function () {\n\t\t\tvar reporterManager = this.reporterManager;\n\t\t\tvar self = this;\n\t\t\tvar startTime;\n\n\t\t\tfunction runLifecycleMethod(suite, name, args) {\n\t\t\t\treturn new Promise(function (resolve) {\n\t\t\t\t\tvar dfd;\n\t\t\t\t\tvar timeout;\n\n\t\t\t\t\t// Provide a new Suite#async method for each call of a lifecycle method since there's no concept of\n\t\t\t\t\t// a Suite-wide async deferred as there is for Tests.\n\t\t\t\t\tsuite.async = function (_timeout) {\n\t\t\t\t\t\ttimeout = _timeout;\n\n\t\t\t\t\t\tdfd = util.createDeferred();\n\n\t\t\t\t\t\tsuite.async = function () {\n\t\t\t\t\t\t\treturn dfd;\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\treturn dfd;\n\t\t\t\t\t};\n\n\t\t\t\t\tvar returnValue = suite[name] && suite[name].apply(suite, args);\n\n\t\t\t\t\tif (dfd) {\n\t\t\t\t\t\t// If a timeout was set, async was called, so we should use the dfd created by the call to\n\t\t\t\t\t\t// manage the timeout.\n\t\t\t\t\t\tif (timeout) {\n\t\t\t\t\t\t\tvar timer = setTimeout(function () {\n\t\t\t\t\t\t\t\tdfd.reject(new Error('Timeout reached on ' + suite.id + '#' + name));\n\t\t\t\t\t\t\t}, timeout);\n\n\t\t\t\t\t\t\tdfd.promise.finally(function () {\n\t\t\t\t\t\t\t\ttimer && clearTimeout(timer);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// If the return value looks like a promise, resolve the dfd if the return value resolves\n\t\t\t\t\t\tif (returnValue && returnValue.then) {\n\t\t\t\t\t\t\treturnValue.then(\n\t\t\t\t\t\t\t\tfunction (value) {\n\t\t\t\t\t\t\t\t\tdfd.resolve(value);\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfunction (error) {\n\t\t\t\t\t\t\t\t\tdfd.reject(error);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturnValue = dfd.promise;\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve(returnValue);\n\t\t\t\t}).catch(function (error) {\n\t\t\t\t\t// Remove the async method since it should only be available within a lifecycle function call\n\t\t\t\t\tsuite.async = undefined;\n\n\t\t\t\t\tif (error !== Test.SKIP) {\n\t\t\t\t\t\treturn reportSuiteError(error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tfunction end() {\n\t\t\t\tself.timeElapsed = Date.now() - startTime;\n\t\t\t\treturn report('suiteEnd');\n\t\t\t}\n\n\t\t\tfunction report(eventName) {\n\t\t\t\tif (reporterManager) {\n\t\t\t\t\tvar args = [ eventName, self ].concat(Array.prototype.slice.call(arguments, 1));\n\t\t\t\t\treturn reporterManager.emit.apply(reporterManager, args);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn Promise.resolve();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction reportSuiteError(error) {\n\t\t\t\tself.error = error;\n\t\t\t\treturn report('suiteError', error).then(function () {\n\t\t\t\t\tthrow error;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tfunction runTestLifecycle(name, test) {\n\t\t\t\t// beforeEach executes in order parent -> child;\n\t\t\t\t// afterEach executes in order child -> parent\n\t\t\t\tvar orderMethod = name === 'beforeEach' ? 'push' : 'unshift';\n\n\t\t\t\t// LIFO queue\n\t\t\t\tvar suiteQueue = [];\n\t\t\t\tvar suite = self;\n\n\t\t\t\tdo {\n\t\t\t\t\tsuiteQueue[orderMethod](suite);\n\t\t\t\t}\n\t\t\t\twhile ((suite = suite.parent));\n\n\t\t\t\treturn new Promise(function (resolve, reject, progress, setCanceler) {\n\t\t\t\t\tvar current;\n\t\t\t\t\tvar firstError;\n\n\t\t\t\t\tsetCanceler(function (reason) {\n\t\t\t\t\t\tsuiteQueue.splice(0, suiteQueue.length);\n\t\t\t\t\t\tif (current) {\n\t\t\t\t\t\t\tcurrent.cancel(reason);\n\t\t\t\t\t\t\t// Wait for the current lifecycle to finish, then reject\n\t\t\t\t\t\t\treturn current.finally(function () {\n\t\t\t\t\t\t\t\tthrow reason;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthrow reason;\n\t\t\t\t\t});\n\n\t\t\t\t\tfunction handleError(error) {\n\t\t\t\t\t\tif (name === 'afterEach') {\n\t\t\t\t\t\t\tfirstError = firstError || error;\n\t\t\t\t\t\t\tnext();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfunction next() {\n\t\t\t\t\t\tvar suite = suiteQueue.pop();\n\n\t\t\t\t\t\tif (!suite) {\n\t\t\t\t\t\t\tfirstError ? reject(firstError) : resolve();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfunction runWithCatch() {\n\t\t\t\t\t\t\treturn runLifecycleMethod(suite, name, [ test ]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcurrent = runWithCatch().then(next, handleError);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext();\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tfunction runTests() {\n\t\t\t\tvar i = 0;\n\t\t\t\tvar tests = self.tests;\n\n\t\t\t\treturn new Promise(function (resolve, reject, progress, setCanceler) {\n\t\t\t\t\tvar current;\n\t\t\t\t\tvar firstError;\n\n\t\t\t\t\tsetCanceler(function (reason) {\n\t\t\t\t\t\ti = Infinity;\n\t\t\t\t\t\tif (current) {\n\t\t\t\t\t\t\tcurrent.cancel(reason);\n\t\t\t\t\t\t\t// Wait for the current test to finish, then reject\n\t\t\t\t\t\t\treturn current.finally(function () {\n\t\t\t\t\t\t\t\tthrow reason;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthrow reason;\n\t\t\t\t\t});\n\n\t\t\t\t\tfunction next() {\n\t\t\t\t\t\tvar test = tests[i++];\n\n\t\t\t\t\t\tif (!test) {\n\t\t\t\t\t\t\tfirstError ? reject(firstError) : resolve();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfunction reportAndContinue(error) {\n\t\t\t\t\t\t\t// An error may be associated with a deeper test already, in which case we do not\n\t\t\t\t\t\t\t// want to reassociate it with a more generic parent\n\t\t\t\t\t\t\tif (!error.relatedTest) {\n\t\t\t\t\t\t\t\terror.relatedTest = test;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfunction runWithCatch() {\n\t\t\t\t\t\t\t// Errors raised when running child tests should be reported but should not cause\n\t\t\t\t\t\t\t// this suiteâ€™s run to reject, since this suite itself has not failed.\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\treturn test.run().catch(reportAndContinue);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (error) {\n\t\t\t\t\t\t\t\treturn reportAndContinue(error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// If the suite will be skipped, mark the current test as skipped. This will skip both\n\t\t\t\t\t\t// individual tests and nested suites.\n\t\t\t\t\t\tif (self.skipped != null) {\n\t\t\t\t\t\t\ttest.skipped = self.skipped;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// test is a suite\n\t\t\t\t\t\tif (test.tests) {\n\t\t\t\t\t\t\tcurrent = runWithCatch();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// test is a single test\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (!self.grep.test(test.id)) {\n\t\t\t\t\t\t\t\ttest.skipped = 'grep';\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (test.skipped != null) {\n\t\t\t\t\t\t\t\treporterManager.emit('testSkip', test).then(next);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tcurrent = runTestLifecycle('beforeEach', test)\n\t\t\t\t\t\t\t\t.then(runWithCatch)\n\t\t\t\t\t\t\t\t.finally(function () {\n\t\t\t\t\t\t\t\t\treturn runTestLifecycle('afterEach', test);\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t.catch(function (error) {\n\t\t\t\t\t\t\t\t\tfirstError = firstError || error;\n\t\t\t\t\t\t\t\t\treturn reportAndContinue(error);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcurrent.then(function () {\n\t\t\t\t\t\t\tfunction skipRestOfSuite() {\n\t\t\t\t\t\t\t\tself.skipped = self.skipped != null ? self.skipped : BAIL_REASON;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// If the test was a suite and the suite was skipped due to bailing, skip the rest of this\n\t\t\t\t\t\t\t// suite\n\t\t\t\t\t\t\tif (test.tests && test.skipped === BAIL_REASON) {\n\t\t\t\t\t\t\t\tskipRestOfSuite();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// If the test errored and bail mode is enabled, skip the rest of this suite\n\t\t\t\t\t\t\telse if (test.error && self.bail) {\n\t\t\t\t\t\t\t\tskipRestOfSuite();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tnext();\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\tnext();\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tfunction setup() {\n\t\t\t\treturn runLifecycleMethod(self, 'setup');\n\t\t\t}\n\n\t\t\tfunction start() {\n\t\t\t\treturn report('suiteStart').then(function () {\n\t\t\t\t\tstartTime = Date.now();\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tfunction teardown() {\n\t\t\t\treturn runLifecycleMethod(self, 'teardown');\n\t\t\t}\n\n\t\t\t// Reset some state in case someone tries to re-run the same suite\n\t\t\t// TODO: Cancel any previous outstanding suite run\n\t\t\t// TODO: Test\n\t\t\tthis.error = this.timeElapsed = null;\n\n\t\t\treturn (function () {\n\t\t\t\tif (!self.publishAfterSetup) {\n\t\t\t\t\treturn start().then(setup);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn setup().then(start);\n\t\t\t\t}\n\t\t\t})()\n\t\t\t.then(runTests)\n\t\t\t.finally(function () {\n\t\t\t\tif (self.publishAfterSetup) {\n\t\t\t\t\treturn end().then(teardown);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn teardown().then(end);\n\t\t\t\t}\n\t\t\t})\n\t\t\t.then(function () {\n\t\t\t\treturn self.numFailedTests;\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Skips this suite.\n\t\t *\n\t\t * @param {String} message\n\t\t * If provided, will be stored in this suite's `skipped` property.\n\t\t */\n\t\tskip: function (message) {\n\t\t\tthis.skipped = message || 'suite skipped';\n\t\t\t// Use the SKIP constant from Test so that calling Suite#skip from a test won't fail the test.\n\t\t\tthrow Test.SKIP;\n\t\t},\n\n\t\ttoJSON: function () {\n\t\t\treturn {\n\t\t\t\tname: this.name,\n\t\t\t\tid: this.id,\n\t\t\t\tparentId: this.parentId,\n\t\t\t\tsessionId: this.sessionId,\n\t\t\t\thasParent: Boolean(this.parent),\n\t\t\t\ttests: this.tests.map(function (test) {\n\t\t\t\t\treturn test.toJSON();\n\t\t\t\t}),\n\t\t\t\ttimeElapsed: this.timeElapsed,\n\t\t\t\tnumTests: this.numTests,\n\t\t\t\tnumFailedTests: this.numFailedTests,\n\t\t\t\tnumSkippedTests: this.numSkippedTests,\n\t\t\t\tskipped: this.skipped,\n\t\t\t\terror: this.error ? {\n\t\t\t\t\tname: this.error.name,\n\t\t\t\t\tmessage: this.error.message,\n\t\t\t\t\tstack: this.error.stack,\n\t\t\t\t\t// relatedTest can be the Suite itself in the case of nested suites (a nested Suite's error is\n\t\t\t\t\t// caught by a parent Suite, which assigns the nested Suite as the relatedTest, resulting in\n\t\t\t\t\t// nestedSuite.relatedTest === nestedSuite); in that case, don't serialize it\n\t\t\t\t\trelatedTest: this.error.relatedTest === this ? undefined : this.error.relatedTest\n\t\t\t\t} : null\n\t\t\t};\n\t\t}\n\t};\n\n\treturn Suite;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/lib/util.js":"/* jshint node: true */\ndefine([\n\t'dojo/has',\n\t'dojo/lang',\n\t'dojo/Promise',\n\t'./EnvironmentType',\n\t'../main',\n\t'diff',\n\t'dojo/has!host-node?dojo/node!glob',\n\t'dojo/has!host-node?dojo/node!path',\n\t'dojo/has!host-node?dojo/node!istanbul/lib/hook',\n\t'dojo/has!host-node?dojo/node!istanbul/lib/instrumenter',\n\t'dojo/has!host-node?dojo/node!source-map',\n\t'dojo/has!host-node?dojo/node!fs'\n], function (\n\thas,\n\tlang,\n\tPromise,\n\tEnvironmentType,\n\tintern,\n\tdiffUtil,\n\tglob,\n\tpathUtil,\n\thook,\n\tInstrumenter,\n\tsourceMap,\n\tfs\n) {\n\thas.add('function-name', function () {\n\t\tfunction foo() {}\n\t\treturn foo.name === 'foo';\n\t});\n\n\tvar instrumentationSourceMap = {};\n\tvar fileSourceMaps = {};\n\tvar fileSources = {};\n\tvar instrumenters = {};\n\n\t/**\n\t * Creates a serialised representation of an object.\n\t *\n\t * @param {Object} object The object to serialise.\n\t * @returns {string} A canonical, serialised representation of the object.\n\t */\n\tfunction serialize(object) {\n\t\tvar indent = '';\n\t\tvar output = '';\n\t\tvar stack = [];\n\n\t\tfunction writeDate(value) {\n\t\t\toutput += value.toISOString();\n\t\t}\n\n\t\tfunction writeObject(object) {\n\t\t\t// jshint maxcomplexity:12\n\n\t\t\tif (stack.indexOf(object) > -1) {\n\t\t\t\toutput += '[Circular]';\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar isArray = Array.isArray(object);\n\t\t\tvar isFunction = typeof object === 'function';\n\n\t\t\tif (isArray) {\n\t\t\t\toutput += '[';\n\t\t\t}\n\t\t\telse if (isFunction) {\n\t\t\t\toutput += (has('function-name') ? (object.name || '<anonymous>') : '<function>') + '({';\n\t\t\t}\n\t\t\telse {\n\t\t\t\toutput += '{';\n\t\t\t}\n\n\t\t\tvar keys = Object.keys(object);\n\n\t\t\tif (keys.length || isArray) {\n\t\t\t\tstack.push(object);\n\t\t\t\tindent += '  ';\n\n\t\t\t\tkeys.sort(function (a, b) {\n\t\t\t\t\t// Sort numeric keys to the top, in numeric order, to display arrays in their natural sort order\n\t\t\t\t\tif (!isNaN(a) && !isNaN(b)) {\n\t\t\t\t\t\treturn a - b;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!isNaN(a) && isNaN(b)) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (isNaN(a) && !isNaN(b)) {\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (a < b) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (a > b) {\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn 0;\n\t\t\t\t}).forEach(function (key, index) {\n\t\t\t\t\toutput += (index > 0 ? ',' : '') + '\\n' + indent;\n\t\t\t\t\tisArray && !isNaN(key) ? writePrimitive(key) : writeString(key);\n\t\t\t\t\toutput += ': ';\n\t\t\t\t\twrite(object[key]);\n\t\t\t\t});\n\n\t\t\t\tif (isArray) {\n\t\t\t\t\toutput += (keys.length ? ',' : '') + '\\n' + indent;\n\t\t\t\t\twritePrimitive('length');\n\t\t\t\t\toutput += ': ';\n\t\t\t\t\twrite(object.length);\n\t\t\t\t}\n\n\t\t\t\toutput += '\\n';\n\t\t\t\tindent = indent.slice(0, -2);\n\t\t\t\tstack.pop();\n\n\t\t\t\toutput += indent;\n\t\t\t}\n\n\t\t\tif (isArray) {\n\t\t\t\toutput += ']';\n\t\t\t}\n\t\t\telse if (isFunction) {\n\t\t\t\toutput += '})';\n\t\t\t}\n\t\t\telse {\n\t\t\t\toutput += '}';\n\t\t\t}\n\t\t}\n\n\t\tfunction writePrimitive(value) {\n\t\t\toutput += String(value);\n\t\t}\n\n\t\tfunction writeString(value) {\n\t\t\toutput += JSON.stringify(String(value));\n\t\t}\n\n\t\tfunction write(value) {\n\t\t\tswitch (typeof value) {\n\t\t\t\tcase 'object':\n\t\t\t\tcase 'function':\n\t\t\t\t\tif (value === null) {\n\t\t\t\t\t\twritePrimitive(value);\n\t\t\t\t\t}\n\t\t\t\t\telse if (value instanceof Date) {\n\t\t\t\t\t\twriteDate(value);\n\t\t\t\t\t}\n\t\t\t\t\telse if (value instanceof RegExp) {\n\t\t\t\t\t\twritePrimitive(value);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twriteObject(value);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'string':\n\t\t\t\t\twriteString(value);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\twritePrimitive(value);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\twrite(object);\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a unified diff to explain the difference between two objects.\n\t *\n\t * @param {Object} actual The actual result.\n\t * @param {Object} expected The expected result.\n\t * @returns {string} A unified diff formatted string representing the difference between the two objects.\n\t */\n\tfunction createDiff(actual, expected) {\n\t\tactual = serialize(actual);\n\t\texpected = serialize(expected);\n\n\t\tvar diff = diffUtil\n\t\t\t.createPatch('', actual + '\\n', expected + '\\n')\n\t\t\t// diff header, first range information section, and EOF newline are not relevant for serialised object\n\t\t\t// diffs\n\t\t\t.split('\\n')\n\t\t\t.slice(5, -1)\n\t\t\t.join('\\n')\n\t\t\t// range information is not relevant for serialised object diffs\n\t\t\t.replace(/^@@[^@]*@@$/gm, '[...]');\n\n\t\t// If the diff is empty now, running the next replacement will cause it to have some extra whitespace, which\n\t\t// makes it harder than it needs to be for callers to know if the diff is empty\n\t\tif (diff) {\n\t\t\t// + and - are not super clear about which lines are the expected object and which lines are the actual\n\t\t\t// object, and bump directly into code with no indentation, so replace the characters and add space\n\t\t\tdiff = diff.replace(/^([+-]?)(.*)$/gm, function (_, indicator, line) {\n\t\t\t\tif (line === '[...]') {\n\t\t\t\t\treturn line;\n\t\t\t\t}\n\n\t\t\t\treturn (indicator === '+' ? 'E' : indicator === '-' ? 'A' : '') + ' ' + line;\n\t\t\t});\n\t\t}\n\n\t\treturn diff;\n\t}\n\n\t/**\n\t * Return the instrumenter, creating it if necessary.\n\t */\n\tfunction getInstrumenter(instrumenterOptions) {\n\t\tinstrumenterOptions = instrumenterOptions || {};\n\n\t\tvar coverageVariable = instrumenterOptions.coverageVariable;\n\n\t\tif (!instrumenters[coverageVariable]) {\n\t\t\tvar options = lang.mixin({\n\t\t\t\t// coverage variable is changed primarily to avoid any jshint complaints, but also to make\n\t\t\t\t// it clearer where the global is coming from\n\t\t\t\tcoverageVariable: coverageVariable,\n\n\t\t\t\t// compacting code makes it harder to look at but it does not really matter\n\t\t\t\tnoCompact: true,\n\n\t\t\t\t// auto-wrap breaks code\n\t\t\t\tnoAutoWrap: true\n\t\t\t}, instrumenterOptions);\n\n\t\t\tinstrumenters[coverageVariable] = new Instrumenter(options);\n\t\t}\n\t\treturn instrumenters[coverageVariable];\n\t}\n\n\t/**\n\t * Return a new SourceMapConsumer for a given source map string.\n\t */\n\tfunction loadSourceMap(data) {\n\t\treturn new sourceMap.SourceMapConsumer(data);\n\t}\n\n\t/**\n\t * Get the original position of line:column based on map.\n\t *\n\t * Assumes mappings are is in order by generatedLine, then by generatedColumn; maps created with\n\t * SourceMapConsumer.eachMapping should be in this order by default.\n\t */\n\tfunction getOriginalPosition(map, line, column) {\n\t\tvar originalPosition = map.originalPositionFor({ line: line, column: column});\n\n\t\t// if the SourceMapConsumer was able to find a location, return it\n\t\tif (originalPosition.line !== null) {\n\t\t\treturn originalPosition;\n\t\t}\n\n\t\tvar entries = [];\n\n\t\t// find all map entries that apply to the given line in the generated output\n\t\tmap.eachMapping(function (entry) {\n\t\t\tif (entry.generatedLine === line) {\n\t\t\t\tentries.push(entry);\n\t\t\t}\n\t\t}, null, map.GENERATED_ORDER);\n\n\t\tif (entries.length === 0) {\n\t\t\t// no valid mappings exist -- return the line and column arguments\n\t\t\treturn { line: line, column: column };\n\t\t}\n\n\t\toriginalPosition = entries[0];\n\n\t\t// Chrome/Node.js column is at the start of the term that generated the exception\n\t\t// IE column is at the beginning of the expression/line with the exceptional term\n\t\t// Safari column number is just after the exceptional term\n\t\t//   - need to go back one element in the mapping\n\t\t// Firefox, PhantomJS have no column number\n\t\t//   - for no col number, find the largest original line number for the generated line\n\n\t\tif (column !== null) {\n\t\t\t// find the most likely mapping for the given generated line and column\n\t\t\tvar entry;\n\t\t\tfor (var i = 1; i < entries.length; i++) {\n\t\t\t\tentry = entries[i];\n\t\t\t\tif (column > originalPosition.generatedColumn && column >= entry.generatedColumn) {\n\t\t\t\t\toriginalPosition = entry;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tline: originalPosition.originalLine,\n\t\t\tcolumn: originalPosition.originalColumn,\n\t\t\tsource: originalPosition.source\n\t\t};\n\t}\n\n\t/**\n\t * Load and process the source map for a given file.\n\t */\n\tfunction getSourceMap(filepath) {\n\t\tvar data;\n\t\tvar lines;\n\t\tvar lastLine;\n\t\tvar match;\n\t\tvar sourceMapRegEx = /(?:\\/{2}[#@]{1,2}|\\/\\*)\\s+sourceMappingURL\\s*=\\s*(data:(?:[^;]+;)+base64,)?(\\S+)/;\n\n\t\tif (filepath in fileSourceMaps) {\n\t\t\treturn fileSourceMaps[filepath];\n\t\t}\n\n\t\ttry {\n\t\t\tif (filepath in fileSources) {\n\t\t\t\tdata = fileSources[filepath];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdata = fs.readFileSync(filepath).toString('utf-8');\n\t\t\t\tfileSources[filepath] = data;\n\t\t\t}\n\n\t\t\tlines = data.trim().split('\\n');\n\t\t\tlastLine = lines[lines.length - 1];\n\n\t\t\tif ((match = sourceMapRegEx.exec(lastLine))) {\n\t\t\t\tif (match[1]) {\n\t\t\t\t\tdata = JSON.parse((new Buffer(match[2], 'base64').toString('utf8')));\n\t\t\t\t\tfileSourceMaps[filepath] = loadSourceMap(data);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// treat map file path as relative to the source file\n\t\t\t\t\tvar mapFile = pathUtil.join(pathUtil.dirname(filepath), match[2]);\n\t\t\t\t\tdata = fs.readFileSync(mapFile);\n\t\t\t\t\tfileSourceMaps[filepath] = loadSourceMap(data.toString('utf-8'));\n\t\t\t\t}\n\t\t\t\treturn fileSourceMaps[filepath];\n\t\t\t}\n\t\t}\n\t\tcatch (error) {\n\t\t\t// this is normal for files like node.js -- just return null\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Dereference the source from a traceline.\n\t */\n\tfunction getSource(tracepath) {\n\t\t/* jshint maxcomplexity:13 */\n\t\tvar match;\n\t\tvar source;\n\t\tvar line;\n\t\tvar col;\n\t\tvar map;\n\t\tvar originalPos;\n\t\tvar result;\n\n\t\tif (tracepath === '<anonymous>') {\n\t\t\treturn 'anonymous';\n\t\t}\n\n\t\tif (!(match = /^(.*?):(\\d+)(:\\d+)?$/.exec(tracepath))) {\n\t\t\t// no line or column data\n\t\t\treturn tracepath;\n\t\t}\n\n\t\ttracepath = match[1];\n\t\tline = Number(match[2]);\n\t\tcol = match[3] ? Number(match[3].substring(1)) : null;\n\n\t\t// strip the host when we have a URL\n\n\t\tif ((match = /^\\w+:\\/\\/[^\\/]+\\/(.*)$/.exec(tracepath))) {\n\t\t\t// resolve the URL path to a filesystem path\n\t\t\ttracepath = pathUtil ? pathUtil.resolve(match[1]) : match[1];\n\t\t}\n\n\t\tif (has('host-browser')) {\n\t\t\t// no further processing in browser environments\n\t\t\treturn tracepath + ':' + line + (col == null ? '' : ':' + col);\n\t\t}\n\n\t\tsource = pathUtil.relative('.', tracepath);\n\n\t\t// first, check for an instrumentation source map\n\t\tif (tracepath in instrumentationSourceMap) {\n\t\t\tmap = instrumentationSourceMap[tracepath];\n\t\t\toriginalPos = getOriginalPosition(map, line, col);\n\t\t\tline = originalPos.line;\n\t\t\tcol = originalPos.column;\n\t\t\tif (originalPos.source) {\n\t\t\t\tsource = originalPos.source;\n\t\t\t}\n\t\t}\n\n\t\t// next, check for original source map\n\t\tif ((map = getSourceMap(tracepath))) {\n\t\t\toriginalPos = getOriginalPosition(map, line, col);\n\t\t\tline = originalPos.line;\n\t\t\tcol = originalPos.column;\n\t\t\tif (originalPos.source) {\n\t\t\t\tsource = pathUtil.join(pathUtil.dirname(source), originalPos.source);\n\t\t\t}\n\t\t}\n\n\t\tresult = source + ':' + line;\n\t\tif (col !== null) {\n\t\t\tresult += ':' + col;\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Return a trace line in a standardized format.\n\t */\n\tfunction formatLine(data) {\n\t\tif (!data.func) {\n\t\t\treturn '  at <' + getSource(data.source) + '>';\n\t\t}\n\t\treturn '  at ' + data.func + '  <' + getSource(data.source) + '>';\n\t}\n\n\t/**\n\t * Process Chrome, Opera, and IE traces.\n\t */\n\tfunction processChromeTrace(lines) {\n\t\tvar stack = [];\n\t\tvar match;\n\t\tvar line;\n\t\tfor (var i = 0; i < lines.length; i++) {\n\t\t\tline = lines[i];\n\t\t\tif ((match = /^\\s*at (.+?) \\(([^)]+)\\)$/.exec(line))) {\n\t\t\t\tstack.push(formatLine({ func: match[1], source: match[2] }));\n\t\t\t}\n\t\t\telse if ((match = /^\\s*at (.*)/.exec(line))) {\n\t\t\t\tstack.push(formatLine({ source: match[1] }));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstack.push(line);\n\t\t\t}\n\t\t}\n\t\treturn stack;\n\t}\n\n\t/**\n\t * Process Safari and Firefox traces.\n\t */\n\tfunction processSafariTrace(lines) {\n\t\tvar stack = [];\n\t\tvar match;\n\t\tvar line;\n\t\tfor (var i = 0; i < lines.length; i++) {\n\t\t\tline = lines[i];\n\t\t\tif ((match = /^([^@]+)@(.*)/.exec(line))) {\n\t\t\t\tstack.push(formatLine({ func: match[1], source: match[2] }));\n\t\t\t}\n\t\t\telse if ((match = /^(\\w+:\\/\\/.*)/.exec(line))) {\n\t\t\t\tstack.push(formatLine({ source: match[1] }));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstack.push(line);\n\t\t\t}\n\t\t}\n\t\treturn stack;\n\t}\n\n\t/**\n\t * Parse a stack trace, apply any source mappings, and normalize its format.\n\t */\n\tfunction normalizeStackTrace(stack, filterStack) {\n\t\tvar lines = stack.replace(/\\s+$/, '').split('\\n');\n\t\tvar firstLine = '';\n\n\t\tif (/^(?:[A-Z]\\w+)?Error: /.test(lines[0])) {\n\t\t\t// ignore the first line if it's just the Error name\n\t\t\tfirstLine = lines[0] + '\\n';\n\t\t\tlines = lines.slice(1);\n\t\t}\n\n\t\t// strip leading blank lines\n\t\twhile (/^\\s*$/.test(lines[0])) {\n\t\t\tlines = lines.slice(1);\n\t\t}\n\n\t\tstack = /^\\s*at /.test(lines[0]) ? processChromeTrace(lines) : processSafariTrace(lines);\n\n\t\tif (filterStack) {\n\t\t\tstack = stack.filter(function (line) {\n\t\t\t\treturn !(\n\t\t\t\t\t/internal\\/process\\//.test(line) ||\n\t\t\t\t\t/browser_modules\\//.test(line) ||\n\t\t\t\t\t/node_modules\\//.test(line)\n\t\t\t\t);\n\t\t\t});\n\t\t}\n\n\t\treturn '\\n' + firstLine + stack.join('\\n');\n\t}\n\n\tfunction isAbsoluteUrl(url) {\n\t\treturn /^(?:\\w+:)?\\/\\//.test(url);\n\t}\n\n\t/**\n\t * Return true if the module ID is a glob expression. This is similar to node-glob.hasMagic, but considers some\n\t * special cases for AMD identifiers, like 'dojo/has!host-node?fs'.\n\t */\n\tfunction isGlobModuleId(moduleId) {\n\t\t// Ignore empty moduleIds, absolute URLs, and loader plugins, where a loader plugin MID contains a '!' after a\n\t\t// word character, and the '!' is not immediately followed by a parenthesized expression.\n\t\tif (!moduleId || isAbsoluteUrl(moduleId) || /\\w!(?!\\([^)]+\\))/.test(moduleId)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Return true if a glob special character or pattern is present in the module ID. Recognized patterns are\n\t\t// approximately those of node-glob (see https://github.com/isaacs/node-glob).\n\t\treturn moduleId.indexOf('*') !== -1 ||\n\t\t\tmoduleId.indexOf('?') !== -1 ||\n\t\t\t/\\[[^\\]]+\\]/.test(moduleId) ||\n\t\t\t/{[^}]+}/.test(moduleId) ||\n\t\t\t/[!?+*@]\\([^)]+\\)/.test(moduleId);\n\t}\n\n\t/**\n\t * @borrows serialize as serialize\n\t */\n\treturn {\n\t\tserialize: serialize,\n\n\t\tisAbsoluteUrl: isAbsoluteUrl,\n\n\t\tassertSafeModuleId: function (moduleId) {\n\t\t\tif (isAbsoluteUrl(moduleId)) {\n\t\t\t\tthrow new Error('Cross-origin loading of test modules is not allowed for security reasons');\n\t\t\t}\n\t\t},\n\n\t\tisGlobModuleId: isGlobModuleId,\n\n\t\t/**\n\t\t * Create a Deferred with some additional utility methods.\n\t\t */\n\t\tcreateDeferred: function () {\n\t\t\tvar dfd = new Promise.Deferred(function (reason) {\n\t\t\t\tthrow reason;\n\t\t\t});\n\n\t\t\t/**\n\t\t\t * Wraps any callback to resolve the deferred so long as the callback executes without throwing any Errors.\n\t\t\t */\n\t\t\tdfd.callback = function (callback) {\n\t\t\t\tvar self = this;\n\t\t\t\treturn self.rejectOnError(function () {\n\t\t\t\t\tvar returnValue = callback.apply(this, arguments);\n\t\t\t\t\tself.resolve();\n\t\t\t\t\treturn returnValue;\n\t\t\t\t});\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * Wraps a callback to reject the deferred if the callback throws an Error.\n\t\t\t */\n\t\t\tdfd.rejectOnError = function (callback) {\n\t\t\t\tvar self = this;\n\t\t\t\treturn function () {\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn callback.apply(this, arguments);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (error) {\n\t\t\t\t\t\tself.reject(error);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\n\t\t\treturn dfd;\n\t\t},\n\n\t\t/**\n\t\t * Creates a basic FIFO function queue to limit the number of currently executing asynchronous functions.\n\t\t *\n\t\t * @param maxConcurrency Number of functions to execute at once.\n\t\t * @returns {function(callee:Function)} A function that can be used to push new functions onto the queue.\n\t\t */\n\t\tcreateQueue: function (/**number*/ maxConcurrency) {\n\t\t\tvar numCalls = 0;\n\t\t\tvar queue = [];\n\n\t\t\tfunction shiftQueue() {\n\t\t\t\tif (queue.length) {\n\t\t\t\t\tvar callee = queue.shift();\n\t\t\t\t\tPromise.resolve(callee[0].apply(callee[1], callee[2])).finally(shiftQueue);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t--numCalls;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Returns a function to wrap callback function in this queue\n\t\t\tvar queuer = function (callee) {\n\t\t\t\t// Calling the wrapped function either executes immediately if possible,\n\t\t\t\t// or pushes onto the queue if not\n\t\t\t\treturn function () {\n\t\t\t\t\tif (numCalls < maxConcurrency) {\n\t\t\t\t\t\t++numCalls;\n\t\t\t\t\t\tPromise.resolve(callee.apply(this, arguments)).finally(shiftQueue);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tqueue.push([ callee, this, arguments ]);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\n\t\t\tqueuer.empty = function () {\n\t\t\t\tqueue = [];\n\t\t\t\tnumCalls = 0;\n\t\t\t};\n\n\t\t\treturn queuer;\n\t\t},\n\n\t\tescapeRegExp: function (string) {\n\t\t\treturn String(string).replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n\t\t},\n\n\t\t/**\n\t\t * Generates a full error message from a plain Error object, avoiding duplicate error messages that might be\n\t\t * caused by different opinions on what a stack trace should look like.\n\t\t *\n\t\t * @param {Error} error An object describing the error.\n\t\t * @returns {string} A string message describing the error.\n\t\t */\n\t\tgetErrorMessage: function (error) {\n\t\t\t/* jshint maxcomplexity:14 */\n\t\t\tif (error.message || error.stack) {\n\t\t\t\tvar message = (error.name || 'Error') + ': ' + (error.message || 'Unknown error');\n\t\t\t\tvar stack = error.stack;\n\n\t\t\t\tif (stack) {\n\t\t\t\t\t// V8 puts the original error at the top of the stack too; avoid redundant output that may\n\t\t\t\t\t// cause confusion about how many times an assertion was actually called\n\t\t\t\t\tif (stack.indexOf(message) === 0) {\n\t\t\t\t\t\tstack = stack.slice(message.length);\n\t\t\t\t\t}\n\t\t\t\t\telse if (stack.indexOf(error.message) === 0) {\n\t\t\t\t\t\tstack = stack.slice(String(error.message).length);\n\t\t\t\t\t}\n\n\t\t\t\t\tvar filterStack = intern && intern.config && intern.config.filterErrorStack;\n\t\t\t\t\tstack = normalizeStackTrace(stack, filterStack);\n\t\t\t\t}\n\n\t\t\t\tif (error.showDiff && typeof error.actual === 'object' && typeof error.expected === 'object') {\n\t\t\t\t\tvar diff = createDiff(error.actual, error.expected);\n\t\t\t\t\tif (diff) {\n\t\t\t\t\t\tmessage += '\\n\\n' + diff + '\\n';\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (stack && /\\S/.test(stack)) {\n\t\t\t\t\tmessage += stack;\n\t\t\t\t}\n\t\t\t\telse if (error.fileName) {\n\t\t\t\t\tmessage += '\\n  at ' + error.fileName;\n\t\t\t\t\tif (error.lineNumber != null) {\n\t\t\t\t\t\tmessage += ':' + error.lineNumber;\n\n\t\t\t\t\t\tif (error.columnNumber != null) {\n\t\t\t\t\t\t\tmessage += ':' + error.columnNumber;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tmessage += '\\nNo stack';\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmessage += '\\nNo stack or location';\n\t\t\t\t}\n\n\t\t\t\treturn message;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn String(error);\n\t\t\t}\n\t\t},\n\n\t\tgetModule: function (moduleId, loader) {\n\t\t\treturn this.getModules([ moduleId ], loader).then(function (modules) {\n\t\t\t\treturn modules[0];\n\t\t\t});\n\t\t},\n\n\t\tgetModules: function (moduleIds, loader) {\n\t\t\t/* global require:false */\n\t\t\tif (!loader) {\n\t\t\t\tloader = require;\n\t\t\t}\n\n\t\t\treturn new Promise(function (resolve, reject) {\n\t\t\t\tloader(moduleIds, function () {\n\t\t\t\t\tresolve(Array.prototype.slice.call(arguments, 0));\n\t\t\t\t}, reject);\n\t\t\t});\n\t\t},\n\n\t\tgetShouldWait: function (waitMode, message) {\n\t\t\tvar shouldWait = false;\n\t\t\tvar eventName = message[0];\n\n\t\t\tif (waitMode === 'fail') {\n\t\t\t\tif (\n\t\t\t\t\teventName === 'testFail' ||\n\t\t\t\t\teventName === 'suiteError' ||\n\t\t\t\t\teventName === 'fatalError'\n\t\t\t\t) {\n\t\t\t\t\tshouldWait = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (waitMode === true) {\n\t\t\t\tshouldWait = true;\n\t\t\t}\n\t\t\telse if (Array.isArray(waitMode) && waitMode.indexOf(eventName) !== -1) {\n\t\t\t\tshouldWait = true;\n\t\t\t}\n\n\t\t\treturn shouldWait;\n\t\t},\n\n\t\tnormalizePath: function (path) {\n\t\t\tif (pathUtil) {\n\t\t\t\treturn pathUtil.normalize(path).replace(/\\\\/g, '/');\n\t\t\t}\n\n\t\t\tvar parts = path.replace(/\\\\/g, '/').split('/');\n\t\t\tvar result = [];\n\t\t\tfor (var i = 0; i < parts.length; ++i) {\n\t\t\t\tvar part = parts[i];\n\n\t\t\t\tif (!part || part === '.') {\n\t\t\t\t\tif (i === 0 || i === parts.length - 1) {\n\t\t\t\t\t\tresult.push('');\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (part === '..') {\n\t\t\t\t\tif (result.length && result[result.length - 1] !== '..') {\n\t\t\t\t\t\tresult.pop();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tresult.push(part);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tresult.push(part);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn result.join('/');\n\t\t},\n\n\t\tnormalizePathForInstrumentation: function (filename) {\n\t\t\tfilename = pathUtil.normalize(filename);\n\t\t\tif (pathUtil.sep === '\\\\') {\n\t\t\t\tfilename = filename.replace(/\\\\/g, '/');\n\t\t\t}\n\t\t\treturn filename;\n\t\t},\n\n\t\t/**\n\t\t * Resolve a module ID that contains a glob expression.\n\t\t *\n\t\t * @param {string[]} moduleIds\n\t\t * @returns {string[]} a list of resolved module IDs\n\t\t */\n\t\tresolveModuleIds: function (moduleIds) {\n\t\t\tfunction moduleIdToPath(moduleId, package, packageLocation) {\n\t\t\t\treturn packageLocation + moduleId.slice(package.length);\n\t\t\t}\n\n\t\t\tfunction pathToModuleId(path, package, packageLocation) {\n\t\t\t\treturn package + path.slice(packageLocation.length, path.length - 3);\n\t\t\t}\n\n\t\t\tif (!moduleIds) {\n\t\t\t\treturn moduleIds;\n\t\t\t}\n\n\t\t\t// The module ID has a glob character\n\t\t\treturn moduleIds.reduce(function (resolved, moduleId) {\n\t\t\t\tif (isGlobModuleId(moduleId)) {\n\t\t\t\t\tvar package = moduleId.slice(0, moduleId.indexOf('/'));\n\t\t\t\t\tvar packageLocation = require.toUrl(package);\n\t\t\t\t\tvar modulePath = moduleIdToPath(moduleId, package, packageLocation);\n\n\t\t\t\t\t// Ensure only JS files are considered\n\t\t\t\t\tif (!/\\.js$/.test(modulePath)) {\n\t\t\t\t\t\tmodulePath += '.js';\n\t\t\t\t\t}\n\n\t\t\t\t\tglob.sync(modulePath).forEach(function (file) {\n\t\t\t\t\t\tresolved.push(pathToModuleId(file, package, packageLocation));\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t// The module ID is an actual ID\n\t\t\t\telse {\n\t\t\t\t\tresolved.push(moduleId);\n\t\t\t\t}\n\n\t\t\t\treturn resolved;\n\t\t\t}, []);\n\t\t},\n\n\t\tretry: function (callback, numRetries) {\n\t\t\tvar numAttempts = 0;\n\t\t\treturn callback().catch(function retry(error) {\n\t\t\t\tif (error.name !== 'CancelError' && ++numAttempts <= numRetries) {\n\t\t\t\t\treturn callback().catch(retry);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Adds hooks for code coverage instrumentation in the Node.js loader.\n\t\t *\n\t\t * @param {RegExp|boolean} excludeInstrumentation A RegExp or boolean used to decide whether to apply\n\t\t * instrumentation\n\t\t * @param {string} basePath The base path for all code\n\t\t * @param {Object} instrumenterOptions Extra options for the instrumenter\n\t\t */\n\t\tsetInstrumentationHooks: function (excludeInstrumentation, basePath, instrumenterOptions) {\n\t\t\tvar self = this;\n\n\t\t\tbasePath = self.normalizePath(pathUtil.resolve(basePath || '') + pathUtil.sep);\n\n\t\t\tfunction hookMatcher(filename) {\n\t\t\t\tfilename = self.normalizePath(filename);\n\n\t\t\t\treturn !excludeInstrumentation || (\n\t\t\t\t\tfilename.indexOf(basePath) === 0 &&\n\t\t\t\t\t// if the string passed to `excludeInstrumentation` changes here, it must also change in\n\t\t\t\t\t// `lib/Proxy.js`\n\t\t\t\t\t!excludeInstrumentation.test(filename.slice(basePath.length))\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tfunction hookTransformer(code, filename) {\n\t\t\t\treturn self.instrument(code, pathUtil.resolve(filename), instrumenterOptions);\n\t\t\t}\n\n\t\t\thook.hookRunInThisContext(hookMatcher, hookTransformer);\n\t\t\thook.hookRequire(hookMatcher, hookTransformer);\n\n\t\t\treturn {\n\t\t\t\tremove: function () {\n\t\t\t\t\tthis.remove = function () {};\n\t\t\t\t\thook.unhookRunInThisContext();\n\t\t\t\t\thook.unhookRequire();\n\t\t\t\t}\n\t\t\t};\n\t\t},\n\n\t\t/**\n\t\t * Instrument a given file, saving its coverage source map.\n\t\t *\n\t\t * @param {string} filedata Text of file being instrumented\n\t\t * @param {string} filepath Full path of file being instrumented\n\t\t * @param {Object} instrumenterOptions Extra options for the instrumenter\n\t\t *\n\t\t * @returns {string} A string of instrumented code\n\t\t */\n\t\tinstrument: function (filedata, filepath, instrumenterOptions) {\n\t\t\tvar instrumenter = getInstrumenter(instrumenterOptions);\n\t\t\tvar options = instrumenter.opts;\n\n\t\t\t// Assign to options.codeGenerationOptions to handle the case where codeGenerationOptions is null\n\t\t\toptions.codeGenerationOptions = lang.mixin(options.codeGenerationOptions, {\n\t\t\t\tsourceMap: pathUtil.normalize(filepath),\n\t\t\t\tsourceMapWithCode: true\n\t\t\t});\n\n\t\t\tvar code = instrumenter.instrumentSync(filedata, pathUtil.normalize(filepath));\n\t\t\tvar map = instrumenter.lastSourceMap();\n\n\t\t\tif (map) {\n\t\t\t\tinstrumentationSourceMap[filepath] = loadSourceMap(map.toString());\n\t\t\t\tfileSources[filepath] = filedata;\n\t\t\t}\n\n\t\t\treturn code;\n\t\t}\n\t};\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/support/fixdeps.js":"/*jshint node:true */\nvar fs = require('fs');\nvar path = require('path');\nvar browserModules = path.join(__dirname, '..', 'browser_modules');\n\nfunction getPackageVersion(packageJsonPath) {\n\tvar packageJson = fs.readFileSync(packageJsonPath, { encoding: 'utf8' });\n\treturn JSON.parse(packageJson).version;\n}\n\nif (!fs.existsSync(browserModules)) {\n\tfs.mkdirSync(browserModules);\n}\n\n// AMD-loaded dependencies need to exist in a known location, but npm's deduplication process can make final package\n// locations unpredictable, so copy the currently installed versions of required packages into browser_modules.\n[ 'dojo', 'chai', 'diff', 'benchmark', 'lodash-amd', 'platform' ].forEach(function (dependency) {\n\tvar packageJson = require.resolve(path.join(dependency, 'package.json'));\n\tvar installedPath = path.dirname(packageJson);\n\tvar expectedPath = path.join(browserModules, dependency);\n\tvar installedVersion = getPackageVersion(packageJson);\n\tvar existingVersion;\n\n\ttry {\n\t\texistingVersion = getPackageVersion(path.join(expectedPath, 'package.json'));\n\t}\n\tcatch (error) {\n\t\tif (error.code !== 'ENOENT') {\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t// The package in browser_modules is older than the installed version; delete it\n\tif (existingVersion && existingVersion !== installedVersion) {\n\t\tunlink(expectedPath);\n\t\texistingVersion = null;\n\t}\n\n\t// The package isn't in browser_modules, so copy the installed one\n\tif (!existingVersion) {\n\t\tcopy(installedPath, expectedPath);\n\t}\n});\n\nfunction copy(source, target) {\n\ttry {\n\t\tvar stats = fs.statSync(source);\n\t}\n\tcatch (error) {\n\t\tif (error.code !== 'ENOENT') {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn;\n\t}\n\n\tif (stats.isDirectory()) {\n\t\ttry {\n\t\t\tfs.mkdirSync(target);\n\t\t}\n\t\tcatch (error) {\n\t\t\tif (error.code !== 'EEXIST') {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\n\t\tfs.readdirSync(source).forEach(function (filename) {\n\t\t\tcopy(path.join(source, filename), path.join(target, filename));\n\t\t});\n\t}\n\telse if (stats.isFile()) {\n\t\tfs.writeFileSync(target, fs.readFileSync(source), { mode: stats.mode });\n\t}\n}\n\nfunction unlink(target) {\n\ttry {\n\t\tvar stats = fs.statSync(target);\n\t}\n\tcatch (error) {\n\t\tif (error.code !== 'ENOENT') {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn;\n\t}\n\n\tif (stats.isDirectory()) {\n\t\tfs.readdirSync(target).forEach(function (filename) {\n\t\t\tunlink(path.join(target, filename));\n\t\t});\n\t\tfs.rmdirSync(target);\n\t}\n\telse if (stats.isFile()) {\n\t\tfs.unlinkSync(target);\n\t}\n}\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/tasks/intern.js":"/*jshint node:true */\n\nmodule.exports = function (grunt) {\n\tfunction logOutput(line) {\n\t\tvar state = 'write';\n\n\t\tif (/(\\d+)\\/(\\d+) tests (pass|fail)/.test(line)) {\n\t\t\tvar match = /(\\d+)\\/(\\d+) tests (pass|fail)/.exec(line),\n\t\t\t\tcount = Number(match[1]),\n\t\t\t\ttotal = Number(match[2]);\n\t\t\tif (match[3] === 'pass') {\n\t\t\t\tstate = (count === total) ? 'ok' : 'error';\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstate = count ? 'error' : 'ok';\n\t\t\t}\n\t\t}\n\t\telse if (/\\bPASS/.test(line)) {\n\t\t\tstate = 'ok';\n\t\t}\n\t\telse if (/\\bFAIL/.test(line)) {\n\t\t\tstate = 'error';\n\t\t}\n\n\t\tstate === 'error' && grunt.event.emit('intern.fail', line);\n\t\tstate === 'ok' && grunt.event.emit('intern.pass', line);\n\t\tgrunt.log[state](line);\n\t}\n\n\tfunction readOutput(data) {\n\t\tvar start = 0,\n\t\t\tnext;\n\n\t\tdata = String(data);\n\t\tnext = data.indexOf('\\n', start);\n\n\t\twhile (next !== -1) {\n\t\t\tlogOutput(data.substring(start, next) + '\\n');\n\t\t\tstart = next + 1;\n\t\t\tnext = data.indexOf('\\n', start);\n\t\t}\n\n\t\tlogOutput(data.slice(start));\n\t}\n\n\tfunction serialize(data) {\n\t\tif (typeof data === 'object') {\n\t\t\treturn JSON.stringify(data);\n\t\t}\n\n\t\treturn data;\n\t}\n\n\tgrunt.registerMultiTask('intern', function () {\n\t\tvar done = this.async(),\n\t\t\topts = this.options({ runType: 'client' }),\n\t\t\targs = [ require('path').join(__dirname, '..') + '/' + opts.runType + '.js' ],\n\t\t\tenv = Object.create(process.env),\n\t\t\tskipOptions = {\n\t\t\t\tbrowserstackAccessKey: true,\n\t\t\t\tbrowserstackUsername: true,\n\t\t\t\tcbtApikey: true,\n\t\t\t\tcbtUsername: true,\n\t\t\t\trunType: true,\n\t\t\t\tsauceAccessKey: true,\n\t\t\t\tsauceUsername: true,\n\t\t\t\ttestingbotKey: true,\n\t\t\t\ttestingbotSecret: true,\n\t\t\t\tnodeEnv: true,\n\t\t\t\tcwd: true,\n\t\t\t\t// --harmony, etc.\n\t\t\t\tnodeOptions: true\n\t\t\t};\n\n\t\tif (opts.nodeOptions) {\n\t\t\t// Node Options need to go at the beginning\n\t\t\tif (Array.isArray(opts.nodeOptions)) {\n\t\t\t\tArray.prototype.unshift.apply(args, opts.nodeOptions);\n\t\t\t}\n\t\t\telse {\n\t\t\t\targs.unshift(opts.nodeOptions);\n\t\t\t}\n\t\t}\n\n\t\tObject.keys(opts).forEach(function (option) {\n\t\t\tif (skipOptions[option]) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar value = opts[option];\n\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\tgrunt.util._.flatten(value).forEach(function (value) {\n\t\t\t\t\targs.push(option + '=' + serialize(value));\n\t\t\t\t});\n\t\t\t}\n\t\t\telse if (typeof value === 'boolean') {\n\t\t\t\tif (value) {\n\t\t\t\t\targs.push(option);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\targs.push(option + '=' + serialize(value));\n\t\t\t}\n\t\t});\n\n\t\t[\n\t\t\t'browserstackAccessKey',\n\t\t\t'browserstackUsername',\n\t\t\t'cbtApikey',\n\t\t\t'cbtUsername',\n\t\t\t'sauceAccessKey',\n\t\t\t'sauceUsername',\n\t\t\t'testingbotKey',\n\t\t\t'testingbotSecret',\n\t\t\t'nodeEnv'\n\t\t].forEach(function (option) {\n\t\t\tvar value = opts[option];\n\t\t\tif (value) {\n\t\t\t\tenv[option.replace(/[A-Z]/g, '_$&').toUpperCase()] = value;\n\t\t\t}\n\t\t});\n\n\t\t// force colored output for istanbul report\n\t\tenv.FORCE_COLOR = true;\n\n\t\tvar child = grunt.util.spawn({\n\t\t\tcmd: process.argv[0],\n\t\t\targs: args,\n\t\t\topts: {\n\t\t\t\tcwd: opts.cwd || process.cwd(),\n\t\t\t\tenv: env\n\t\t\t}\n\t\t}, function (error) {\n\t\t\t// The error object from grunt.util.spawn contains information\n\t\t\t// that we already logged, so hide it from the user\n\t\t\tdone(error ? new Error('Test failure; check output above for details.') : null);\n\t\t});\n\n\t\tchild.stdout.on('data', readOutput);\n\t\tchild.stderr.on('data', readOutput);\n\t});\n};\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/benchmark/benchmark.js":"/*!\n * Benchmark.js <https://benchmarkjs.com/>\n * Copyright 2010-2016 Mathias Bynens <https://mths.be/>\n * Based on JSLitmus.js, copyright Robert Kieffer <http://broofa.com/>\n * Modified by John-David Dalton <http://allyoucanleet.com/>\n * Available under MIT license <https://mths.be/mit>\n */\n;(function() {\n  'use strict';\n\n  /** Used as a safe reference for `undefined` in pre ES5 environments. */\n  var undefined;\n\n  /** Used to determine if values are of the language type Object. */\n  var objectTypes = {\n    'function': true,\n    'object': true\n  };\n\n  /** Used as a reference to the global object. */\n  var root = (objectTypes[typeof window] && window) || this;\n\n  /** Detect free variable `define`. */\n  var freeDefine = typeof define == 'function' && typeof define.amd == 'object' && define.amd && define;\n\n  /** Detect free variable `exports`. */\n  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;\n\n  /** Detect free variable `module`. */\n  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;\n\n  /** Detect free variable `global` from Node.js or Browserified code and use it as `root`. */\n  var freeGlobal = freeExports && freeModule && typeof global == 'object' && global;\n  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {\n    root = freeGlobal;\n  }\n\n  /** Detect free variable `require`. */\n  var freeRequire = typeof require == 'function' && require;\n\n  /** Used to assign each benchmark an incremented id. */\n  var counter = 0;\n\n  /** Detect the popular CommonJS extension `module.exports`. */\n  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;\n\n  /** Used to detect primitive types. */\n  var rePrimitive = /^(?:boolean|number|string|undefined)$/;\n\n  /** Used to make every compiled test unique. */\n  var uidCounter = 0;\n\n  /** Used to assign default `context` object properties. */\n  var contextProps = [\n    'Array', 'Date', 'Function', 'Math', 'Object', 'RegExp', 'String', '_',\n    'clearTimeout', 'chrome', 'chromium', 'document', 'navigator', 'phantom',\n    'platform', 'process', 'runtime', 'setTimeout'\n  ];\n\n  /** Used to avoid hz of Infinity. */\n  var divisors = {\n    '1': 4096,\n    '2': 512,\n    '3': 64,\n    '4': 8,\n    '5': 0\n  };\n\n  /**\n   * T-Distribution two-tailed critical values for 95% confidence.\n   * For more info see http://www.itl.nist.gov/div898/handbook/eda/section3/eda3672.htm.\n   */\n  var tTable = {\n    '1':  12.706, '2':  4.303, '3':  3.182, '4':  2.776, '5':  2.571, '6':  2.447,\n    '7':  2.365,  '8':  2.306, '9':  2.262, '10': 2.228, '11': 2.201, '12': 2.179,\n    '13': 2.16,   '14': 2.145, '15': 2.131, '16': 2.12,  '17': 2.11,  '18': 2.101,\n    '19': 2.093,  '20': 2.086, '21': 2.08,  '22': 2.074, '23': 2.069, '24': 2.064,\n    '25': 2.06,   '26': 2.056, '27': 2.052, '28': 2.048, '29': 2.045, '30': 2.042,\n    'infinity': 1.96\n  };\n\n  /**\n   * Critical Mann-Whitney U-values for 95% confidence.\n   * For more info see http://www.saburchill.com/IBbiology/stats/003.html.\n   */\n  var uTable = {\n    '5':  [0, 1, 2],\n    '6':  [1, 2, 3, 5],\n    '7':  [1, 3, 5, 6, 8],\n    '8':  [2, 4, 6, 8, 10, 13],\n    '9':  [2, 4, 7, 10, 12, 15, 17],\n    '10': [3, 5, 8, 11, 14, 17, 20, 23],\n    '11': [3, 6, 9, 13, 16, 19, 23, 26, 30],\n    '12': [4, 7, 11, 14, 18, 22, 26, 29, 33, 37],\n    '13': [4, 8, 12, 16, 20, 24, 28, 33, 37, 41, 45],\n    '14': [5, 9, 13, 17, 22, 26, 31, 36, 40, 45, 50, 55],\n    '15': [5, 10, 14, 19, 24, 29, 34, 39, 44, 49, 54, 59, 64],\n    '16': [6, 11, 15, 21, 26, 31, 37, 42, 47, 53, 59, 64, 70, 75],\n    '17': [6, 11, 17, 22, 28, 34, 39, 45, 51, 57, 63, 67, 75, 81, 87],\n    '18': [7, 12, 18, 24, 30, 36, 42, 48, 55, 61, 67, 74, 80, 86, 93, 99],\n    '19': [7, 13, 19, 25, 32, 38, 45, 52, 58, 65, 72, 78, 85, 92, 99, 106, 113],\n    '20': [8, 14, 20, 27, 34, 41, 48, 55, 62, 69, 76, 83, 90, 98, 105, 112, 119, 127],\n    '21': [8, 15, 22, 29, 36, 43, 50, 58, 65, 73, 80, 88, 96, 103, 111, 119, 126, 134, 142],\n    '22': [9, 16, 23, 30, 38, 45, 53, 61, 69, 77, 85, 93, 101, 109, 117, 125, 133, 141, 150, 158],\n    '23': [9, 17, 24, 32, 40, 48, 56, 64, 73, 81, 89, 98, 106, 115, 123, 132, 140, 149, 157, 166, 175],\n    '24': [10, 17, 25, 33, 42, 50, 59, 67, 76, 85, 94, 102, 111, 120, 129, 138, 147, 156, 165, 174, 183, 192],\n    '25': [10, 18, 27, 35, 44, 53, 62, 71, 80, 89, 98, 107, 117, 126, 135, 145, 154, 163, 173, 182, 192, 201, 211],\n    '26': [11, 19, 28, 37, 46, 55, 64, 74, 83, 93, 102, 112, 122, 132, 141, 151, 161, 171, 181, 191, 200, 210, 220, 230],\n    '27': [11, 20, 29, 38, 48, 57, 67, 77, 87, 97, 107, 118, 125, 138, 147, 158, 168, 178, 188, 199, 209, 219, 230, 240, 250],\n    '28': [12, 21, 30, 40, 50, 60, 70, 80, 90, 101, 111, 122, 132, 143, 154, 164, 175, 186, 196, 207, 218, 228, 239, 250, 261, 272],\n    '29': [13, 22, 32, 42, 52, 62, 73, 83, 94, 105, 116, 127, 138, 149, 160, 171, 182, 193, 204, 215, 226, 238, 249, 260, 271, 282, 294],\n    '30': [13, 23, 33, 43, 54, 65, 76, 87, 98, 109, 120, 131, 143, 154, 166, 177, 189, 200, 212, 223, 235, 247, 258, 270, 282, 293, 305, 317]\n  };\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Create a new `Benchmark` function using the given `context` object.\n   *\n   * @static\n   * @memberOf Benchmark\n   * @param {Object} [context=root] The context object.\n   * @returns {Function} Returns a new `Benchmark` function.\n   */\n  function runInContext(context) {\n    // Exit early if unable to acquire lodash.\n    var _ = context && context._ || require('lodash') || root._;\n    if (!_) {\n      Benchmark.runInContext = runInContext;\n      return Benchmark;\n    }\n    // Avoid issues with some ES3 environments that attempt to use values, named\n    // after built-in constructors like `Object`, for the creation of literals.\n    // ES5 clears this up by stating that literals must use built-in constructors.\n    // See http://es5.github.io/#x11.1.5.\n    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;\n\n    /** Native constructor references. */\n    var Array = context.Array,\n        Date = context.Date,\n        Function = context.Function,\n        Math = context.Math,\n        Object = context.Object,\n        RegExp = context.RegExp,\n        String = context.String;\n\n    /** Used for `Array` and `Object` method references. */\n    var arrayRef = [],\n        objectProto = Object.prototype;\n\n    /** Native method shortcuts. */\n    var abs = Math.abs,\n        clearTimeout = context.clearTimeout,\n        floor = Math.floor,\n        log = Math.log,\n        max = Math.max,\n        min = Math.min,\n        pow = Math.pow,\n        push = arrayRef.push,\n        setTimeout = context.setTimeout,\n        shift = arrayRef.shift,\n        slice = arrayRef.slice,\n        sqrt = Math.sqrt,\n        toString = objectProto.toString,\n        unshift = arrayRef.unshift;\n\n    /** Used to avoid inclusion in Browserified bundles. */\n    var req = require;\n\n    /** Detect DOM document object. */\n    var doc = isHostType(context, 'document') && context.document;\n\n    /** Used to access Wade Simmons' Node.js `microtime` module. */\n    var microtimeObject = req('microtime');\n\n    /** Used to access Node.js's high resolution timer. */\n    var processObject = isHostType(context, 'process') && context.process;\n\n    /** Used to prevent a `removeChild` memory leak in IE < 9. */\n    var trash = doc && doc.createElement('div');\n\n    /** Used to integrity check compiled tests. */\n    var uid = 'uid' + _.now();\n\n    /** Used to avoid infinite recursion when methods call each other. */\n    var calledBy = {};\n\n    /**\n     * An object used to flag environments/features.\n     *\n     * @static\n     * @memberOf Benchmark\n     * @type Object\n     */\n    var support = {};\n\n    (function() {\n\n      /**\n       * Detect if running in a browser environment.\n       *\n       * @memberOf Benchmark.support\n       * @type boolean\n       */\n      support.browser = doc && isHostType(context, 'navigator') && !isHostType(context, 'phantom');\n\n      /**\n       * Detect if the Timers API exists.\n       *\n       * @memberOf Benchmark.support\n       * @type boolean\n       */\n      support.timeout = isHostType(context, 'setTimeout') && isHostType(context, 'clearTimeout');\n\n      /**\n       * Detect if function decompilation is support.\n       *\n       * @name decompilation\n       * @memberOf Benchmark.support\n       * @type boolean\n       */\n      try {\n        // Safari 2.x removes commas in object literals from `Function#toString` results.\n        // See http://webk.it/11609 for more details.\n        // Firefox 3.6 and Opera 9.25 strip grouping parentheses from `Function#toString` results.\n        // See http://bugzil.la/559438 for more details.\n        support.decompilation = Function(\n          ('return (' + (function(x) { return { 'x': '' + (1 + x) + '', 'y': 0 }; }) + ')')\n          // Avoid issues with code added by Istanbul.\n          .replace(/__cov__[^;]+;/g, '')\n        )()(0).x === '1';\n      } catch(e) {\n        support.decompilation = false;\n      }\n    }());\n\n    /**\n     * Timer object used by `clock()` and `Deferred#resolve`.\n     *\n     * @private\n     * @type Object\n     */\n    var timer = {\n\n      /**\n       * The timer namespace object or constructor.\n       *\n       * @private\n       * @memberOf timer\n       * @type {Function|Object}\n       */\n      'ns': Date,\n\n      /**\n       * Starts the deferred timer.\n       *\n       * @private\n       * @memberOf timer\n       * @param {Object} deferred The deferred instance.\n       */\n      'start': null, // Lazy defined in `clock()`.\n\n      /**\n       * Stops the deferred timer.\n       *\n       * @private\n       * @memberOf timer\n       * @param {Object} deferred The deferred instance.\n       */\n      'stop': null // Lazy defined in `clock()`.\n    };\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * The Benchmark constructor.\n     *\n     * Note: The Benchmark constructor exposes a handful of lodash methods to\n     * make working with arrays, collections, and objects easier. The lodash\n     * methods are:\n     * [`each/forEach`](https://lodash.com/docs#forEach), [`forOwn`](https://lodash.com/docs#forOwn),\n     * [`has`](https://lodash.com/docs#has), [`indexOf`](https://lodash.com/docs#indexOf),\n     * [`map`](https://lodash.com/docs#map), and [`reduce`](https://lodash.com/docs#reduce)\n     *\n     * @constructor\n     * @param {string} name A name to identify the benchmark.\n     * @param {Function|string} fn The test to benchmark.\n     * @param {Object} [options={}] Options object.\n     * @example\n     *\n     * // basic usage (the `new` operator is optional)\n     * var bench = new Benchmark(fn);\n     *\n     * // or using a name first\n     * var bench = new Benchmark('foo', fn);\n     *\n     * // or with options\n     * var bench = new Benchmark('foo', fn, {\n     *\n     *   // displayed by `Benchmark#toString` if `name` is not available\n     *   'id': 'xyz',\n     *\n     *   // called when the benchmark starts running\n     *   'onStart': onStart,\n     *\n     *   // called after each run cycle\n     *   'onCycle': onCycle,\n     *\n     *   // called when aborted\n     *   'onAbort': onAbort,\n     *\n     *   // called when a test errors\n     *   'onError': onError,\n     *\n     *   // called when reset\n     *   'onReset': onReset,\n     *\n     *   // called when the benchmark completes running\n     *   'onComplete': onComplete,\n     *\n     *   // compiled/called before the test loop\n     *   'setup': setup,\n     *\n     *   // compiled/called after the test loop\n     *   'teardown': teardown\n     * });\n     *\n     * // or name and options\n     * var bench = new Benchmark('foo', {\n     *\n     *   // a flag to indicate the benchmark is deferred\n     *   'defer': true,\n     *\n     *   // benchmark test function\n     *   'fn': function(deferred) {\n     *     // call `Deferred#resolve` when the deferred test is finished\n     *     deferred.resolve();\n     *   }\n     * });\n     *\n     * // or options only\n     * var bench = new Benchmark({\n     *\n     *   // benchmark name\n     *   'name': 'foo',\n     *\n     *   // benchmark test as a string\n     *   'fn': '[1,2,3,4].sort()'\n     * });\n     *\n     * // a test's `this` binding is set to the benchmark instance\n     * var bench = new Benchmark('foo', function() {\n     *   'My name is '.concat(this.name); // \"My name is foo\"\n     * });\n     */\n    function Benchmark(name, fn, options) {\n      var bench = this;\n\n      // Allow instance creation without the `new` operator.\n      if (!(bench instanceof Benchmark)) {\n        return new Benchmark(name, fn, options);\n      }\n      // Juggle arguments.\n      if (_.isPlainObject(name)) {\n        // 1 argument (options).\n        options = name;\n      }\n      else if (_.isFunction(name)) {\n        // 2 arguments (fn, options).\n        options = fn;\n        fn = name;\n      }\n      else if (_.isPlainObject(fn)) {\n        // 2 arguments (name, options).\n        options = fn;\n        fn = null;\n        bench.name = name;\n      }\n      else {\n        // 3 arguments (name, fn [, options]).\n        bench.name = name;\n      }\n      setOptions(bench, options);\n\n      bench.id || (bench.id = ++counter);\n      bench.fn == null && (bench.fn = fn);\n\n      bench.stats = cloneDeep(bench.stats);\n      bench.times = cloneDeep(bench.times);\n    }\n\n    /**\n     * The Deferred constructor.\n     *\n     * @constructor\n     * @memberOf Benchmark\n     * @param {Object} clone The cloned benchmark instance.\n     */\n    function Deferred(clone) {\n      var deferred = this;\n      if (!(deferred instanceof Deferred)) {\n        return new Deferred(clone);\n      }\n      deferred.benchmark = clone;\n      clock(deferred);\n    }\n\n    /**\n     * The Event constructor.\n     *\n     * @constructor\n     * @memberOf Benchmark\n     * @param {Object|string} type The event type.\n     */\n    function Event(type) {\n      var event = this;\n      if (type instanceof Event) {\n        return type;\n      }\n      return (event instanceof Event)\n        ? _.assign(event, { 'timeStamp': _.now() }, typeof type == 'string' ? { 'type': type } : type)\n        : new Event(type);\n    }\n\n    /**\n     * The Suite constructor.\n     *\n     * Note: Each Suite instance has a handful of wrapped lodash methods to\n     * make working with Suites easier. The wrapped lodash methods are:\n     * [`each/forEach`](https://lodash.com/docs#forEach), [`indexOf`](https://lodash.com/docs#indexOf),\n     * [`map`](https://lodash.com/docs#map), and [`reduce`](https://lodash.com/docs#reduce)\n     *\n     * @constructor\n     * @memberOf Benchmark\n     * @param {string} name A name to identify the suite.\n     * @param {Object} [options={}] Options object.\n     * @example\n     *\n     * // basic usage (the `new` operator is optional)\n     * var suite = new Benchmark.Suite;\n     *\n     * // or using a name first\n     * var suite = new Benchmark.Suite('foo');\n     *\n     * // or with options\n     * var suite = new Benchmark.Suite('foo', {\n     *\n     *   // called when the suite starts running\n     *   'onStart': onStart,\n     *\n     *   // called between running benchmarks\n     *   'onCycle': onCycle,\n     *\n     *   // called when aborted\n     *   'onAbort': onAbort,\n     *\n     *   // called when a test errors\n     *   'onError': onError,\n     *\n     *   // called when reset\n     *   'onReset': onReset,\n     *\n     *   // called when the suite completes running\n     *   'onComplete': onComplete\n     * });\n     */\n    function Suite(name, options) {\n      var suite = this;\n\n      // Allow instance creation without the `new` operator.\n      if (!(suite instanceof Suite)) {\n        return new Suite(name, options);\n      }\n      // Juggle arguments.\n      if (_.isPlainObject(name)) {\n        // 1 argument (options).\n        options = name;\n      } else {\n        // 2 arguments (name [, options]).\n        suite.name = name;\n      }\n      setOptions(suite, options);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * A specialized version of `_.cloneDeep` which only clones arrays and plain\n     * objects assigning all other values by reference.\n     *\n     * @private\n     * @param {*} value The value to clone.\n     * @returns {*} The cloned value.\n     */\n    var cloneDeep = _.partial(_.cloneDeepWith, _, function(value) {\n      // Only clone primitives, arrays, and plain objects.\n      return (_.isObject(value) && !_.isArray(value) && !_.isPlainObject(value))\n        ? value\n        : undefined;\n    });\n\n    /**\n     * Creates a function from the given arguments string and body.\n     *\n     * @private\n     * @param {string} args The comma separated function arguments.\n     * @param {string} body The function body.\n     * @returns {Function} The new function.\n     */\n    function createFunction() {\n      // Lazy define.\n      createFunction = function(args, body) {\n        var result,\n            anchor = freeDefine ? freeDefine.amd : Benchmark,\n            prop = uid + 'createFunction';\n\n        runScript((freeDefine ? 'define.amd.' : 'Benchmark.') + prop + '=function(' + args + '){' + body + '}');\n        result = anchor[prop];\n        delete anchor[prop];\n        return result;\n      };\n      // Fix JaegerMonkey bug.\n      // For more information see http://bugzil.la/639720.\n      createFunction = support.browser && (createFunction('', 'return\"' + uid + '\"') || _.noop)() == uid ? createFunction : Function;\n      return createFunction.apply(null, arguments);\n    }\n\n    /**\n     * Delay the execution of a function based on the benchmark's `delay` property.\n     *\n     * @private\n     * @param {Object} bench The benchmark instance.\n     * @param {Object} fn The function to execute.\n     */\n    function delay(bench, fn) {\n      bench._timerId = _.delay(fn, bench.delay * 1e3);\n    }\n\n    /**\n     * Destroys the given element.\n     *\n     * @private\n     * @param {Element} element The element to destroy.\n     */\n    function destroyElement(element) {\n      trash.appendChild(element);\n      trash.innerHTML = '';\n    }\n\n    /**\n     * Gets the name of the first argument from a function's source.\n     *\n     * @private\n     * @param {Function} fn The function.\n     * @returns {string} The argument name.\n     */\n    function getFirstArgument(fn) {\n      return (!_.has(fn, 'toString') &&\n        (/^[\\s(]*function[^(]*\\(([^\\s,)]+)/.exec(fn) || 0)[1]) || '';\n    }\n\n    /**\n     * Computes the arithmetic mean of a sample.\n     *\n     * @private\n     * @param {Array} sample The sample.\n     * @returns {number} The mean.\n     */\n    function getMean(sample) {\n      return (_.reduce(sample, function(sum, x) {\n        return sum + x;\n      }) / sample.length) || 0;\n    }\n\n    /**\n     * Gets the source code of a function.\n     *\n     * @private\n     * @param {Function} fn The function.\n     * @returns {string} The function's source code.\n     */\n    function getSource(fn) {\n      var result = '';\n      if (isStringable(fn)) {\n        result = String(fn);\n      } else if (support.decompilation) {\n        // Escape the `{` for Firefox 1.\n        result = _.result(/^[^{]+\\{([\\s\\S]*)\\}\\s*$/.exec(fn), 1);\n      }\n      // Trim string.\n      result = (result || '').replace(/^\\s+|\\s+$/g, '');\n\n      // Detect strings containing only the \"use strict\" directive.\n      return /^(?:\\/\\*+[\\w\\W]*?\\*\\/|\\/\\/.*?[\\n\\r\\u2028\\u2029]|\\s)*([\"'])use strict\\1;?$/.test(result)\n        ? ''\n        : result;\n    }\n\n    /**\n     * Checks if an object is of the specified class.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @param {string} name The name of the class.\n     * @returns {boolean} Returns `true` if the value is of the specified class, else `false`.\n     */\n    function isClassOf(value, name) {\n      return value != null && toString.call(value) == '[object ' + name + ']';\n    }\n\n    /**\n     * Host objects can return type values that are different from their actual\n     * data type. The objects we are concerned with usually return non-primitive\n     * types of \"object\", \"function\", or \"unknown\".\n     *\n     * @private\n     * @param {*} object The owner of the property.\n     * @param {string} property The property to check.\n     * @returns {boolean} Returns `true` if the property value is a non-primitive, else `false`.\n     */\n    function isHostType(object, property) {\n      if (object == null) {\n        return false;\n      }\n      var type = typeof object[property];\n      return !rePrimitive.test(type) && (type != 'object' || !!object[property]);\n    }\n\n    /**\n     * Checks if a value can be safely coerced to a string.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the value can be coerced, else `false`.\n     */\n    function isStringable(value) {\n      return _.isString(value) || (_.has(value, 'toString') && _.isFunction(value.toString));\n    }\n\n    /**\n     * A wrapper around `require` to suppress `module missing` errors.\n     *\n     * @private\n     * @param {string} id The module id.\n     * @returns {*} The exported module or `null`.\n     */\n    function require(id) {\n      try {\n        var result = freeExports && freeRequire(id);\n      } catch(e) {}\n      return result || null;\n    }\n\n    /**\n     * Runs a snippet of JavaScript via script injection.\n     *\n     * @private\n     * @param {string} code The code to run.\n     */\n    function runScript(code) {\n      var anchor = freeDefine ? define.amd : Benchmark,\n          script = doc.createElement('script'),\n          sibling = doc.getElementsByTagName('script')[0],\n          parent = sibling.parentNode,\n          prop = uid + 'runScript',\n          prefix = '(' + (freeDefine ? 'define.amd.' : 'Benchmark.') + prop + '||function(){})();';\n\n      // Firefox 2.0.0.2 cannot use script injection as intended because it executes\n      // asynchronously, but that's OK because script injection is only used to avoid\n      // the previously commented JaegerMonkey bug.\n      try {\n        // Remove the inserted script *before* running the code to avoid differences\n        // in the expected script element count/order of the document.\n        script.appendChild(doc.createTextNode(prefix + code));\n        anchor[prop] = function() { destroyElement(script); };\n      } catch(e) {\n        parent = parent.cloneNode(false);\n        sibling = null;\n        script.text = code;\n      }\n      parent.insertBefore(script, sibling);\n      delete anchor[prop];\n    }\n\n    /**\n     * A helper function for setting options/event handlers.\n     *\n     * @private\n     * @param {Object} object The benchmark or suite instance.\n     * @param {Object} [options={}] Options object.\n     */\n    function setOptions(object, options) {\n      options = object.options = _.assign({}, cloneDeep(object.constructor.options), cloneDeep(options));\n\n      _.forOwn(options, function(value, key) {\n        if (value != null) {\n          // Add event listeners.\n          if (/^on[A-Z]/.test(key)) {\n            _.each(key.split(' '), function(key) {\n              object.on(key.slice(2).toLowerCase(), value);\n            });\n          } else if (!_.has(object, key)) {\n            object[key] = cloneDeep(value);\n          }\n        }\n      });\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Handles cycling/completing the deferred benchmark.\n     *\n     * @memberOf Benchmark.Deferred\n     */\n    function resolve() {\n      var deferred = this,\n          clone = deferred.benchmark,\n          bench = clone._original;\n\n      if (bench.aborted) {\n        // cycle() -> clone cycle/complete event -> compute()'s invoked bench.run() cycle/complete.\n        deferred.teardown();\n        clone.running = false;\n        cycle(deferred);\n      }\n      else if (++deferred.cycles < clone.count) {\n        clone.compiled.call(deferred, context, timer);\n      }\n      else {\n        timer.stop(deferred);\n        deferred.teardown();\n        delay(clone, function() { cycle(deferred); });\n      }\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * A generic `Array#filter` like method.\n     *\n     * @static\n     * @memberOf Benchmark\n     * @param {Array} array The array to iterate over.\n     * @param {Function|string} callback The function/alias called per iteration.\n     * @returns {Array} A new array of values that passed callback filter.\n     * @example\n     *\n     * // get odd numbers\n     * Benchmark.filter([1, 2, 3, 4, 5], function(n) {\n     *   return n % 2;\n     * }); // -> [1, 3, 5];\n     *\n     * // get fastest benchmarks\n     * Benchmark.filter(benches, 'fastest');\n     *\n     * // get slowest benchmarks\n     * Benchmark.filter(benches, 'slowest');\n     *\n     * // get benchmarks that completed without erroring\n     * Benchmark.filter(benches, 'successful');\n     */\n    function filter(array, callback) {\n      if (callback === 'successful') {\n        // Callback to exclude those that are errored, unrun, or have hz of Infinity.\n        callback = function(bench) {\n          return bench.cycles && _.isFinite(bench.hz) && !bench.error;\n        };\n      }\n      else if (callback === 'fastest' || callback === 'slowest') {\n        // Get successful, sort by period + margin of error, and filter fastest/slowest.\n        var result = filter(array, 'successful').sort(function(a, b) {\n          a = a.stats; b = b.stats;\n          return (a.mean + a.moe > b.mean + b.moe ? 1 : -1) * (callback === 'fastest' ? 1 : -1);\n        });\n\n        return _.filter(result, function(bench) {\n          return result[0].compare(bench) == 0;\n        });\n      }\n      return _.filter(array, callback);\n    }\n\n    /**\n     * Converts a number to a more readable comma-separated string representation.\n     *\n     * @static\n     * @memberOf Benchmark\n     * @param {number} number The number to convert.\n     * @returns {string} The more readable string representation.\n     */\n    function formatNumber(number) {\n      number = String(number).split('.');\n      return number[0].replace(/(?=(?:\\d{3})+$)(?!\\b)/g, ',') +\n        (number[1] ? '.' + number[1] : '');\n    }\n\n    /**\n     * Invokes a method on all items in an array.\n     *\n     * @static\n     * @memberOf Benchmark\n     * @param {Array} benches Array of benchmarks to iterate over.\n     * @param {Object|string} name The name of the method to invoke OR options object.\n     * @param {...*} [args] Arguments to invoke the method with.\n     * @returns {Array} A new array of values returned from each method invoked.\n     * @example\n     *\n     * // invoke `reset` on all benchmarks\n     * Benchmark.invoke(benches, 'reset');\n     *\n     * // invoke `emit` with arguments\n     * Benchmark.invoke(benches, 'emit', 'complete', listener);\n     *\n     * // invoke `run(true)`, treat benchmarks as a queue, and register invoke callbacks\n     * Benchmark.invoke(benches, {\n     *\n     *   // invoke the `run` method\n     *   'name': 'run',\n     *\n     *   // pass a single argument\n     *   'args': true,\n     *\n     *   // treat as queue, removing benchmarks from front of `benches` until empty\n     *   'queued': true,\n     *\n     *   // called before any benchmarks have been invoked.\n     *   'onStart': onStart,\n     *\n     *   // called between invoking benchmarks\n     *   'onCycle': onCycle,\n     *\n     *   // called after all benchmarks have been invoked.\n     *   'onComplete': onComplete\n     * });\n     */\n    function invoke(benches, name) {\n      var args,\n          bench,\n          queued,\n          index = -1,\n          eventProps = { 'currentTarget': benches },\n          options = { 'onStart': _.noop, 'onCycle': _.noop, 'onComplete': _.noop },\n          result = _.toArray(benches);\n\n      /**\n       * Invokes the method of the current object and if synchronous, fetches the next.\n       */\n      function execute() {\n        var listeners,\n            async = isAsync(bench);\n\n        if (async) {\n          // Use `getNext` as the first listener.\n          bench.on('complete', getNext);\n          listeners = bench.events.complete;\n          listeners.splice(0, 0, listeners.pop());\n        }\n        // Execute method.\n        result[index] = _.isFunction(bench && bench[name]) ? bench[name].apply(bench, args) : undefined;\n        // If synchronous return `true` until finished.\n        return !async && getNext();\n      }\n\n      /**\n       * Fetches the next bench or executes `onComplete` callback.\n       */\n      function getNext(event) {\n        var cycleEvent,\n            last = bench,\n            async = isAsync(last);\n\n        if (async) {\n          last.off('complete', getNext);\n          last.emit('complete');\n        }\n        // Emit \"cycle\" event.\n        eventProps.type = 'cycle';\n        eventProps.target = last;\n        cycleEvent = Event(eventProps);\n        options.onCycle.call(benches, cycleEvent);\n\n        // Choose next benchmark if not exiting early.\n        if (!cycleEvent.aborted && raiseIndex() !== false) {\n          bench = queued ? benches[0] : result[index];\n          if (isAsync(bench)) {\n            delay(bench, execute);\n          }\n          else if (async) {\n            // Resume execution if previously asynchronous but now synchronous.\n            while (execute()) {}\n          }\n          else {\n            // Continue synchronous execution.\n            return true;\n          }\n        } else {\n          // Emit \"complete\" event.\n          eventProps.type = 'complete';\n          options.onComplete.call(benches, Event(eventProps));\n        }\n        // When used as a listener `event.aborted = true` will cancel the rest of\n        // the \"complete\" listeners because they were already called above and when\n        // used as part of `getNext` the `return false` will exit the execution while-loop.\n        if (event) {\n          event.aborted = true;\n        } else {\n          return false;\n        }\n      }\n\n      /**\n       * Checks if invoking `Benchmark#run` with asynchronous cycles.\n       */\n      function isAsync(object) {\n        // Avoid using `instanceof` here because of IE memory leak issues with host objects.\n        var async = args[0] && args[0].async;\n        return name == 'run' && (object instanceof Benchmark) &&\n          ((async == null ? object.options.async : async) && support.timeout || object.defer);\n      }\n\n      /**\n       * Raises `index` to the next defined index or returns `false`.\n       */\n      function raiseIndex() {\n        index++;\n\n        // If queued remove the previous bench.\n        if (queued && index > 0) {\n          shift.call(benches);\n        }\n        // If we reached the last index then return `false`.\n        return (queued ? benches.length : index < result.length)\n          ? index\n          : (index = false);\n      }\n      // Juggle arguments.\n      if (_.isString(name)) {\n        // 2 arguments (array, name).\n        args = slice.call(arguments, 2);\n      } else {\n        // 2 arguments (array, options).\n        options = _.assign(options, name);\n        name = options.name;\n        args = _.isArray(args = 'args' in options ? options.args : []) ? args : [args];\n        queued = options.queued;\n      }\n      // Start iterating over the array.\n      if (raiseIndex() !== false) {\n        // Emit \"start\" event.\n        bench = result[index];\n        eventProps.type = 'start';\n        eventProps.target = bench;\n        options.onStart.call(benches, Event(eventProps));\n\n        // End early if the suite was aborted in an \"onStart\" listener.\n        if (name == 'run' && (benches instanceof Suite) && benches.aborted) {\n          // Emit \"cycle\" event.\n          eventProps.type = 'cycle';\n          options.onCycle.call(benches, Event(eventProps));\n          // Emit \"complete\" event.\n          eventProps.type = 'complete';\n          options.onComplete.call(benches, Event(eventProps));\n        }\n        // Start method execution.\n        else {\n          if (isAsync(bench)) {\n            delay(bench, execute);\n          } else {\n            while (execute()) {}\n          }\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Creates a string of joined array values or object key-value pairs.\n     *\n     * @static\n     * @memberOf Benchmark\n     * @param {Array|Object} object The object to operate on.\n     * @param {string} [separator1=','] The separator used between key-value pairs.\n     * @param {string} [separator2=': '] The separator used between keys and values.\n     * @returns {string} The joined result.\n     */\n    function join(object, separator1, separator2) {\n      var result = [],\n          length = (object = Object(object)).length,\n          arrayLike = length === length >>> 0;\n\n      separator2 || (separator2 = ': ');\n      _.each(object, function(value, key) {\n        result.push(arrayLike ? value : key + separator2 + value);\n      });\n      return result.join(separator1 || ',');\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Aborts all benchmarks in the suite.\n     *\n     * @name abort\n     * @memberOf Benchmark.Suite\n     * @returns {Object} The suite instance.\n     */\n    function abortSuite() {\n      var event,\n          suite = this,\n          resetting = calledBy.resetSuite;\n\n      if (suite.running) {\n        event = Event('abort');\n        suite.emit(event);\n        if (!event.cancelled || resetting) {\n          // Avoid infinite recursion.\n          calledBy.abortSuite = true;\n          suite.reset();\n          delete calledBy.abortSuite;\n\n          if (!resetting) {\n            suite.aborted = true;\n            invoke(suite, 'abort');\n          }\n        }\n      }\n      return suite;\n    }\n\n    /**\n     * Adds a test to the benchmark suite.\n     *\n     * @memberOf Benchmark.Suite\n     * @param {string} name A name to identify the benchmark.\n     * @param {Function|string} fn The test to benchmark.\n     * @param {Object} [options={}] Options object.\n     * @returns {Object} The suite instance.\n     * @example\n     *\n     * // basic usage\n     * suite.add(fn);\n     *\n     * // or using a name first\n     * suite.add('foo', fn);\n     *\n     * // or with options\n     * suite.add('foo', fn, {\n     *   'onCycle': onCycle,\n     *   'onComplete': onComplete\n     * });\n     *\n     * // or name and options\n     * suite.add('foo', {\n     *   'fn': fn,\n     *   'onCycle': onCycle,\n     *   'onComplete': onComplete\n     * });\n     *\n     * // or options only\n     * suite.add({\n     *   'name': 'foo',\n     *   'fn': fn,\n     *   'onCycle': onCycle,\n     *   'onComplete': onComplete\n     * });\n     */\n    function add(name, fn, options) {\n      var suite = this,\n          bench = new Benchmark(name, fn, options),\n          event = Event({ 'type': 'add', 'target': bench });\n\n      if (suite.emit(event), !event.cancelled) {\n        suite.push(bench);\n      }\n      return suite;\n    }\n\n    /**\n     * Creates a new suite with cloned benchmarks.\n     *\n     * @name clone\n     * @memberOf Benchmark.Suite\n     * @param {Object} options Options object to overwrite cloned options.\n     * @returns {Object} The new suite instance.\n     */\n    function cloneSuite(options) {\n      var suite = this,\n          result = new suite.constructor(_.assign({}, suite.options, options));\n\n      // Copy own properties.\n      _.forOwn(suite, function(value, key) {\n        if (!_.has(result, key)) {\n          result[key] = value && _.isFunction(value.clone)\n            ? value.clone()\n            : cloneDeep(value);\n        }\n      });\n      return result;\n    }\n\n    /**\n     * An `Array#filter` like method.\n     *\n     * @name filter\n     * @memberOf Benchmark.Suite\n     * @param {Function|string} callback The function/alias called per iteration.\n     * @returns {Object} A new suite of benchmarks that passed callback filter.\n     */\n    function filterSuite(callback) {\n      var suite = this,\n          result = new suite.constructor(suite.options);\n\n      result.push.apply(result, filter(suite, callback));\n      return result;\n    }\n\n    /**\n     * Resets all benchmarks in the suite.\n     *\n     * @name reset\n     * @memberOf Benchmark.Suite\n     * @returns {Object} The suite instance.\n     */\n    function resetSuite() {\n      var event,\n          suite = this,\n          aborting = calledBy.abortSuite;\n\n      if (suite.running && !aborting) {\n        // No worries, `resetSuite()` is called within `abortSuite()`.\n        calledBy.resetSuite = true;\n        suite.abort();\n        delete calledBy.resetSuite;\n      }\n      // Reset if the state has changed.\n      else if ((suite.aborted || suite.running) &&\n          (suite.emit(event = Event('reset')), !event.cancelled)) {\n        suite.aborted = suite.running = false;\n        if (!aborting) {\n          invoke(suite, 'reset');\n        }\n      }\n      return suite;\n    }\n\n    /**\n     * Runs the suite.\n     *\n     * @name run\n     * @memberOf Benchmark.Suite\n     * @param {Object} [options={}] Options object.\n     * @returns {Object} The suite instance.\n     * @example\n     *\n     * // basic usage\n     * suite.run();\n     *\n     * // or with options\n     * suite.run({ 'async': true, 'queued': true });\n     */\n    function runSuite(options) {\n      var suite = this;\n\n      suite.reset();\n      suite.running = true;\n      options || (options = {});\n\n      invoke(suite, {\n        'name': 'run',\n        'args': options,\n        'queued': options.queued,\n        'onStart': function(event) {\n          suite.emit(event);\n        },\n        'onCycle': function(event) {\n          var bench = event.target;\n          if (bench.error) {\n            suite.emit({ 'type': 'error', 'target': bench });\n          }\n          suite.emit(event);\n          event.aborted = suite.aborted;\n        },\n        'onComplete': function(event) {\n          suite.running = false;\n          suite.emit(event);\n        }\n      });\n      return suite;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Executes all registered listeners of the specified event type.\n     *\n     * @memberOf Benchmark, Benchmark.Suite\n     * @param {Object|string} type The event type or object.\n     * @param {...*} [args] Arguments to invoke the listener with.\n     * @returns {*} Returns the return value of the last listener executed.\n     */\n    function emit(type) {\n      var listeners,\n          object = this,\n          event = Event(type),\n          events = object.events,\n          args = (arguments[0] = event, arguments);\n\n      event.currentTarget || (event.currentTarget = object);\n      event.target || (event.target = object);\n      delete event.result;\n\n      if (events && (listeners = _.has(events, event.type) && events[event.type])) {\n        _.each(listeners.slice(), function(listener) {\n          if ((event.result = listener.apply(object, args)) === false) {\n            event.cancelled = true;\n          }\n          return !event.aborted;\n        });\n      }\n      return event.result;\n    }\n\n    /**\n     * Returns an array of event listeners for a given type that can be manipulated\n     * to add or remove listeners.\n     *\n     * @memberOf Benchmark, Benchmark.Suite\n     * @param {string} type The event type.\n     * @returns {Array} The listeners array.\n     */\n    function listeners(type) {\n      var object = this,\n          events = object.events || (object.events = {});\n\n      return _.has(events, type) ? events[type] : (events[type] = []);\n    }\n\n    /**\n     * Unregisters a listener for the specified event type(s),\n     * or unregisters all listeners for the specified event type(s),\n     * or unregisters all listeners for all event types.\n     *\n     * @memberOf Benchmark, Benchmark.Suite\n     * @param {string} [type] The event type.\n     * @param {Function} [listener] The function to unregister.\n     * @returns {Object} The current instance.\n     * @example\n     *\n     * // unregister a listener for an event type\n     * bench.off('cycle', listener);\n     *\n     * // unregister a listener for multiple event types\n     * bench.off('start cycle', listener);\n     *\n     * // unregister all listeners for an event type\n     * bench.off('cycle');\n     *\n     * // unregister all listeners for multiple event types\n     * bench.off('start cycle complete');\n     *\n     * // unregister all listeners for all event types\n     * bench.off();\n     */\n    function off(type, listener) {\n      var object = this,\n          events = object.events;\n\n      if (!events) {\n        return object;\n      }\n      _.each(type ? type.split(' ') : events, function(listeners, type) {\n        var index;\n        if (typeof listeners == 'string') {\n          type = listeners;\n          listeners = _.has(events, type) && events[type];\n        }\n        if (listeners) {\n          if (listener) {\n            index = _.indexOf(listeners, listener);\n            if (index > -1) {\n              listeners.splice(index, 1);\n            }\n          } else {\n            listeners.length = 0;\n          }\n        }\n      });\n      return object;\n    }\n\n    /**\n     * Registers a listener for the specified event type(s).\n     *\n     * @memberOf Benchmark, Benchmark.Suite\n     * @param {string} type The event type.\n     * @param {Function} listener The function to register.\n     * @returns {Object} The current instance.\n     * @example\n     *\n     * // register a listener for an event type\n     * bench.on('cycle', listener);\n     *\n     * // register a listener for multiple event types\n     * bench.on('start cycle', listener);\n     */\n    function on(type, listener) {\n      var object = this,\n          events = object.events || (object.events = {});\n\n      _.each(type.split(' '), function(type) {\n        (_.has(events, type)\n          ? events[type]\n          : (events[type] = [])\n        ).push(listener);\n      });\n      return object;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Aborts the benchmark without recording times.\n     *\n     * @memberOf Benchmark\n     * @returns {Object} The benchmark instance.\n     */\n    function abort() {\n      var event,\n          bench = this,\n          resetting = calledBy.reset;\n\n      if (bench.running) {\n        event = Event('abort');\n        bench.emit(event);\n        if (!event.cancelled || resetting) {\n          // Avoid infinite recursion.\n          calledBy.abort = true;\n          bench.reset();\n          delete calledBy.abort;\n\n          if (support.timeout) {\n            clearTimeout(bench._timerId);\n            delete bench._timerId;\n          }\n          if (!resetting) {\n            bench.aborted = true;\n            bench.running = false;\n          }\n        }\n      }\n      return bench;\n    }\n\n    /**\n     * Creates a new benchmark using the same test and options.\n     *\n     * @memberOf Benchmark\n     * @param {Object} options Options object to overwrite cloned options.\n     * @returns {Object} The new benchmark instance.\n     * @example\n     *\n     * var bizarro = bench.clone({\n     *   'name': 'doppelganger'\n     * });\n     */\n    function clone(options) {\n      var bench = this,\n          result = new bench.constructor(_.assign({}, bench, options));\n\n      // Correct the `options` object.\n      result.options = _.assign({}, cloneDeep(bench.options), cloneDeep(options));\n\n      // Copy own custom properties.\n      _.forOwn(bench, function(value, key) {\n        if (!_.has(result, key)) {\n          result[key] = cloneDeep(value);\n        }\n      });\n\n      return result;\n    }\n\n    /**\n     * Determines if a benchmark is faster than another.\n     *\n     * @memberOf Benchmark\n     * @param {Object} other The benchmark to compare.\n     * @returns {number} Returns `-1` if slower, `1` if faster, and `0` if indeterminate.\n     */\n    function compare(other) {\n      var bench = this;\n\n      // Exit early if comparing the same benchmark.\n      if (bench == other) {\n        return 0;\n      }\n      var critical,\n          zStat,\n          sample1 = bench.stats.sample,\n          sample2 = other.stats.sample,\n          size1 = sample1.length,\n          size2 = sample2.length,\n          maxSize = max(size1, size2),\n          minSize = min(size1, size2),\n          u1 = getU(sample1, sample2),\n          u2 = getU(sample2, sample1),\n          u = min(u1, u2);\n\n      function getScore(xA, sampleB) {\n        return _.reduce(sampleB, function(total, xB) {\n          return total + (xB > xA ? 0 : xB < xA ? 1 : 0.5);\n        }, 0);\n      }\n\n      function getU(sampleA, sampleB) {\n        return _.reduce(sampleA, function(total, xA) {\n          return total + getScore(xA, sampleB);\n        }, 0);\n      }\n\n      function getZ(u) {\n        return (u - ((size1 * size2) / 2)) / sqrt((size1 * size2 * (size1 + size2 + 1)) / 12);\n      }\n      // Reject the null hypothesis the two samples come from the\n      // same population (i.e. have the same median) if...\n      if (size1 + size2 > 30) {\n        // ...the z-stat is greater than 1.96 or less than -1.96\n        // http://www.statisticslectures.com/topics/mannwhitneyu/\n        zStat = getZ(u);\n        return abs(zStat) > 1.96 ? (u == u1 ? 1 : -1) : 0;\n      }\n      // ...the U value is less than or equal the critical U value.\n      critical = maxSize < 5 || minSize < 3 ? 0 : uTable[maxSize][minSize - 3];\n      return u <= critical ? (u == u1 ? 1 : -1) : 0;\n    }\n\n    /**\n     * Reset properties and abort if running.\n     *\n     * @memberOf Benchmark\n     * @returns {Object} The benchmark instance.\n     */\n    function reset() {\n      var bench = this;\n      if (bench.running && !calledBy.abort) {\n        // No worries, `reset()` is called within `abort()`.\n        calledBy.reset = true;\n        bench.abort();\n        delete calledBy.reset;\n        return bench;\n      }\n      var event,\n          index = 0,\n          changes = [],\n          queue = [];\n\n      // A non-recursive solution to check if properties have changed.\n      // For more information see http://www.jslab.dk/articles/non.recursive.preorder.traversal.part4.\n      var data = {\n        'destination': bench,\n        'source': _.assign({}, cloneDeep(bench.constructor.prototype), cloneDeep(bench.options))\n      };\n\n      do {\n        _.forOwn(data.source, function(value, key) {\n          var changed,\n              destination = data.destination,\n              currValue = destination[key];\n\n          // Skip pseudo private properties like `_timerId` which could be a\n          // Java object in environments like RingoJS.\n          if (key.charAt(0) == '_') {\n            return;\n          }\n          if (value && typeof value == 'object') {\n            if (_.isArray(value)) {\n              // Check if an array value has changed to a non-array value.\n              if (!_.isArray(currValue)) {\n                changed = currValue = [];\n              }\n              // Check if an array has changed its length.\n              if (currValue.length != value.length) {\n                changed = currValue = currValue.slice(0, value.length);\n                currValue.length = value.length;\n              }\n            }\n            // Check if an object has changed to a non-object value.\n            else if (!currValue || typeof currValue != 'object') {\n              changed = currValue = {};\n            }\n            // Register a changed object.\n            if (changed) {\n              changes.push({ 'destination': destination, 'key': key, 'value': currValue });\n            }\n            queue.push({ 'destination': currValue, 'source': value });\n          }\n          // Register a changed primitive.\n          else if (value !== currValue && !(value == null || _.isFunction(value))) {\n            changes.push({ 'destination': destination, 'key': key, 'value': value });\n          }\n        });\n      }\n      while ((data = queue[index++]));\n\n      // If changed emit the `reset` event and if it isn't cancelled reset the benchmark.\n      if (changes.length && (bench.emit(event = Event('reset')), !event.cancelled)) {\n        _.each(changes, function(data) {\n          data.destination[data.key] = data.value;\n        });\n      }\n      return bench;\n    }\n\n    /**\n     * Displays relevant benchmark information when coerced to a string.\n     *\n     * @name toString\n     * @memberOf Benchmark\n     * @returns {string} A string representation of the benchmark instance.\n     */\n    function toStringBench() {\n      var bench = this,\n          error = bench.error,\n          hz = bench.hz,\n          id = bench.id,\n          stats = bench.stats,\n          size = stats.sample.length,\n          pm = '\\xb1',\n          result = bench.name || (_.isNaN(id) ? id : '<Test #' + id + '>');\n\n      if (error) {\n        result += ': ' + join(error);\n      } else {\n        result += ' x ' + formatNumber(hz.toFixed(hz < 100 ? 2 : 0)) + ' ops/sec ' + pm +\n          stats.rme.toFixed(2) + '% (' + size + ' run' + (size == 1 ? '' : 's') + ' sampled)';\n      }\n      return result;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Clocks the time taken to execute a test per cycle (secs).\n     *\n     * @private\n     * @param {Object} bench The benchmark instance.\n     * @returns {number} The time taken.\n     */\n    function clock() {\n      var options = Benchmark.options,\n          templateData = {},\n          timers = [{ 'ns': timer.ns, 'res': max(0.0015, getRes('ms')), 'unit': 'ms' }];\n\n      // Lazy define for hi-res timers.\n      clock = function(clone) {\n        var deferred;\n\n        if (clone instanceof Deferred) {\n          deferred = clone;\n          clone = deferred.benchmark;\n        }\n        var bench = clone._original,\n            stringable = isStringable(bench.fn),\n            count = bench.count = clone.count,\n            decompilable = stringable || (support.decompilation && (clone.setup !== _.noop || clone.teardown !== _.noop)),\n            id = bench.id,\n            name = bench.name || (typeof id == 'number' ? '<Test #' + id + '>' : id),\n            result = 0;\n\n        // Init `minTime` if needed.\n        clone.minTime = bench.minTime || (bench.minTime = bench.options.minTime = options.minTime);\n\n        // Compile in setup/teardown functions and the test loop.\n        // Create a new compiled test, instead of using the cached `bench.compiled`,\n        // to avoid potential engine optimizations enabled over the life of the test.\n        var funcBody = deferred\n          ? 'var d#=this,${fnArg}=d#,m#=d#.benchmark._original,f#=m#.fn,su#=m#.setup,td#=m#.teardown;' +\n            // When `deferred.cycles` is `0` then...\n            'if(!d#.cycles){' +\n            // set `deferred.fn`,\n            'd#.fn=function(){var ${fnArg}=d#;if(typeof f#==\"function\"){try{${fn}\\n}catch(e#){f#(d#)}}else{${fn}\\n}};' +\n            // set `deferred.teardown`,\n            'd#.teardown=function(){d#.cycles=0;if(typeof td#==\"function\"){try{${teardown}\\n}catch(e#){td#()}}else{${teardown}\\n}};' +\n            // execute the benchmark's `setup`,\n            'if(typeof su#==\"function\"){try{${setup}\\n}catch(e#){su#()}}else{${setup}\\n};' +\n            // start timer,\n            't#.start(d#);' +\n            // and then execute `deferred.fn` and return a dummy object.\n            '}d#.fn();return{uid:\"${uid}\"}'\n\n          : 'var r#,s#,m#=this,f#=m#.fn,i#=m#.count,n#=t#.ns;${setup}\\n${begin};' +\n            'while(i#--){${fn}\\n}${end};${teardown}\\nreturn{elapsed:r#,uid:\"${uid}\"}';\n\n        var compiled = bench.compiled = clone.compiled = createCompiled(bench, decompilable, deferred, funcBody),\n            isEmpty = !(templateData.fn || stringable);\n\n        try {\n          if (isEmpty) {\n            // Firefox may remove dead code from `Function#toString` results.\n            // For more information see http://bugzil.la/536085.\n            throw new Error('The test \"' + name + '\" is empty. This may be the result of dead code removal.');\n          }\n          else if (!deferred) {\n            // Pretest to determine if compiled code exits early, usually by a\n            // rogue `return` statement, by checking for a return object with the uid.\n            bench.count = 1;\n            compiled = decompilable && (compiled.call(bench, context, timer) || {}).uid == templateData.uid && compiled;\n            bench.count = count;\n          }\n        } catch(e) {\n          compiled = null;\n          clone.error = e || new Error(String(e));\n          bench.count = count;\n        }\n        // Fallback when a test exits early or errors during pretest.\n        if (!compiled && !deferred && !isEmpty) {\n          funcBody = (\n            stringable || (decompilable && !clone.error)\n              ? 'function f#(){${fn}\\n}var r#,s#,m#=this,i#=m#.count'\n              : 'var r#,s#,m#=this,f#=m#.fn,i#=m#.count'\n            ) +\n            ',n#=t#.ns;${setup}\\n${begin};m#.f#=f#;while(i#--){m#.f#()}${end};' +\n            'delete m#.f#;${teardown}\\nreturn{elapsed:r#}';\n\n          compiled = createCompiled(bench, decompilable, deferred, funcBody);\n\n          try {\n            // Pretest one more time to check for errors.\n            bench.count = 1;\n            compiled.call(bench, context, timer);\n            bench.count = count;\n            delete clone.error;\n          }\n          catch(e) {\n            bench.count = count;\n            if (!clone.error) {\n              clone.error = e || new Error(String(e));\n            }\n          }\n        }\n        // If no errors run the full test loop.\n        if (!clone.error) {\n          compiled = bench.compiled = clone.compiled = createCompiled(bench, decompilable, deferred, funcBody);\n          result = compiled.call(deferred || bench, context, timer).elapsed;\n        }\n        return result;\n      };\n\n      /*----------------------------------------------------------------------*/\n\n      /**\n       * Creates a compiled function from the given function `body`.\n       */\n      function createCompiled(bench, decompilable, deferred, body) {\n        var fn = bench.fn,\n            fnArg = deferred ? getFirstArgument(fn) || 'deferred' : '';\n\n        templateData.uid = uid + uidCounter++;\n\n        _.assign(templateData, {\n          'setup': decompilable ? getSource(bench.setup) : interpolate('m#.setup()'),\n          'fn': decompilable ? getSource(fn) : interpolate('m#.fn(' + fnArg + ')'),\n          'fnArg': fnArg,\n          'teardown': decompilable ? getSource(bench.teardown) : interpolate('m#.teardown()')\n        });\n\n        // Use API of chosen timer.\n        if (timer.unit == 'ns') {\n          _.assign(templateData, {\n            'begin': interpolate('s#=n#()'),\n            'end': interpolate('r#=n#(s#);r#=r#[0]+(r#[1]/1e9)')\n          });\n        }\n        else if (timer.unit == 'us') {\n          if (timer.ns.stop) {\n            _.assign(templateData, {\n              'begin': interpolate('s#=n#.start()'),\n              'end': interpolate('r#=n#.microseconds()/1e6')\n            });\n          } else {\n            _.assign(templateData, {\n              'begin': interpolate('s#=n#()'),\n              'end': interpolate('r#=(n#()-s#)/1e6')\n            });\n          }\n        }\n        else if (timer.ns.now) {\n          _.assign(templateData, {\n            'begin': interpolate('s#=n#.now()'),\n            'end': interpolate('r#=(n#.now()-s#)/1e3')\n          });\n        }\n        else {\n          _.assign(templateData, {\n            'begin': interpolate('s#=new n#().getTime()'),\n            'end': interpolate('r#=(new n#().getTime()-s#)/1e3')\n          });\n        }\n        // Define `timer` methods.\n        timer.start = createFunction(\n          interpolate('o#'),\n          interpolate('var n#=this.ns,${begin};o#.elapsed=0;o#.timeStamp=s#')\n        );\n\n        timer.stop = createFunction(\n          interpolate('o#'),\n          interpolate('var n#=this.ns,s#=o#.timeStamp,${end};o#.elapsed=r#')\n        );\n\n        // Create compiled test.\n        return createFunction(\n          interpolate('window,t#'),\n          'var global = window, clearTimeout = global.clearTimeout, setTimeout = global.setTimeout;\\n' +\n          interpolate(body)\n        );\n      }\n\n      /**\n       * Gets the current timer's minimum resolution (secs).\n       */\n      function getRes(unit) {\n        var measured,\n            begin,\n            count = 30,\n            divisor = 1e3,\n            ns = timer.ns,\n            sample = [];\n\n        // Get average smallest measurable time.\n        while (count--) {\n          if (unit == 'us') {\n            divisor = 1e6;\n            if (ns.stop) {\n              ns.start();\n              while (!(measured = ns.microseconds())) {}\n            } else {\n              begin = ns();\n              while (!(measured = ns() - begin)) {}\n            }\n          }\n          else if (unit == 'ns') {\n            divisor = 1e9;\n            begin = (begin = ns())[0] + (begin[1] / divisor);\n            while (!(measured = ((measured = ns())[0] + (measured[1] / divisor)) - begin)) {}\n            divisor = 1;\n          }\n          else if (ns.now) {\n            begin = ns.now();\n            while (!(measured = ns.now() - begin)) {}\n          }\n          else {\n            begin = new ns().getTime();\n            while (!(measured = new ns().getTime() - begin)) {}\n          }\n          // Check for broken timers.\n          if (measured > 0) {\n            sample.push(measured);\n          } else {\n            sample.push(Infinity);\n            break;\n          }\n        }\n        // Convert to seconds.\n        return getMean(sample) / divisor;\n      }\n\n      /**\n       * Interpolates a given template string.\n       */\n      function interpolate(string) {\n        // Replaces all occurrences of `#` with a unique number and template tokens with content.\n        return _.template(string.replace(/\\#/g, /\\d+/.exec(templateData.uid)))(templateData);\n      }\n\n      /*----------------------------------------------------------------------*/\n\n      // Detect Chrome's microsecond timer:\n      // enable benchmarking via the --enable-benchmarking command\n      // line switch in at least Chrome 7 to use chrome.Interval\n      try {\n        if ((timer.ns = new (context.chrome || context.chromium).Interval)) {\n          timers.push({ 'ns': timer.ns, 'res': getRes('us'), 'unit': 'us' });\n        }\n      } catch(e) {}\n\n      // Detect Node.js's nanosecond resolution timer available in Node.js >= 0.8.\n      if (processObject && typeof (timer.ns = processObject.hrtime) == 'function') {\n        timers.push({ 'ns': timer.ns, 'res': getRes('ns'), 'unit': 'ns' });\n      }\n      // Detect Wade Simmons' Node.js `microtime` module.\n      if (microtimeObject && typeof (timer.ns = microtimeObject.now) == 'function') {\n        timers.push({ 'ns': timer.ns,  'res': getRes('us'), 'unit': 'us' });\n      }\n      // Pick timer with highest resolution.\n      timer = _.minBy(timers, 'res');\n\n      // Error if there are no working timers.\n      if (timer.res == Infinity) {\n        throw new Error('Benchmark.js was unable to find a working timer.');\n      }\n      // Resolve time span required to achieve a percent uncertainty of at most 1%.\n      // For more information see http://spiff.rit.edu/classes/phys273/uncert/uncert.html.\n      options.minTime || (options.minTime = max(timer.res / 2 / 0.01, 0.05));\n      return clock.apply(null, arguments);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Computes stats on benchmark results.\n     *\n     * @private\n     * @param {Object} bench The benchmark instance.\n     * @param {Object} options The options object.\n     */\n    function compute(bench, options) {\n      options || (options = {});\n\n      var async = options.async,\n          elapsed = 0,\n          initCount = bench.initCount,\n          minSamples = bench.minSamples,\n          queue = [],\n          sample = bench.stats.sample;\n\n      /**\n       * Adds a clone to the queue.\n       */\n      function enqueue() {\n        queue.push(bench.clone({\n          '_original': bench,\n          'events': {\n            'abort': [update],\n            'cycle': [update],\n            'error': [update],\n            'start': [update]\n          }\n        }));\n      }\n\n      /**\n       * Updates the clone/original benchmarks to keep their data in sync.\n       */\n      function update(event) {\n        var clone = this,\n            type = event.type;\n\n        if (bench.running) {\n          if (type == 'start') {\n            // Note: `clone.minTime` prop is inited in `clock()`.\n            clone.count = bench.initCount;\n          }\n          else {\n            if (type == 'error') {\n              bench.error = clone.error;\n            }\n            if (type == 'abort') {\n              bench.abort();\n              bench.emit('cycle');\n            } else {\n              event.currentTarget = event.target = bench;\n              bench.emit(event);\n            }\n          }\n        } else if (bench.aborted) {\n          // Clear abort listeners to avoid triggering bench's abort/cycle again.\n          clone.events.abort.length = 0;\n          clone.abort();\n        }\n      }\n\n      /**\n       * Determines if more clones should be queued or if cycling should stop.\n       */\n      function evaluate(event) {\n        var critical,\n            df,\n            mean,\n            moe,\n            rme,\n            sd,\n            sem,\n            variance,\n            clone = event.target,\n            done = bench.aborted,\n            now = _.now(),\n            size = sample.push(clone.times.period),\n            maxedOut = size >= minSamples && (elapsed += now - clone.times.timeStamp) / 1e3 > bench.maxTime,\n            times = bench.times,\n            varOf = function(sum, x) { return sum + pow(x - mean, 2); };\n\n        // Exit early for aborted or unclockable tests.\n        if (done || clone.hz == Infinity) {\n          maxedOut = !(size = sample.length = queue.length = 0);\n        }\n\n        if (!done) {\n          // Compute the sample mean (estimate of the population mean).\n          mean = getMean(sample);\n          // Compute the sample variance (estimate of the population variance).\n          variance = _.reduce(sample, varOf, 0) / (size - 1) || 0;\n          // Compute the sample standard deviation (estimate of the population standard deviation).\n          sd = sqrt(variance);\n          // Compute the standard error of the mean (a.k.a. the standard deviation of the sampling distribution of the sample mean).\n          sem = sd / sqrt(size);\n          // Compute the degrees of freedom.\n          df = size - 1;\n          // Compute the critical value.\n          critical = tTable[Math.round(df) || 1] || tTable.infinity;\n          // Compute the margin of error.\n          moe = sem * critical;\n          // Compute the relative margin of error.\n          rme = (moe / mean) * 100 || 0;\n\n          _.assign(bench.stats, {\n            'deviation': sd,\n            'mean': mean,\n            'moe': moe,\n            'rme': rme,\n            'sem': sem,\n            'variance': variance\n          });\n\n          // Abort the cycle loop when the minimum sample size has been collected\n          // and the elapsed time exceeds the maximum time allowed per benchmark.\n          // We don't count cycle delays toward the max time because delays may be\n          // increased by browsers that clamp timeouts for inactive tabs. For more\n          // information see https://developer.mozilla.org/en/window.setTimeout#Inactive_tabs.\n          if (maxedOut) {\n            // Reset the `initCount` in case the benchmark is rerun.\n            bench.initCount = initCount;\n            bench.running = false;\n            done = true;\n            times.elapsed = (now - times.timeStamp) / 1e3;\n          }\n          if (bench.hz != Infinity) {\n            bench.hz = 1 / mean;\n            times.cycle = mean * bench.count;\n            times.period = mean;\n          }\n        }\n        // If time permits, increase sample size to reduce the margin of error.\n        if (queue.length < 2 && !maxedOut) {\n          enqueue();\n        }\n        // Abort the `invoke` cycle when done.\n        event.aborted = done;\n      }\n\n      // Init queue and begin.\n      enqueue();\n      invoke(queue, {\n        'name': 'run',\n        'args': { 'async': async },\n        'queued': true,\n        'onCycle': evaluate,\n        'onComplete': function() { bench.emit('complete'); }\n      });\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Cycles a benchmark until a run `count` can be established.\n     *\n     * @private\n     * @param {Object} clone The cloned benchmark instance.\n     * @param {Object} options The options object.\n     */\n    function cycle(clone, options) {\n      options || (options = {});\n\n      var deferred;\n      if (clone instanceof Deferred) {\n        deferred = clone;\n        clone = clone.benchmark;\n      }\n      var clocked,\n          cycles,\n          divisor,\n          event,\n          minTime,\n          period,\n          async = options.async,\n          bench = clone._original,\n          count = clone.count,\n          times = clone.times;\n\n      // Continue, if not aborted between cycles.\n      if (clone.running) {\n        // `minTime` is set to `Benchmark.options.minTime` in `clock()`.\n        cycles = ++clone.cycles;\n        clocked = deferred ? deferred.elapsed : clock(clone);\n        minTime = clone.minTime;\n\n        if (cycles > bench.cycles) {\n          bench.cycles = cycles;\n        }\n        if (clone.error) {\n          event = Event('error');\n          event.message = clone.error;\n          clone.emit(event);\n          if (!event.cancelled) {\n            clone.abort();\n          }\n        }\n      }\n      // Continue, if not errored.\n      if (clone.running) {\n        // Compute the time taken to complete last test cycle.\n        bench.times.cycle = times.cycle = clocked;\n        // Compute the seconds per operation.\n        period = bench.times.period = times.period = clocked / count;\n        // Compute the ops per second.\n        bench.hz = clone.hz = 1 / period;\n        // Avoid working our way up to this next time.\n        bench.initCount = clone.initCount = count;\n        // Do we need to do another cycle?\n        clone.running = clocked < minTime;\n\n        if (clone.running) {\n          // Tests may clock at `0` when `initCount` is a small number,\n          // to avoid that we set its count to something a bit higher.\n          if (!clocked && (divisor = divisors[clone.cycles]) != null) {\n            count = floor(4e6 / divisor);\n          }\n          // Calculate how many more iterations it will take to achieve the `minTime`.\n          if (count <= clone.count) {\n            count += Math.ceil((minTime - clocked) / period);\n          }\n          clone.running = count != Infinity;\n        }\n      }\n      // Should we exit early?\n      event = Event('cycle');\n      clone.emit(event);\n      if (event.aborted) {\n        clone.abort();\n      }\n      // Figure out what to do next.\n      if (clone.running) {\n        // Start a new cycle.\n        clone.count = count;\n        if (deferred) {\n          clone.compiled.call(deferred, context, timer);\n        } else if (async) {\n          delay(clone, function() { cycle(clone, options); });\n        } else {\n          cycle(clone);\n        }\n      }\n      else {\n        // Fix TraceMonkey bug associated with clock fallbacks.\n        // For more information see http://bugzil.la/509069.\n        if (support.browser) {\n          runScript(uid + '=1;delete ' + uid);\n        }\n        // We're done.\n        clone.emit('complete');\n      }\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Runs the benchmark.\n     *\n     * @memberOf Benchmark\n     * @param {Object} [options={}] Options object.\n     * @returns {Object} The benchmark instance.\n     * @example\n     *\n     * // basic usage\n     * bench.run();\n     *\n     * // or with options\n     * bench.run({ 'async': true });\n     */\n    function run(options) {\n      var bench = this,\n          event = Event('start');\n\n      // Set `running` to `false` so `reset()` won't call `abort()`.\n      bench.running = false;\n      bench.reset();\n      bench.running = true;\n\n      bench.count = bench.initCount;\n      bench.times.timeStamp = _.now();\n      bench.emit(event);\n\n      if (!event.cancelled) {\n        options = { 'async': ((options = options && options.async) == null ? bench.async : options) && support.timeout };\n\n        // For clones created within `compute()`.\n        if (bench._original) {\n          if (bench.defer) {\n            Deferred(bench);\n          } else {\n            cycle(bench, options);\n          }\n        }\n        // For original benchmarks.\n        else {\n          compute(bench, options);\n        }\n      }\n      return bench;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    // Firefox 1 erroneously defines variable and argument names of functions on\n    // the function itself as non-configurable properties with `undefined` values.\n    // The bugginess continues as the `Benchmark` constructor has an argument\n    // named `options` and Firefox 1 will not assign a value to `Benchmark.options`,\n    // making it non-writable in the process, unless it is the first property\n    // assigned by for-in loop of `_.assign()`.\n    _.assign(Benchmark, {\n\n      /**\n       * The default options copied by benchmark instances.\n       *\n       * @static\n       * @memberOf Benchmark\n       * @type Object\n       */\n      'options': {\n\n        /**\n         * A flag to indicate that benchmark cycles will execute asynchronously\n         * by default.\n         *\n         * @memberOf Benchmark.options\n         * @type boolean\n         */\n        'async': false,\n\n        /**\n         * A flag to indicate that the benchmark clock is deferred.\n         *\n         * @memberOf Benchmark.options\n         * @type boolean\n         */\n        'defer': false,\n\n        /**\n         * The delay between test cycles (secs).\n         * @memberOf Benchmark.options\n         * @type number\n         */\n        'delay': 0.005,\n\n        /**\n         * Displayed by `Benchmark#toString` when a `name` is not available\n         * (auto-generated if absent).\n         *\n         * @memberOf Benchmark.options\n         * @type string\n         */\n        'id': undefined,\n\n        /**\n         * The default number of times to execute a test on a benchmark's first cycle.\n         *\n         * @memberOf Benchmark.options\n         * @type number\n         */\n        'initCount': 1,\n\n        /**\n         * The maximum time a benchmark is allowed to run before finishing (secs).\n         *\n         * Note: Cycle delays aren't counted toward the maximum time.\n         *\n         * @memberOf Benchmark.options\n         * @type number\n         */\n        'maxTime': 5,\n\n        /**\n         * The minimum sample size required to perform statistical analysis.\n         *\n         * @memberOf Benchmark.options\n         * @type number\n         */\n        'minSamples': 5,\n\n        /**\n         * The time needed to reduce the percent uncertainty of measurement to 1% (secs).\n         *\n         * @memberOf Benchmark.options\n         * @type number\n         */\n        'minTime': 0,\n\n        /**\n         * The name of the benchmark.\n         *\n         * @memberOf Benchmark.options\n         * @type string\n         */\n        'name': undefined,\n\n        /**\n         * An event listener called when the benchmark is aborted.\n         *\n         * @memberOf Benchmark.options\n         * @type Function\n         */\n        'onAbort': undefined,\n\n        /**\n         * An event listener called when the benchmark completes running.\n         *\n         * @memberOf Benchmark.options\n         * @type Function\n         */\n        'onComplete': undefined,\n\n        /**\n         * An event listener called after each run cycle.\n         *\n         * @memberOf Benchmark.options\n         * @type Function\n         */\n        'onCycle': undefined,\n\n        /**\n         * An event listener called when a test errors.\n         *\n         * @memberOf Benchmark.options\n         * @type Function\n         */\n        'onError': undefined,\n\n        /**\n         * An event listener called when the benchmark is reset.\n         *\n         * @memberOf Benchmark.options\n         * @type Function\n         */\n        'onReset': undefined,\n\n        /**\n         * An event listener called when the benchmark starts running.\n         *\n         * @memberOf Benchmark.options\n         * @type Function\n         */\n        'onStart': undefined\n      },\n\n      /**\n       * Platform object with properties describing things like browser name,\n       * version, and operating system. See [`platform.js`](https://mths.be/platform).\n       *\n       * @static\n       * @memberOf Benchmark\n       * @type Object\n       */\n      'platform': context.platform || require('platform') || ({\n        'description': context.navigator && context.navigator.userAgent || null,\n        'layout': null,\n        'product': null,\n        'name': null,\n        'manufacturer': null,\n        'os': null,\n        'prerelease': null,\n        'version': null,\n        'toString': function() {\n          return this.description || '';\n        }\n      }),\n\n      /**\n       * The semantic version number.\n       *\n       * @static\n       * @memberOf Benchmark\n       * @type string\n       */\n      'version': '2.1.1'\n    });\n\n    _.assign(Benchmark, {\n      'filter': filter,\n      'formatNumber': formatNumber,\n      'invoke': invoke,\n      'join': join,\n      'runInContext': runInContext,\n      'support': support\n    });\n\n    // Add lodash methods to Benchmark.\n    _.each(['each', 'forEach', 'forOwn', 'has', 'indexOf', 'map', 'reduce'], function(methodName) {\n      Benchmark[methodName] = _[methodName];\n    });\n\n    /*------------------------------------------------------------------------*/\n\n    _.assign(Benchmark.prototype, {\n\n      /**\n       * The number of times a test was executed.\n       *\n       * @memberOf Benchmark\n       * @type number\n       */\n      'count': 0,\n\n      /**\n       * The number of cycles performed while benchmarking.\n       *\n       * @memberOf Benchmark\n       * @type number\n       */\n      'cycles': 0,\n\n      /**\n       * The number of executions per second.\n       *\n       * @memberOf Benchmark\n       * @type number\n       */\n      'hz': 0,\n\n      /**\n       * The compiled test function.\n       *\n       * @memberOf Benchmark\n       * @type {Function|string}\n       */\n      'compiled': undefined,\n\n      /**\n       * The error object if the test failed.\n       *\n       * @memberOf Benchmark\n       * @type Object\n       */\n      'error': undefined,\n\n      /**\n       * The test to benchmark.\n       *\n       * @memberOf Benchmark\n       * @type {Function|string}\n       */\n      'fn': undefined,\n\n      /**\n       * A flag to indicate if the benchmark is aborted.\n       *\n       * @memberOf Benchmark\n       * @type boolean\n       */\n      'aborted': false,\n\n      /**\n       * A flag to indicate if the benchmark is running.\n       *\n       * @memberOf Benchmark\n       * @type boolean\n       */\n      'running': false,\n\n      /**\n       * Compiled into the test and executed immediately **before** the test loop.\n       *\n       * @memberOf Benchmark\n       * @type {Function|string}\n       * @example\n       *\n       * // basic usage\n       * var bench = Benchmark({\n       *   'setup': function() {\n       *     var c = this.count,\n       *         element = document.getElementById('container');\n       *     while (c--) {\n       *       element.appendChild(document.createElement('div'));\n       *     }\n       *   },\n       *   'fn': function() {\n       *     element.removeChild(element.lastChild);\n       *   }\n       * });\n       *\n       * // compiles to something like:\n       * var c = this.count,\n       *     element = document.getElementById('container');\n       * while (c--) {\n       *   element.appendChild(document.createElement('div'));\n       * }\n       * var start = new Date;\n       * while (count--) {\n       *   element.removeChild(element.lastChild);\n       * }\n       * var end = new Date - start;\n       *\n       * // or using strings\n       * var bench = Benchmark({\n       *   'setup': '\\\n       *     var a = 0;\\n\\\n       *     (function() {\\n\\\n       *       (function() {\\n\\\n       *         (function() {',\n       *   'fn': 'a += 1;',\n       *   'teardown': '\\\n       *          }())\\n\\\n       *        }())\\n\\\n       *      }())'\n       * });\n       *\n       * // compiles to something like:\n       * var a = 0;\n       * (function() {\n       *   (function() {\n       *     (function() {\n       *       var start = new Date;\n       *       while (count--) {\n       *         a += 1;\n       *       }\n       *       var end = new Date - start;\n       *     }())\n       *   }())\n       * }())\n       */\n      'setup': _.noop,\n\n      /**\n       * Compiled into the test and executed immediately **after** the test loop.\n       *\n       * @memberOf Benchmark\n       * @type {Function|string}\n       */\n      'teardown': _.noop,\n\n      /**\n       * An object of stats including mean, margin or error, and standard deviation.\n       *\n       * @memberOf Benchmark\n       * @type Object\n       */\n      'stats': {\n\n        /**\n         * The margin of error.\n         *\n         * @memberOf Benchmark#stats\n         * @type number\n         */\n        'moe': 0,\n\n        /**\n         * The relative margin of error (expressed as a percentage of the mean).\n         *\n         * @memberOf Benchmark#stats\n         * @type number\n         */\n        'rme': 0,\n\n        /**\n         * The standard error of the mean.\n         *\n         * @memberOf Benchmark#stats\n         * @type number\n         */\n        'sem': 0,\n\n        /**\n         * The sample standard deviation.\n         *\n         * @memberOf Benchmark#stats\n         * @type number\n         */\n        'deviation': 0,\n\n        /**\n         * The sample arithmetic mean (secs).\n         *\n         * @memberOf Benchmark#stats\n         * @type number\n         */\n        'mean': 0,\n\n        /**\n         * The array of sampled periods.\n         *\n         * @memberOf Benchmark#stats\n         * @type Array\n         */\n        'sample': [],\n\n        /**\n         * The sample variance.\n         *\n         * @memberOf Benchmark#stats\n         * @type number\n         */\n        'variance': 0\n      },\n\n      /**\n       * An object of timing data including cycle, elapsed, period, start, and stop.\n       *\n       * @memberOf Benchmark\n       * @type Object\n       */\n      'times': {\n\n        /**\n         * The time taken to complete the last cycle (secs).\n         *\n         * @memberOf Benchmark#times\n         * @type number\n         */\n        'cycle': 0,\n\n        /**\n         * The time taken to complete the benchmark (secs).\n         *\n         * @memberOf Benchmark#times\n         * @type number\n         */\n        'elapsed': 0,\n\n        /**\n         * The time taken to execute the test once (secs).\n         *\n         * @memberOf Benchmark#times\n         * @type number\n         */\n        'period': 0,\n\n        /**\n         * A timestamp of when the benchmark started (ms).\n         *\n         * @memberOf Benchmark#times\n         * @type number\n         */\n        'timeStamp': 0\n      }\n    });\n\n    _.assign(Benchmark.prototype, {\n      'abort': abort,\n      'clone': clone,\n      'compare': compare,\n      'emit': emit,\n      'listeners': listeners,\n      'off': off,\n      'on': on,\n      'reset': reset,\n      'run': run,\n      'toString': toStringBench\n    });\n\n    /*------------------------------------------------------------------------*/\n\n    _.assign(Deferred.prototype, {\n\n      /**\n       * The deferred benchmark instance.\n       *\n       * @memberOf Benchmark.Deferred\n       * @type Object\n       */\n      'benchmark': null,\n\n      /**\n       * The number of deferred cycles performed while benchmarking.\n       *\n       * @memberOf Benchmark.Deferred\n       * @type number\n       */\n      'cycles': 0,\n\n      /**\n       * The time taken to complete the deferred benchmark (secs).\n       *\n       * @memberOf Benchmark.Deferred\n       * @type number\n       */\n      'elapsed': 0,\n\n      /**\n       * A timestamp of when the deferred benchmark started (ms).\n       *\n       * @memberOf Benchmark.Deferred\n       * @type number\n       */\n      'timeStamp': 0\n    });\n\n    _.assign(Deferred.prototype, {\n      'resolve': resolve\n    });\n\n    /*------------------------------------------------------------------------*/\n\n    _.assign(Event.prototype, {\n\n      /**\n       * A flag to indicate if the emitters listener iteration is aborted.\n       *\n       * @memberOf Benchmark.Event\n       * @type boolean\n       */\n      'aborted': false,\n\n      /**\n       * A flag to indicate if the default action is cancelled.\n       *\n       * @memberOf Benchmark.Event\n       * @type boolean\n       */\n      'cancelled': false,\n\n      /**\n       * The object whose listeners are currently being processed.\n       *\n       * @memberOf Benchmark.Event\n       * @type Object\n       */\n      'currentTarget': undefined,\n\n      /**\n       * The return value of the last executed listener.\n       *\n       * @memberOf Benchmark.Event\n       * @type Mixed\n       */\n      'result': undefined,\n\n      /**\n       * The object to which the event was originally emitted.\n       *\n       * @memberOf Benchmark.Event\n       * @type Object\n       */\n      'target': undefined,\n\n      /**\n       * A timestamp of when the event was created (ms).\n       *\n       * @memberOf Benchmark.Event\n       * @type number\n       */\n      'timeStamp': 0,\n\n      /**\n       * The event type.\n       *\n       * @memberOf Benchmark.Event\n       * @type string\n       */\n      'type': ''\n    });\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * The default options copied by suite instances.\n     *\n     * @static\n     * @memberOf Benchmark.Suite\n     * @type Object\n     */\n    Suite.options = {\n\n      /**\n       * The name of the suite.\n       *\n       * @memberOf Benchmark.Suite.options\n       * @type string\n       */\n      'name': undefined\n    };\n\n    /*------------------------------------------------------------------------*/\n\n    _.assign(Suite.prototype, {\n\n      /**\n       * The number of benchmarks in the suite.\n       *\n       * @memberOf Benchmark.Suite\n       * @type number\n       */\n      'length': 0,\n\n      /**\n       * A flag to indicate if the suite is aborted.\n       *\n       * @memberOf Benchmark.Suite\n       * @type boolean\n       */\n      'aborted': false,\n\n      /**\n       * A flag to indicate if the suite is running.\n       *\n       * @memberOf Benchmark.Suite\n       * @type boolean\n       */\n      'running': false\n    });\n\n    _.assign(Suite.prototype, {\n      'abort': abortSuite,\n      'add': add,\n      'clone': cloneSuite,\n      'emit': emit,\n      'filter': filterSuite,\n      'join': arrayRef.join,\n      'listeners': listeners,\n      'off': off,\n      'on': on,\n      'pop': arrayRef.pop,\n      'push': push,\n      'reset': resetSuite,\n      'run': runSuite,\n      'reverse': arrayRef.reverse,\n      'shift': shift,\n      'slice': slice,\n      'sort': arrayRef.sort,\n      'splice': arrayRef.splice,\n      'unshift': unshift\n    });\n\n    /*------------------------------------------------------------------------*/\n\n    // Expose Deferred, Event, and Suite.\n    _.assign(Benchmark, {\n      'Deferred': Deferred,\n      'Event': Event,\n      'Suite': Suite\n    });\n\n    /*------------------------------------------------------------------------*/\n\n    // Add lodash methods as Suite methods.\n    _.each(['each', 'forEach', 'indexOf', 'map', 'reduce'], function(methodName) {\n      var func = _[methodName];\n      Suite.prototype[methodName] = function() {\n        var args = [this];\n        push.apply(args, arguments);\n        return func.apply(_, args);\n      };\n    });\n\n    // Avoid array-like object bugs with `Array#shift` and `Array#splice`\n    // in Firefox < 10 and IE < 9.\n    _.each(['pop', 'shift', 'splice'], function(methodName) {\n      var func = arrayRef[methodName];\n\n      Suite.prototype[methodName] = function() {\n        var value = this,\n            result = func.apply(value, arguments);\n\n        if (value.length === 0) {\n          delete value[0];\n        }\n        return result;\n      };\n    });\n\n    // Avoid buggy `Array#unshift` in IE < 8 which doesn't return the new\n    // length of the array.\n    Suite.prototype.unshift = function() {\n      var value = this;\n      unshift.apply(value, arguments);\n      return value.length;\n    };\n\n    return Benchmark;\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  // Export Benchmark.\n  // Some AMD build optimizers, like r.js, check for condition patterns like the following:\n  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {\n    // Define as an anonymous module so, through path mapping, it can be aliased.\n    define(['lodash', 'platform'], function(_, platform) {\n      return runInContext({\n        '_': _,\n        'platform': platform\n      });\n    });\n  }\n  else {\n    var Benchmark = runInContext();\n\n    // Check for `exports` after `define` in case a build optimizer adds an `exports` object.\n    if (freeExports && freeModule) {\n      // Export for Node.js.\n      if (moduleExports) {\n        (freeModule.exports = Benchmark).Benchmark = Benchmark;\n      }\n      // Export for CommonJS support.\n      freeExports.Benchmark = Benchmark;\n    }\n    else {\n      // Export to the global object.\n      root.Benchmark = Benchmark;\n    }\n  }\n}.call(this));\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/chai/karma.conf.js":"module.exports = function(config) {\n  config.set({\n      frameworks: [ 'mocha' ]\n    , files: [\n          'chai.js'\n        , 'test/bootstrap/karma.js'\n        , 'test/*.js'\n      ]\n    , reporters: [ 'progress' ]\n    , colors: true\n    , logLevel: config.LOG_INFO\n    , autoWatch: false\n    , browsers: [ 'PhantomJS' ]\n    , browserDisconnectTimeout: 10000\n    , browserDisconnectTolerance: 2\n    , browserNoActivityTimeout: 20000\n    , singleRun: true\n  });\n\n  switch (process.env.CHAI_TEST_ENV) {\n    case 'sauce':\n      require('./karma.sauce')(config);\n      break;\n    default:\n      // ...\n      break;\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/chai/karma.sauce.js":"var version = require('./package.json').version;\nvar ts = new Date().getTime();\n\nmodule.exports = function(config) {\n  var auth;\n\n  try {\n    auth = require('./test/auth/index');\n  } catch(ex) {\n    auth = {};\n    auth.SAUCE_USERNAME = process.env.SAUCE_USERNAME || null;\n    auth.SAUCE_ACCESS_KEY = process.env.SAUCE_ACCESS_KEY || null;\n  }\n\n  if (!auth.SAUCE_USERNAME || !auth.SAUCE_ACCESS_KEY) return;\n  if (process.env.SKIP_SAUCE) return;\n\n  var branch = process.env.TRAVIS_BRANCH || 'local'\n  var browserConfig = require('./sauce.browsers');\n  var browsers = Object.keys(browserConfig);\n  var tags = [ 'chaijs_' + version, auth.SAUCE_USERNAME + '@' + branch ];\n  var tunnel = process.env.TRAVIS_JOB_NUMBER || ts;\n\n  if (process.env.TRAVIS_JOB_NUMBER) {\n    tags.push('travis@' + process.env.TRAVIS_JOB_NUMBER);\n  }\n\n  config.browsers = config.browsers.concat(browsers);\n  config.customLaunchers = browserConfig;\n  config.reporters.push('saucelabs');\n  config.transports = [ 'xhr-polling' ];\n\n  config.sauceLabs = {\n      username: auth.SAUCE_USERNAME\n    , accessKey: auth.SAUCE_ACCESS_KEY\n    , startConnect: true\n    , tags: tags\n    , testName: 'ChaiJS'\n    , tunnelIdentifier: tunnel\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/chai/sauce.browsers.js":"\n/*!\n * Chrome\n */\n\nexports['SL_Chrome'] = {\n    base: 'SauceLabs'\n  , browserName: 'chrome'\n};\n\n/*!\n * Firefox\n */\n\n/*!\n * TODO: Karma doesn't seem to like this, though sauce boots its up\n *\n\nexports['SL_Firefox_23'] = {\n    base: 'SauceLabs'\n  , browserName: 'firefox'\n  , platform: 'Windows XP'\n  , version: '23'\n};\n\n*/\n\nexports['SL_Firefox_22'] = {\n    base: 'SauceLabs'\n  , browserName: 'firefox'\n  , platform: 'Windows 7'\n  , version: '22'\n};\n\n/*!\n * Opera\n */\n\nexports['SL_Opera_12'] = {\n    base: 'SauceLabs'\n  , browserName: 'opera'\n  , platform: 'Windows 7'\n  , version: '12'\n};\n\nexports['SL_Opera_11'] = {\n    base: 'SauceLabs'\n  , browserName: 'opera'\n  , platform: 'Windows 7'\n  , version: '11'\n};\n\n/*!\n * Internet Explorer\n */\n\nexports['SL_IE_10'] = {\n    base: 'SauceLabs'\n  , browserName: 'internet explorer'\n  , platform: 'Windows 2012'\n  , version: '10'\n};\n\n/*!\n * Safari\n */\n\nexports['SL_Safari_6'] = {\n    base: 'SauceLabs'\n  , browserName: 'safari'\n  , platform: 'Mac 10.8'\n  , version: '6'\n};\n\nexports['SL_Safari_5'] = {\n    base: 'SauceLabs'\n  , browserName: 'safari'\n  , platform: 'Mac 10.6'\n  , version: '5'\n};\n\n/*!\n * iPhone\n */\n\n/*!\n * TODO: These take forever to boot or shut down. Causes timeout.\n *\n\nexports['SL_iPhone_6'] = {\n    base: 'SauceLabs'\n  , browserName: 'iphone'\n  , platform: 'Mac 10.8'\n  , version: '6'\n};\n\nexports['SL_iPhone_5-1'] = {\n    base: 'SauceLabs'\n  , browserName: 'iphone'\n  , platform: 'Mac 10.8'\n  , version: '5.1'\n};\n\nexports['SL_iPhone_5'] = {\n    base: 'SauceLabs'\n  , browserName: 'iphone'\n  , platform: 'Mac 10.6'\n  , version: '5'\n};\n\n*/\n\n/*!\n * Android\n */\n\n/*!\n * TODO: fails because of error serialization\n *\n\nexports['SL_Android_4'] = {\n    base: 'SauceLabs'\n  , browserName: 'android'\n  , platform: 'Linux'\n  , version: '4'\n};\n\n*/\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/diff/diff.js":"/* See LICENSE file for terms of use */\n\n/*\n * Text diff implementation.\n *\n * This library supports the following APIS:\n * JsDiff.diffChars: Character by character diff\n * JsDiff.diffWords: Word (as defined by \\b regex) diff which ignores whitespace\n * JsDiff.diffLines: Line based diff\n *\n * JsDiff.diffCss: Diff targeted at CSS content\n *\n * These methods are based on the implementation proposed in\n * \"An O(ND) Difference Algorithm and its Variations\" (Myers, 1986).\n * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.4.6927\n */\n(function(global, undefined) {\n  var JsDiff = (function() {\n    /*jshint maxparams: 5*/\n    function map(arr, mapper, that) {\n      if (Array.prototype.map) {\n        return Array.prototype.map.call(arr, mapper, that);\n      }\n\n      var other = new Array(arr.length);\n\n      for (var i = 0, n = arr.length; i < n; i++) {\n        other[i] = mapper.call(that, arr[i], i, arr);\n      }\n      return other;\n    }\n    function clonePath(path) {\n      return { newPos: path.newPos, components: path.components.slice(0) };\n    }\n    function removeEmpty(array) {\n      var ret = [];\n      for (var i = 0; i < array.length; i++) {\n        if (array[i]) {\n          ret.push(array[i]);\n        }\n      }\n      return ret;\n    }\n    function escapeHTML(s) {\n      var n = s;\n      n = n.replace(/&/g, '&amp;');\n      n = n.replace(/</g, '&lt;');\n      n = n.replace(/>/g, '&gt;');\n      n = n.replace(/\"/g, '&quot;');\n\n      return n;\n    }\n\n    var Diff = function(ignoreWhitespace) {\n      this.ignoreWhitespace = ignoreWhitespace;\n    };\n    Diff.prototype = {\n        diff: function(oldString, newString) {\n          // Handle the identity case (this is due to unrolling editLength == 0\n          if (newString === oldString) {\n            return [{ value: newString }];\n          }\n          if (!newString) {\n            return [{ value: oldString, removed: true }];\n          }\n          if (!oldString) {\n            return [{ value: newString, added: true }];\n          }\n\n          newString = this.tokenize(newString);\n          oldString = this.tokenize(oldString);\n\n          var newLen = newString.length, oldLen = oldString.length;\n          var maxEditLength = newLen + oldLen;\n          var bestPath = [{ newPos: -1, components: [] }];\n\n          // Seed editLength = 0\n          var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);\n          if (bestPath[0].newPos+1 >= newLen && oldPos+1 >= oldLen) {\n            return bestPath[0].components;\n          }\n\n          for (var editLength = 1; editLength <= maxEditLength; editLength++) {\n            for (var diagonalPath = -1*editLength; diagonalPath <= editLength; diagonalPath+=2) {\n              var basePath;\n              var addPath = bestPath[diagonalPath-1],\n                  removePath = bestPath[diagonalPath+1];\n              oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n              if (addPath) {\n                // No one else is going to attempt to use this value, clear it\n                bestPath[diagonalPath-1] = undefined;\n              }\n\n              var canAdd = addPath && addPath.newPos+1 < newLen;\n              var canRemove = removePath && 0 <= oldPos && oldPos < oldLen;\n              if (!canAdd && !canRemove) {\n                bestPath[diagonalPath] = undefined;\n                continue;\n              }\n\n              // Select the diagonal that we want to branch from. We select the prior\n              // path whose position in the new string is the farthest from the origin\n              // and does not pass the bounds of the diff graph\n              if (!canAdd || (canRemove && addPath.newPos < removePath.newPos)) {\n                basePath = clonePath(removePath);\n                this.pushComponent(basePath.components, oldString[oldPos], undefined, true);\n              } else {\n                basePath = clonePath(addPath);\n                basePath.newPos++;\n                this.pushComponent(basePath.components, newString[basePath.newPos], true, undefined);\n              }\n\n              var oldPos = this.extractCommon(basePath, newString, oldString, diagonalPath);\n\n              if (basePath.newPos+1 >= newLen && oldPos+1 >= oldLen) {\n                return basePath.components;\n              } else {\n                bestPath[diagonalPath] = basePath;\n              }\n            }\n          }\n        },\n\n        pushComponent: function(components, value, added, removed) {\n          var last = components[components.length-1];\n          if (last && last.added === added && last.removed === removed) {\n            // We need to clone here as the component clone operation is just\n            // as shallow array clone\n            components[components.length-1] =\n              {value: this.join(last.value, value), added: added, removed: removed };\n          } else {\n            components.push({value: value, added: added, removed: removed });\n          }\n        },\n        extractCommon: function(basePath, newString, oldString, diagonalPath) {\n          var newLen = newString.length,\n              oldLen = oldString.length,\n              newPos = basePath.newPos,\n              oldPos = newPos - diagonalPath;\n          while (newPos+1 < newLen && oldPos+1 < oldLen && this.equals(newString[newPos+1], oldString[oldPos+1])) {\n            newPos++;\n            oldPos++;\n\n            this.pushComponent(basePath.components, newString[newPos], undefined, undefined);\n          }\n          basePath.newPos = newPos;\n          return oldPos;\n        },\n\n        equals: function(left, right) {\n          var reWhitespace = /\\S/;\n          if (this.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right)) {\n            return true;\n          } else {\n            return left === right;\n          }\n        },\n        join: function(left, right) {\n          return left + right;\n        },\n        tokenize: function(value) {\n          return value;\n        }\n    };\n\n    var CharDiff = new Diff();\n\n    var WordDiff = new Diff(true);\n    var WordWithSpaceDiff = new Diff();\n    WordDiff.tokenize = WordWithSpaceDiff.tokenize = function(value) {\n      return removeEmpty(value.split(/(\\s+|\\b)/));\n    };\n\n    var CssDiff = new Diff(true);\n    CssDiff.tokenize = function(value) {\n      return removeEmpty(value.split(/([{}:;,]|\\s+)/));\n    };\n\n    var LineDiff = new Diff();\n    LineDiff.tokenize = function(value) {\n      var retLines = [],\n          lines = value.split(/^/m);\n\n      for(var i = 0; i < lines.length; i++) {\n        var line = lines[i],\n            lastLine = lines[i - 1];\n\n        // Merge lines that may contain windows new lines\n        if (line == '\\n' && lastLine && lastLine[lastLine.length - 1] === '\\r') {\n          retLines[retLines.length - 1] += '\\n';\n        } else if (line) {\n          retLines.push(line);\n        }\n      }\n\n      return retLines;\n    };\n\n    return {\n      Diff: Diff,\n\n      diffChars: function(oldStr, newStr) { return CharDiff.diff(oldStr, newStr); },\n      diffWords: function(oldStr, newStr) { return WordDiff.diff(oldStr, newStr); },\n      diffWordsWithSpace: function(oldStr, newStr) { return WordWithSpaceDiff.diff(oldStr, newStr); },\n      diffLines: function(oldStr, newStr) { return LineDiff.diff(oldStr, newStr); },\n\n      diffCss: function(oldStr, newStr) { return CssDiff.diff(oldStr, newStr); },\n\n      createPatch: function(fileName, oldStr, newStr, oldHeader, newHeader) {\n        var ret = [];\n\n        ret.push('Index: ' + fileName);\n        ret.push('===================================================================');\n        ret.push('--- ' + fileName + (typeof oldHeader === 'undefined' ? '' : '\\t' + oldHeader));\n        ret.push('+++ ' + fileName + (typeof newHeader === 'undefined' ? '' : '\\t' + newHeader));\n\n        var diff = LineDiff.diff(oldStr, newStr);\n        if (!diff[diff.length-1].value) {\n          diff.pop();   // Remove trailing newline add\n        }\n        diff.push({value: '', lines: []});   // Append an empty value to make cleanup easier\n\n        function contextLines(lines) {\n          return map(lines, function(entry) { return ' ' + entry; });\n        }\n        function eofNL(curRange, i, current) {\n          var last = diff[diff.length-2],\n              isLast = i === diff.length-2,\n              isLastOfType = i === diff.length-3 && (current.added !== last.added || current.removed !== last.removed);\n\n          // Figure out if this is the last line for the given file and missing NL\n          if (!/\\n$/.test(current.value) && (isLast || isLastOfType)) {\n            curRange.push('\\\\ No newline at end of file');\n          }\n        }\n\n        var oldRangeStart = 0, newRangeStart = 0, curRange = [],\n            oldLine = 1, newLine = 1;\n        for (var i = 0; i < diff.length; i++) {\n          var current = diff[i],\n              lines = current.lines || current.value.replace(/\\n$/, '').split('\\n');\n          current.lines = lines;\n\n          if (current.added || current.removed) {\n            if (!oldRangeStart) {\n              var prev = diff[i-1];\n              oldRangeStart = oldLine;\n              newRangeStart = newLine;\n\n              if (prev) {\n                curRange = contextLines(prev.lines.slice(-4));\n                oldRangeStart -= curRange.length;\n                newRangeStart -= curRange.length;\n              }\n            }\n            curRange.push.apply(curRange, map(lines, function(entry) { return (current.added?'+':'-') + entry; }));\n            eofNL(curRange, i, current);\n\n            if (current.added) {\n              newLine += lines.length;\n            } else {\n              oldLine += lines.length;\n            }\n          } else {\n            if (oldRangeStart) {\n              // Close out any changes that have been output (or join overlapping)\n              if (lines.length <= 8 && i < diff.length-2) {\n                // Overlapping\n                curRange.push.apply(curRange, contextLines(lines));\n              } else {\n                // end the range and output\n                var contextSize = Math.min(lines.length, 4);\n                ret.push(\n                    '@@ -' + oldRangeStart + ',' + (oldLine-oldRangeStart+contextSize)\n                    + ' +' + newRangeStart + ',' + (newLine-newRangeStart+contextSize)\n                    + ' @@');\n                ret.push.apply(ret, curRange);\n                ret.push.apply(ret, contextLines(lines.slice(0, contextSize)));\n                if (lines.length <= 4) {\n                  eofNL(ret, i, current);\n                }\n\n                oldRangeStart = 0;  newRangeStart = 0; curRange = [];\n              }\n            }\n            oldLine += lines.length;\n            newLine += lines.length;\n          }\n        }\n\n        return ret.join('\\n') + '\\n';\n      },\n\n      applyPatch: function(oldStr, uniDiff) {\n        var diffstr = uniDiff.split('\\n');\n        var diff = [];\n        var remEOFNL = false,\n            addEOFNL = false;\n\n        for (var i = (diffstr[0][0]==='I'?4:0); i < diffstr.length; i++) {\n          if(diffstr[i][0] === '@') {\n            var meh = diffstr[i].split(/@@ -(\\d+),(\\d+) \\+(\\d+),(\\d+) @@/);\n            diff.unshift({\n              start:meh[3],\n              oldlength:meh[2],\n              oldlines:[],\n              newlength:meh[4],\n              newlines:[]\n            });\n          } else if(diffstr[i][0] === '+') {\n            diff[0].newlines.push(diffstr[i].substr(1));\n          } else if(diffstr[i][0] === '-') {\n            diff[0].oldlines.push(diffstr[i].substr(1));\n          } else if(diffstr[i][0] === ' ') {\n            diff[0].newlines.push(diffstr[i].substr(1));\n            diff[0].oldlines.push(diffstr[i].substr(1));\n          } else if(diffstr[i][0] === '\\\\') {\n            if (diffstr[i-1][0] === '+') {\n              remEOFNL = true;\n            } else if(diffstr[i-1][0] === '-') {\n              addEOFNL = true;\n            }\n          }\n        }\n\n        var str = oldStr.split('\\n');\n        for (var i = diff.length - 1; i >= 0; i--) {\n          var d = diff[i];\n          for (var j = 0; j < d.oldlength; j++) {\n            if(str[d.start-1+j] !== d.oldlines[j]) {\n              return false;\n            }\n          }\n          Array.prototype.splice.apply(str,[d.start-1,+d.oldlength].concat(d.newlines));\n        }\n\n        if (remEOFNL) {\n          while (!str[str.length-1]) {\n            str.pop();\n          }\n        } else if (addEOFNL) {\n          str.push('');\n        }\n        return str.join('\\n');\n      },\n\n      convertChangesToXML: function(changes){\n        var ret = [];\n        for ( var i = 0; i < changes.length; i++) {\n          var change = changes[i];\n          if (change.added) {\n            ret.push('<ins>');\n          } else if (change.removed) {\n            ret.push('<del>');\n          }\n\n          ret.push(escapeHTML(change.value));\n\n          if (change.added) {\n            ret.push('</ins>');\n          } else if (change.removed) {\n            ret.push('</del>');\n          }\n        }\n        return ret.join('');\n      },\n\n      // See: http://code.google.com/p/google-diff-match-patch/wiki/API\n      convertChangesToDMP: function(changes){\n        var ret = [], change;\n        for ( var i = 0; i < changes.length; i++) {\n          change = changes[i];\n          ret.push([(change.added ? 1 : change.removed ? -1 : 0), change.value]);\n        }\n        return ret;\n      }\n    };\n  })();\n\n  if (typeof module !== 'undefined') {\n      module.exports = JsDiff;\n  }\n  else if (typeof define === 'function') {\n    define([], function() { return JsDiff; });\n  }\n  else if (typeof global.JsDiff === 'undefined') {\n    global.JsDiff = JsDiff;\n  }\n})(this);\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/dojo/aspect.js":"(function (deps, factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define(deps, factory);\n    }\n})([\"require\", \"exports\"], function (require, exports) {\n    var nextId = 0;\n    function advise(dispatcher, type, advice, receiveArguments) {\n        var previous = dispatcher[type];\n        var advised = {\n            id: nextId++,\n            advice: advice,\n            receiveArguments: receiveArguments\n        };\n        if (previous) {\n            if (type === 'after') {\n                while (previous.next && (previous = previous.next)) { }\n                previous.next = advised;\n                advised.previous = previous;\n            }\n            else {\n                dispatcher.before = advised;\n                advised.next = previous;\n                previous.previous = advised;\n            }\n        }\n        else {\n            dispatcher[type] = advised;\n        }\n        advice = previous = null;\n        return {\n            remove: function () {\n                this.remove = noop;\n                var previous = advised.previous;\n                var next = advised.next;\n                if (!previous && !next) {\n                    dispatcher[type] = null;\n                }\n                else {\n                    if (previous) {\n                        previous.next = next;\n                    }\n                    else {\n                        dispatcher[type] = next;\n                    }\n                    if (next) {\n                        next.previous = previous;\n                    }\n                }\n                dispatcher = advised = null;\n            }\n        };\n    }\n    function getDispatcher(target, methodName) {\n        var existing = target[methodName];\n        var dispatcher;\n        if (!existing || existing.target !== target) {\n            target[methodName] = dispatcher = function () {\n                var executionId = nextId;\n                var args = arguments;\n                var results;\n                var before = dispatcher.before;\n                while (before) {\n                    args = before.advice.apply(this, args) || args;\n                    before = before.next;\n                }\n                if (dispatcher.around) {\n                    results = dispatcher.around.advice(this, args);\n                }\n                var after = dispatcher.after;\n                while (after && after.id < executionId) {\n                    if (after.receiveArguments) {\n                        var newResults = after.advice.apply(this, args);\n                        results = newResults === undefined ? results : newResults;\n                    }\n                    else {\n                        results = after.advice.call(this, results, args);\n                    }\n                    after = after.next;\n                }\n                return results;\n            };\n            if (existing) {\n                dispatcher.around = {\n                    advice: function (target, args) {\n                        return existing.apply(target, args);\n                    }\n                };\n            }\n            dispatcher.target = target;\n        }\n        else {\n            dispatcher = existing;\n        }\n        target = null;\n        return dispatcher;\n    }\n    function noop() { }\n    function after(target, methodName, advice) {\n        return advise(getDispatcher(target, methodName), 'after', advice);\n    }\n    exports.after = after;\n    function around(target, methodName, advice) {\n        var dispatcher = getDispatcher(target, methodName);\n        var previous = dispatcher.around;\n        var advised = advice(function () {\n            return previous.advice(this, arguments);\n        });\n        dispatcher.around = {\n            advice: function (target, args) {\n                return advised ?\n                    advised.apply(target, args) :\n                    previous.advice(target, args);\n            }\n        };\n        advice = null;\n        return {\n            remove: function () {\n                this.remove = noop;\n                advised = dispatcher = null;\n            }\n        };\n    }\n    exports.around = around;\n    function before(target, methodName, advice) {\n        return advise(getDispatcher(target, methodName), 'before', advice);\n    }\n    exports.before = before;\n    function on(target, methodName, advice) {\n        return advise(getDispatcher(target, methodName), 'after', advice, true);\n    }\n    exports.on = on;\n});\n//# sourceMappingURL=_debug/aspect.js.map","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/dojo/CallbackQueue.js":"(function (deps, factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define(deps, factory);\n    }\n})([\"require\", \"exports\"], function (require, exports) {\n    var CallbackQueue = (function () {\n        function CallbackQueue() {\n            this._callbacks = [];\n        }\n        CallbackQueue.prototype.add = function (callback) {\n            var _callback = {\n                active: true,\n                callback: callback\n            };\n            this._callbacks.push(_callback);\n            callback = null;\n            return {\n                remove: function () {\n                    this.remove = function () { };\n                    _callback.active = false;\n                    _callback = null;\n                }\n            };\n        };\n        CallbackQueue.prototype.drain = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i - 0] = arguments[_i];\n            }\n            var callbacks = this._callbacks;\n            var item;\n            this._callbacks = [];\n            for (var i = 0; i < callbacks.length; i++) {\n                item = callbacks[i];\n                if (item && item.active) {\n                    item.callback.apply(null, args);\n                }\n            }\n        };\n        return CallbackQueue;\n    })();\n    return CallbackQueue;\n});\n//# sourceMappingURL=_debug/CallbackQueue.js.map","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/dojo/cookie.js":"(function (deps, factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define(deps, factory);\n    }\n})([\"require\", \"exports\", './string'], function (require, exports) {\n    var string = require('./string');\n    var longAgo = new Date(1970, 0, 1).toUTCString();\n    function createCookieOptions(options) {\n        var optionsString = '';\n        for (var key in options) {\n            var value = options[key];\n            if (key === 'maxAge') {\n                key = 'max-age';\n            }\n            else if (key === 'secure' && !value) {\n                continue;\n            }\n            optionsString += '; ' + encodeURIComponent(key);\n            if (key === 'secure') {\n            }\n            else if (key === 'expires') {\n                optionsString += '=' + (value.toUTCString ? value.toUTCString() : value);\n            }\n            else {\n                optionsString += '=' + encodeURIComponent(value);\n            }\n        }\n        return optionsString;\n    }\n    Object.defineProperty(exports, 'length', {\n        get: function () {\n            return document.cookie.length ? string.count(document.cookie, '; ') + 1 : 0;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    function key(index) {\n        var keyValuePair = document.cookie.split('; ', index + 1)[index];\n        return keyValuePair ? decodeURIComponent(/^([^=]+)/.exec(keyValuePair)[0]) : null;\n    }\n    exports.key = key;\n    function getItem(key) {\n        var match = new RegExp('(?:^|; )' + string.escapeRegExpString(encodeURIComponent(key)) + '=([^;]*)').exec(document.cookie);\n        return match ? decodeURIComponent(match[1]) : null;\n    }\n    exports.getItem = getItem;\n    function setItem(key, data, options) {\n        if (options === void 0) { options = {}; }\n        document.cookie = encodeURIComponent(key) + '=' + encodeURIComponent(data) + createCookieOptions(options);\n    }\n    exports.setItem = setItem;\n    function removeItem(key, options) {\n        options = options ? Object.create(options) : {};\n        options.expires = longAgo;\n        document.cookie = encodeURIComponent(key) + '=' + createCookieOptions(options);\n    }\n    exports.removeItem = removeItem;\n});\n//# sourceMappingURL=_debug/cookie.js.map","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/dojo/string.js":"(function (deps, factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define(deps, factory);\n    }\n})([\"require\", \"exports\", './lang'], function (require, exports) {\n    var lang = require('./lang');\n    function repeat(string, times) {\n        if (!string || times <= 0) {\n            return '';\n        }\n        var buffer = [];\n        while (true) {\n            if (times & 1) {\n                buffer.push(string);\n            }\n            times >>= 1;\n            if (!times) {\n                break;\n            }\n            string += string;\n        }\n        return buffer.join('');\n    }\n    exports.repeat = repeat;\n    var Padding;\n    (function (Padding) {\n        Padding[Padding[\"Left\"] = 0] = \"Left\";\n        Padding[Padding[\"Right\"] = 1] = \"Right\";\n        Padding[Padding[\"Both\"] = 2] = \"Both\";\n    })(Padding || (Padding = {}));\n    ;\n    function _pad(text, size, character, position) {\n        if (position === void 0) { position = Padding.Right; }\n        var length = size - text.length, pad = exports.repeat(character, Math.ceil(length / character.length));\n        if (position === Padding.Left) {\n            return pad + text;\n        }\n        else if (position === Padding.Right) {\n            return text + pad;\n        }\n        else {\n            var left = Math.ceil(length / 2);\n            return pad.substr(0, left) + text + pad.substr(0, length - left);\n        }\n    }\n    function pad(text, size, character) {\n        if (character === void 0) { character = ' '; }\n        return _pad(text, size, character, Padding.Both);\n    }\n    exports.pad = pad;\n    function padr(text, size, character) {\n        if (character === void 0) { character = ' '; }\n        return _pad(text, size, character, Padding.Right);\n    }\n    exports.padr = padr;\n    function padl(text, size, character) {\n        if (character === void 0) { character = ' '; }\n        return _pad(text, size, character, Padding.Left);\n    }\n    exports.padl = padl;\n    var substitutePattern = /\\$\\{([^\\s\\:\\}]+)(?:\\:([^\\s\\:\\}]+))?\\}/g;\n    function defaultTransform(value) {\n        return value;\n    }\n    ;\n    function substitute(template, map, transform, context) {\n        context = context || undefined;\n        transform = transform ? transform.bind(context) : defaultTransform;\n        return template.replace(substitutePattern, function (match, key, format) {\n            var value = lang.getProperty(map, key);\n            if (format) {\n                value = lang.getProperty(context, format).call(context, value, key);\n            }\n            return transform(value, key) + '';\n        });\n    }\n    exports.substitute = substitute;\n    function count(haystack, needle) {\n        var hits = 0, lastIndex = haystack.indexOf(needle);\n        while (lastIndex > -1) {\n            ++hits;\n            lastIndex = haystack.indexOf(needle, lastIndex + 1);\n        }\n        return hits;\n    }\n    exports.count = count;\n    var regExpPattern = /[-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g;\n    function escapeRegExpString(string) {\n        return string.replace(regExpPattern, '\\\\$&');\n    }\n    exports.escapeRegExpString = escapeRegExpString;\n});\n//# sourceMappingURL=_debug/string.js.map","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/dojo/lang.js":"(function (deps, factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define(deps, factory);\n    }\n})([\"require\", \"exports\", './has'], function (require, exports) {\n    var has = require('./has');\n    has.add('es6-getpropertydescriptor', typeof Object.getPropertyDescriptor === 'function');\n    var slice = Array.prototype.slice;\n    function getDottedProperty(object, parts, create) {\n        var key;\n        var i = 0;\n        while (object && (key = parts[i++])) {\n            if (typeof object !== 'object') {\n                return undefined;\n            }\n            object = key in object ? object[key] : (create ? object[key] = {} : undefined);\n        }\n        return object;\n    }\n    function setProperty(object, propertyName, value) {\n        var parts = propertyName.split('.');\n        var part = parts.pop();\n        var property = getDottedProperty(object, parts, true);\n        if (property && part) {\n            property[part] = value;\n            return value;\n        }\n    }\n    exports.setProperty = setProperty;\n    function getProperty(object, propertyName, create) {\n        if (create === void 0) { create = false; }\n        return getDottedProperty(object, propertyName.split('.'), create);\n    }\n    exports.getProperty = getProperty;\n    function _mixin(target, source) {\n        for (var name in source) {\n            var sourceValue = source[name];\n            if (name in target && target[name] === sourceValue) {\n                continue;\n            }\n            target[name] = sourceValue;\n        }\n        return target;\n    }\n    function mixin(target) {\n        var sources = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            sources[_i - 1] = arguments[_i];\n        }\n        if (!target) {\n            target = {};\n        }\n        for (var i = 0; i < sources.length; i++) {\n            _mixin(target, sources[i]);\n        }\n        return target;\n    }\n    exports.mixin = mixin;\n    function delegate(object, properties) {\n        object = Object.create(object);\n        _mixin(object, properties);\n        return object;\n    }\n    exports.delegate = delegate;\n    var _bind = Function.prototype.bind;\n    function bind(context, fn) {\n        var extra = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            extra[_i - 2] = arguments[_i];\n        }\n        if (typeof fn === 'function') {\n            return _bind.apply(fn, [context].concat(extra));\n        }\n        return function () {\n            return context[fn].apply(context, extra.concat(slice.call(arguments, 0)));\n        };\n    }\n    exports.bind = bind;\n    function partial(fn) {\n        var extra = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            extra[_i - 1] = arguments[_i];\n        }\n        return function () {\n            return fn.apply(this, extra.concat(slice.call(arguments, 0)));\n        };\n    }\n    exports.partial = partial;\n    function deepMixin(target, source) {\n        if (source && typeof source === 'object') {\n            if (Array.isArray(source)) {\n                target.length = source.length;\n            }\n            for (var name in source) {\n                var targetValue = target[name];\n                var sourceValue = source[name];\n                if (targetValue !== sourceValue) {\n                    if (sourceValue && typeof sourceValue === 'object') {\n                        if (sourceValue instanceof RegExp ||\n                            sourceValue instanceof Date ||\n                            sourceValue instanceof String ||\n                            sourceValue instanceof Number ||\n                            sourceValue instanceof Boolean) {\n                            target[name] = targetValue = new sourceValue.constructor(sourceValue);\n                        }\n                        else if (!targetValue || typeof targetValue !== 'object') {\n                            target[name] = targetValue = Array.isArray(sourceValue) ? [] : {};\n                        }\n                        deepMixin(targetValue, sourceValue);\n                    }\n                    else {\n                        target[name] = sourceValue;\n                    }\n                }\n            }\n        }\n        return target;\n    }\n    exports.deepMixin = deepMixin;\n    function deepDelegate(source, properties) {\n        var target = delegate(source);\n        for (var name in source) {\n            var value = source[name];\n            if (value && typeof value === 'object') {\n                target[name] = deepDelegate(value);\n            }\n        }\n        return deepMixin(target, properties);\n    }\n    exports.deepDelegate = deepDelegate;\n    function isEqual(a, b) {\n        return a === b || (a !== a && b !== b);\n    }\n    exports.isEqual = isEqual;\n    exports.getPropertyDescriptor;\n    if (has('es6-getpropertydescriptor')) {\n        exports.getPropertyDescriptor = Object.getPropertyDescriptor;\n    }\n    else {\n        exports.getPropertyDescriptor = function (object, property) {\n            var descriptor;\n            while (object) {\n                descriptor = Object.getOwnPropertyDescriptor(object, property);\n                if (descriptor) {\n                    return descriptor;\n                }\n                object = Object.getPrototypeOf(object);\n            }\n            return null;\n        };\n    }\n    function pullFromArray(haystack, needle) {\n        var removed = [];\n        var i = 0;\n        while ((i = haystack.indexOf(needle, i)) > -1) {\n            removed.push(haystack.splice(i, 1)[0]);\n        }\n        return removed;\n    }\n    exports.pullFromArray = pullFromArray;\n});\n//# sourceMappingURL=_debug/lang.js.map","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/dojo/has.js":"(function (deps, factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define(deps, factory);\n    }\n})([\"require\", \"exports\"], function (require, exports) {\n    var has = require.has;\n    if (!has) {\n        has = (function () {\n            var hasCache = Object.create(null);\n            var global = this;\n            var document = global.document;\n            var element = document && document.createElement('div');\n            var has = function (name) {\n                return typeof hasCache[name] === 'function' ? (hasCache[name] = hasCache[name](global, document, element)) : hasCache[name];\n            };\n            has.add = function (name, test, now, force) {\n                (!(name in hasCache) || force) && (hasCache[name] = test);\n                now && has(name);\n            };\n            return has;\n        })();\n        has.add('host-browser', typeof document !== 'undefined' && typeof location !== 'undefined');\n        has.add('host-node', typeof process === 'object' && process.versions && process.versions.node);\n        has.add('debug', true);\n    }\n    has.normalize = function (resourceId, normalize) {\n        var tokens = resourceId.match(/[\\?:]|[^:\\?]*/g);\n        var i = 0;\n        function get(skip) {\n            var term = tokens[i++];\n            if (term === ':') {\n                return null;\n            }\n            else {\n                if (tokens[i++] === '?') {\n                    if (!skip && has(term)) {\n                        return get();\n                    }\n                    else {\n                        get(true);\n                        return get(skip);\n                    }\n                }\n                return term;\n            }\n        }\n        resourceId = get();\n        return resourceId && normalize(resourceId);\n    };\n    has.load = function (resourceId, require, load) {\n        if (resourceId) {\n            require([resourceId], load);\n        }\n        else {\n            load();\n        }\n    };\n    return has;\n});\n//# sourceMappingURL=_debug/has.js.map","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/dojo/DateObject.js":"(function (deps, factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define(deps, factory);\n    }\n})([\"require\", \"exports\"], function (require, exports) {\n    var days = [null, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    var operationOrder = ['year', 'month', 'dayOfMonth', 'hours', 'minutes', 'seconds', 'milliseconds'];\n    function isLeapYear(year) {\n        var date = new Date(year, 1, 29);\n        return date.getDate() === 29;\n    }\n    var DateObject = (function () {\n        function DateObject(value) {\n            var _date;\n            if (!arguments.length) {\n                _date = new Date();\n            }\n            else if (value instanceof Date) {\n                _date = new Date(+value);\n            }\n            else if (typeof value === 'number' || typeof value === 'string') {\n                _date = new Date(value);\n            }\n            else {\n                _date = new Date(value.year, value.month - 1, value.dayOfMonth || 1, value.hours || 0, value.minutes || 0, value.seconds || 0, value.milliseconds || 0);\n            }\n            Object.defineProperty(this, '_date', {\n                configurable: true,\n                enumerable: false,\n                value: _date,\n                writable: true\n            });\n            var self = this;\n            Object.defineProperty(this, 'utc', {\n                value: {\n                    get isLeapYear() {\n                        return isLeapYear(this.year);\n                    },\n                    get daysInMonth() {\n                        var month = this.month;\n                        if (month === 2 && this.isLeapYear) {\n                            return 29;\n                        }\n                        return days[month];\n                    },\n                    get year() {\n                        return self._date.getUTCFullYear();\n                    },\n                    set year(year) {\n                        self._date.setUTCFullYear(year);\n                    },\n                    get month() {\n                        return self._date.getUTCMonth() + 1;\n                    },\n                    set month(month) {\n                        self._date.setUTCMonth(month - 1);\n                    },\n                    get dayOfMonth() {\n                        return self._date.getUTCDate();\n                    },\n                    set dayOfMonth(day) {\n                        self._date.setUTCDate(day);\n                    },\n                    get hours() {\n                        return self._date.getUTCHours();\n                    },\n                    set hours(hours) {\n                        self._date.setUTCHours(hours);\n                    },\n                    get minutes() {\n                        return self._date.getUTCMinutes();\n                    },\n                    set minutes(minutes) {\n                        self._date.setUTCMinutes(minutes);\n                    },\n                    get seconds() {\n                        return self._date.getUTCSeconds();\n                    },\n                    set seconds(seconds) {\n                        self._date.setUTCSeconds(seconds);\n                    },\n                    get milliseconds() {\n                        return self._date.getUTCMilliseconds();\n                    },\n                    set milliseconds(milliseconds) {\n                        self._date.setUTCMilliseconds(milliseconds);\n                    },\n                    get dayOfWeek() {\n                        return self._date.getUTCDay();\n                    },\n                    toString: function () {\n                        return self._date.toUTCString();\n                    }\n                },\n                enumerable: true\n            });\n        }\n        DateObject.parse = function (string) {\n            return new DateObject(Date.parse(string));\n        };\n        DateObject.now = function () {\n            return new DateObject(Date.now());\n        };\n        Object.defineProperty(DateObject.prototype, \"isLeapYear\", {\n            get: function () {\n                return isLeapYear(this.year);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DateObject.prototype, \"daysInMonth\", {\n            get: function () {\n                var month = this.month;\n                if (month === 2 && this.isLeapYear) {\n                    return 29;\n                }\n                return days[month];\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DateObject.prototype, \"year\", {\n            get: function () {\n                return this._date.getFullYear();\n            },\n            set: function (year) {\n                var dayOfMonth = this.dayOfMonth;\n                this._date.setFullYear(year);\n                if (this.dayOfMonth < dayOfMonth) {\n                    this.dayOfMonth = 0;\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DateObject.prototype, \"month\", {\n            get: function () {\n                return this._date.getMonth() + 1;\n            },\n            set: function (month) {\n                var dayOfMonth = this.dayOfMonth;\n                this._date.setMonth(month - 1);\n                if (this.dayOfMonth < dayOfMonth) {\n                    this.dayOfMonth = 0;\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DateObject.prototype, \"dayOfMonth\", {\n            get: function () {\n                return this._date.getDate();\n            },\n            set: function (day) {\n                this._date.setDate(day);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DateObject.prototype, \"hours\", {\n            get: function () {\n                return this._date.getHours();\n            },\n            set: function (hours) {\n                this._date.setHours(hours);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DateObject.prototype, \"minutes\", {\n            get: function () {\n                return this._date.getMinutes();\n            },\n            set: function (minutes) {\n                this._date.setMinutes(minutes);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DateObject.prototype, \"seconds\", {\n            get: function () {\n                return this._date.getSeconds();\n            },\n            set: function (seconds) {\n                this._date.setSeconds(seconds);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DateObject.prototype, \"milliseconds\", {\n            get: function () {\n                return this._date.getMilliseconds();\n            },\n            set: function (milliseconds) {\n                this._date.setMilliseconds(milliseconds);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DateObject.prototype, \"time\", {\n            get: function () {\n                return this._date.getTime();\n            },\n            set: function (time) {\n                this._date.setTime(time);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DateObject.prototype, \"dayOfWeek\", {\n            get: function () {\n                return this._date.getDay();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DateObject.prototype, \"timezoneOffset\", {\n            get: function () {\n                return this._date.getTimezoneOffset();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        DateObject.prototype.add = function (value) {\n            var result = new DateObject(this);\n            operationOrder.forEach(function (property) {\n                if (!(property in value)) {\n                    return;\n                }\n                result[property] += value[property];\n            });\n            return result;\n        };\n        DateObject.prototype.toString = function () {\n            return this._date.toString();\n        };\n        DateObject.prototype.toDateString = function () {\n            return this._date.toDateString();\n        };\n        DateObject.prototype.toTimeString = function () {\n            return this._date.toTimeString();\n        };\n        DateObject.prototype.toLocaleString = function () {\n            return this._date.toLocaleString();\n        };\n        DateObject.prototype.toLocaleDateString = function () {\n            return this._date.toLocaleDateString();\n        };\n        DateObject.prototype.toLocaleTimeString = function () {\n            return this._date.toLocaleTimeString();\n        };\n        DateObject.prototype.toISOString = function () {\n            return this._date.toISOString();\n        };\n        DateObject.prototype.toJSON = function (key) {\n            return this._date.toJSON(key);\n        };\n        DateObject.prototype.valueOf = function () {\n            return this._date.valueOf();\n        };\n        return DateObject;\n    })();\n    return DateObject;\n});\n//# sourceMappingURL=_debug/DateObject.js.map","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/dojo/dom.js":"(function (deps, factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define(deps, factory);\n    }\n})([\"require\", \"exports\"], function (require, exports) {\n    function get(id, doc) {\n        if (typeof id !== 'string') {\n            return id;\n        }\n        return (doc || document).getElementById(id);\n    }\n    exports.get = get;\n});\n//# sourceMappingURL=_debug/dom.js.map","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/dojo/domReady.js":"(function (deps, factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define(deps, factory);\n    }\n})([\"require\", \"exports\", './has'], function (require, exports) {\n    var has = require('./has');\n    if (!has('host-browser')) {\n        throw new Error('dojo/domReady makes no sense to load in a non-browser environment');\n    }\n    var readyStates = Object.create(null);\n    readyStates.loaded = readyStates.complete = true;\n    var ready = readyStates[document.readyState], readyQueue = [], processing = false;\n    function processQueue() {\n        if (processing) {\n            return;\n        }\n        processing = true;\n        for (var i = 0; i < readyQueue.length; i++) {\n            readyQueue[i](document);\n        }\n        processing = false;\n    }\n    if (!ready) {\n        document.addEventListener('DOMContentLoaded', function () {\n            if (ready) {\n                return;\n            }\n            ready = true;\n            processQueue();\n        });\n    }\n    var domReady = function (callback) {\n        readyQueue.push(callback);\n        if (ready) {\n            processQueue();\n        }\n    };\n    domReady.load = function (resourceId, require, load) {\n        domReady(load);\n    };\n    return domReady;\n});\n//# sourceMappingURL=_debug/domReady.js.map","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/dojo/Evented.js":"(function (deps, factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define(deps, factory);\n    }\n})([\"require\", \"exports\", './on', './aspect'], function (require, exports) {\n    var on = require('./on');\n    var aspect = require('./aspect');\n    var Evented = (function () {\n        function Evented() {\n        }\n        Evented.prototype.on = function (type, listener) {\n            var _this = this;\n            return on.parse(this, type, listener, this, function (target, type) {\n                var name = '__on' + type;\n                if (!_this[name]) {\n                    Object.defineProperty(_this, name, {\n                        configurable: true,\n                        value: undefined,\n                        writable: true\n                    });\n                }\n                return aspect.on(_this, '__on' + type, listener);\n            });\n        };\n        Evented.prototype.emit = function (type) {\n            var args = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                args[_i - 1] = arguments[_i];\n            }\n            type = '__on' + type;\n            var method = this[type];\n            if (method) {\n                return method.apply(this, args);\n            }\n        };\n        return Evented;\n    })();\n    return Evented;\n});\n//# sourceMappingURL=_debug/Evented.js.map","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/dojo/on.js":"(function (deps, factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define(deps, factory);\n    }\n})([\"require\", \"exports\"], function (require, exports) {\n    function noop() { }\n    function addListener(target, type, listener, capture) {\n        if (target.addEventListener) {\n            target.addEventListener(type, listener, capture);\n            return {\n                remove: function () {\n                    this.remove = noop;\n                    target.removeEventListener(type, listener, capture);\n                    target = listener = null;\n                }\n            };\n        }\n        throw new Error('Target must be an event emitter');\n    }\n    var on = function (target, type, listener, capture) {\n        if (typeof target.on === 'function' && typeof type !== 'function' && !target.nodeType) {\n            return target.on(type, listener, capture);\n        }\n        return on.parse(target, type, listener, this, addListener, capture);\n    };\n    on.parse = function (target, type, listener, context, addListener, capture) {\n        if (type.call) {\n            return type.call(context, target, listener, capture);\n        }\n        if (type.indexOf(',') > -1) {\n            var events = type.split(/\\s*,\\s*/);\n            var handles = events.map(function (type) {\n                return addListener(target, type, listener, capture);\n            });\n            return {\n                remove: function () {\n                    this.remove = noop;\n                    var handle;\n                    while ((handle = handles.pop())) {\n                        handle.remove();\n                    }\n                }\n            };\n        }\n        return addListener(target, type, listener, capture);\n    };\n    on.emit = function (target, type, event) {\n        if (typeof target.emit === 'function' && !target.nodeType) {\n            return target.emit(type, event);\n        }\n        if (target.dispatchEvent && target.ownerDocument && target.ownerDocument.createEvent) {\n            var nativeEvent = target.ownerDocument.createEvent('HTMLEvents');\n            nativeEvent.initEvent(type, Boolean(event.bubbles), Boolean(event.cancelable));\n            for (var key in event) {\n                if (!(key in nativeEvent)) {\n                    nativeEvent[key] = event[key];\n                }\n            }\n            return target.dispatchEvent(nativeEvent);\n        }\n        throw new Error('Target must be an event emitter');\n    };\n    return on;\n});\n//# sourceMappingURL=_debug/on.js.map","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/dojo/io-query.js":"/**\n * @module dojo/io-query\n *\n * This module defines query string processing functions.\n */\n(function (deps, factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define(deps, factory);\n    }\n})([\"require\", \"exports\"], function (require, exports) {\n    function objectToQuery(map) {\n        var query = [];\n        var value;\n        for (var key in map) {\n            value = map[key];\n            key = encodeURIComponent(key);\n            if (typeof value === 'boolean') {\n                value && query.push(key);\n            }\n            else if (Array.isArray(value)) {\n                for (var i = 0, j = value.length; i < j; ++i) {\n                    query.push(key + '=' + encodeURIComponent(value[i]));\n                }\n            }\n            else {\n                query.push(key + '=' + encodeURIComponent(value));\n            }\n        }\n        return query.join('&');\n    }\n    exports.objectToQuery = objectToQuery;\n});\n//# sourceMappingURL=_debug/io-query.js.map","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/dojo/kernel.js":"(function (deps, factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define(deps, factory);\n    }\n})([\"require\", \"exports\"], function (require, exports) {\n    exports.version = {\n        major: 2,\n        minor: 0,\n        patch: 0,\n        flag: 'dev',\n        revision: ('$Rev$'.match(/[0-9a-f]{7,}/) || [])[0],\n        toString: function () {\n            var v = this;\n            return v.major + '.' + v.minor + '.' + v.patch +\n                (v.flag ? '-' + v.flag : '') +\n                (v.revision ? '+' + v.revision : '');\n        }\n    };\n});\n//# sourceMappingURL=_debug/kernel.js.map","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/dojo/loader.js":"(function () {\n    var req = function (config, dependencies, callback) {\n        if (Array.isArray(config) || typeof config === 'string') {\n            callback = dependencies;\n            dependencies = config;\n            config = {};\n        }\n        if (has('loader-configurable')) {\n            configure(config);\n        }\n        contextRequire(dependencies, callback);\n    };\n    var has = req.has = (function () {\n        var hasCache = Object.create(null);\n        var global = this;\n        var document = global.document;\n        var element = document && document.createElement('div');\n        var has = function (name) {\n            return typeof hasCache[name] === 'function' ? (hasCache[name] = hasCache[name](global, document, element)) : hasCache[name];\n        };\n        has.add = function (name, test, now, force) {\n            (!(name in hasCache) || force) && (hasCache[name] = test);\n            now && has(name);\n        };\n        return has;\n    })();\n    has.add('host-browser', typeof document !== 'undefined' && typeof location !== 'undefined');\n    has.add('host-node', typeof process === 'object' && process.versions && process.versions.node);\n    has.add('debug', true);\n    has.add('loader-ie9-compat', has('host-browser') && navigator.userAgent.indexOf('MSIE 9.0') > -1);\n    has.add('loader-configurable', true);\n    if (has('loader-configurable')) {\n        var configure = req.config = function (config) {\n            baseUrl = (config.baseUrl || baseUrl).replace(/\\/*$/, '/');\n            forEach(config.packages, function (p) {\n                if (typeof p === 'string') {\n                    p = { name: p, location: p };\n                }\n                if (p.location != null) {\n                    p.location = p.location.replace(/\\/*$/, '/');\n                }\n                packs[p.name] = p;\n            });\n            function computeMapProg(map) {\n                // This method takes a map as represented by a JavaScript object and initializes an array of\n                // arrays of (map-key, map-value, regex-for-map-key, length-of-map-key), sorted decreasing by length-\n                // of-map-key. The regex looks for the map-key followed by either \"/\" or end-of-string at the beginning\n                // of a the search source.\n                //\n                // Maps look like this:\n                //\n                // map: { C: { D: E } }\n                //      A    B\n                //\n                // The computed mapping is a 4-array deep tree, where the outermost array corresponds to the source\n                // mapping object A, the 2nd level arrays each correspond to one of the source mappings C -> B, the 3rd\n                // level arrays correspond to each destination mapping object B, and the innermost arrays each\n                // correspond to one of the destination mappings D -> E.\n                //\n                // So, the overall structure looks like this:\n                //\n                // mapProgs = [ source mapping array, source mapping array, ... ]\n                // source mapping array = [\n                //     source module id,\n                //     [ destination mapping array, destination mapping array, ... ],\n                //     RegExp that matches on source module id,\n                //     source module id length\n                // ]\n                // destination mapping array = [\n                //     original module id,\n                //     destination module id,\n                //     RegExp that matches on original module id,\n                //     original module id length\n                // ]\n                var result = [];\n                for (var moduleId in map) {\n                    var value = map[moduleId];\n                    var valueIsMapReplacement = typeof value === 'object';\n                    var item = {\n                        0: moduleId,\n                        1: valueIsMapReplacement ? computeMapProg(value) : value,\n                        2: new RegExp('^' + moduleId.replace(/[-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, '\\\\$&') + '(?:\\/|$)'),\n                        3: moduleId.length\n                    };\n                    result.push(item);\n                    if (valueIsMapReplacement && moduleId === '*') {\n                        result.star = item[1];\n                    }\n                }\n                result.sort(function (lhs, rhs) {\n                    return rhs[3] - lhs[3];\n                });\n                return result;\n            }\n            mix(map, config.map);\n            mapProgs = computeMapProg(map);\n            config.paths && (pathsMapProg = computeMapProg(config.paths));\n        };\n    }\n    var baseUrl = './';\n    var packs = {};\n    var pathsMapProg = [];\n    var map = {};\n    var mapProgs = [];\n    var modules = {};\n    var cache = {};\n    var pendingCacheInsert = {};\n    function forEach(array, callback) {\n        array && array.forEach(callback);\n    }\n    function mix(target, source) {\n        for (var key in source) {\n            target[key] = source[key];\n        }\n        return target;\n    }\n    function signal(type, event) {\n        req.signal.apply(req, arguments);\n    }\n    function consumePendingCacheInsert(referenceModule) {\n        var item;\n        for (var key in pendingCacheInsert) {\n            item = pendingCacheInsert[key];\n            cache[typeof item === 'string' ? toUrl(key, referenceModule) : getModuleInfo(key, referenceModule).mid] = item;\n        }\n        pendingCacheInsert = {};\n    }\n    var uidGenerator = 0;\n    function contextRequire(a1, a2, referenceModule) {\n        var module;\n        if (typeof a1 === 'string') {\n            module = getModule(a1, referenceModule);\n            if (module.executed !== true && module.executed !== EXECUTING) {\n                throw new Error('Attempt to require unloaded module ' + module.mid);\n            }\n            module = module.result;\n        }\n        else if (Array.isArray(a1)) {\n            module = getModuleInfo('*' + (++uidGenerator));\n            mix(module, {\n                deps: resolveDeps(a1, module, referenceModule),\n                def: a2 || {},\n                gc: true\n            });\n            guardCheckComplete(function () {\n                forEach(module.deps, injectModule.bind(null, module));\n            });\n            execQ.push(module);\n            checkComplete();\n        }\n        return module;\n    }\n    function createRequire(module) {\n        var result = (!module && req) || module.require;\n        if (!result) {\n            module.require = result = function (a1, a2) {\n                return contextRequire(a1, a2, module);\n            };\n            mix(mix(result, req), {\n                toUrl: function (name) {\n                    return toUrl(name, module);\n                },\n                toAbsMid: function (mid) {\n                    return toAbsMid(mid, module);\n                }\n            });\n        }\n        return result;\n    }\n    var execQ = [];\n    var defArgs = null;\n    var waitingCount = 0;\n    function runMapProg(targetMid, map) {\n        if (map) {\n            for (var i = 0, j = map.length; i < j; ++i) {\n                if (map[i][2].test(targetMid)) {\n                    return map[i];\n                }\n            }\n        }\n        return null;\n    }\n    function compactPath(path) {\n        var result = [];\n        var segment;\n        var lastSegment;\n        var splitPath = path.replace(/\\\\/g, '/').split('/');\n        while (splitPath.length) {\n            segment = splitPath.shift();\n            if (segment === '..' && result.length && lastSegment !== '..') {\n                result.pop();\n                lastSegment = result[result.length - 1];\n            }\n            else if (segment !== '.') {\n                result.push((lastSegment = segment));\n            }\n        }\n        return result.join('/');\n    }\n    function getModuleInfo(mid, referenceModule) {\n        var match;\n        var pid;\n        var pack;\n        var midInPackage;\n        var mapItem;\n        var url;\n        var result;\n        mid = compactPath(/^\\./.test(mid) && referenceModule ? (referenceModule.mid + '/../' + mid) : mid);\n        var moduleMap = referenceModule && runMapProg(referenceModule.mid, mapProgs);\n        moduleMap = moduleMap ? moduleMap[1] : mapProgs.star;\n        if ((mapItem = runMapProg(mid, moduleMap))) {\n            mid = mapItem[1] + mid.slice(mapItem[3]);\n        }\n        match = mid.match(/^([^\\/]+)(\\/(.+))?$/);\n        pid = match ? match[1] : '';\n        pack = packs[pid];\n        if (pack) {\n            mid = pid + '/' + (midInPackage = (match[3] || pack.main || 'main'));\n        }\n        else {\n            pid = '';\n        }\n        if (!(result = modules[mid])) {\n            mapItem = runMapProg(mid, pathsMapProg);\n            url = mapItem ? mapItem[1] + mid.slice(mapItem[3]) : (pid ? pack.location + midInPackage : mid);\n            result = {\n                pid: pid,\n                mid: mid,\n                pack: pack,\n                url: compactPath((/^(?:\\/|\\w+:)/.test(url) ? '' : baseUrl) +\n                    url +\n                    (/\\.js(?:\\?[^?]*)?$/.test(url) ? '' : '.js'))\n            };\n        }\n        return result;\n    }\n    function resolvePluginResourceId(plugin, prid, contextRequire) {\n        return plugin.normalize ? plugin.normalize(prid, contextRequire.toAbsMid) : contextRequire.toAbsMid(prid);\n    }\n    function getModule(mid, referenceModule) {\n        var match;\n        var plugin;\n        var prid;\n        var result;\n        var contextRequire;\n        var loaded;\n        match = mid.match(/^(.+?)\\!(.*)$/);\n        if (match) {\n            plugin = getModule(match[1], referenceModule);\n            loaded = Boolean(plugin.load);\n            contextRequire = createRequire(referenceModule);\n            if (loaded) {\n                prid = resolvePluginResourceId(plugin, match[2], contextRequire);\n                mid = (plugin.mid + '!' + (plugin.dynamic ? ++uidGenerator + '!' : '') + prid);\n            }\n            else {\n                prid = match[2];\n                mid = plugin.mid + '!' + (++uidGenerator) + '!*';\n            }\n            result = {\n                plugin: plugin,\n                mid: mid,\n                req: contextRequire,\n                prid: prid,\n                fix: !loaded\n            };\n        }\n        else {\n            result = getModuleInfo(mid, referenceModule);\n        }\n        return modules[result.mid] || (modules[result.mid] = result);\n    }\n    function toAbsMid(mid, referenceModule) {\n        return getModuleInfo(mid, referenceModule).mid;\n    }\n    function toUrl(name, referenceModule) {\n        var moduleInfo = getModuleInfo(name + '/x', referenceModule);\n        var url = moduleInfo.url;\n        return url.slice(0, url.length - 5);\n    }\n    function makeCjs(mid) {\n        var module = modules[mid] = {\n            mid: mid,\n            injected: true,\n            executed: true\n        };\n        return module;\n    }\n    var cjsRequireModule = makeCjs('require');\n    var cjsExportsModule = makeCjs('exports');\n    var cjsModuleModule = makeCjs('module');\n    var EXECUTING = 'executing';\n    var abortExec = {};\n    var executedSomething = false;\n    has.add('loader-debug-circular-dependencies', true);\n    if (has('loader-debug-circular-dependencies')) {\n        var circularTrace = [];\n    }\n    function execModule(module) {\n        if (module.executed === EXECUTING) {\n            if (has('loader-debug-circular-dependencies') &&\n                module.deps.indexOf(cjsExportsModule) === -1 &&\n                typeof console !== 'undefined') {\n                console.warn('Circular dependency: ' + circularTrace.concat(module.mid).join(' -> '));\n            }\n            return module.cjs.exports;\n        }\n        if (!module.executed) {\n            if (!module.def && !module.deps) {\n                return abortExec;\n            }\n            var deps = module.deps;\n            var factory = module.def;\n            var result;\n            var args;\n            has('loader-debug-circular-dependencies') && circularTrace.push(module.mid);\n            module.executed = EXECUTING;\n            args = deps.map(function (dep) {\n                if (result !== abortExec) {\n                    result = ((dep === cjsRequireModule) ? createRequire(module) :\n                        ((dep === cjsExportsModule) ? module.cjs.exports :\n                            ((dep === cjsModuleModule) ? module.cjs :\n                                execModule(dep))));\n                }\n                return result;\n            });\n            if (result === abortExec) {\n                module.executed = false;\n                has('loader-debug-circular-dependencies') && circularTrace.pop();\n                return abortExec;\n            }\n            result = typeof factory === 'function' ? factory.apply(null, args) : factory;\n            result = module.result = result === undefined && module.cjs ? module.cjs.exports : result;\n            module.executed = true;\n            executedSomething = true;\n            if (module.gc) {\n                modules[module.mid] = undefined;\n            }\n            result && result.load && ['dynamic', 'normalize', 'load'].forEach(function (key) {\n                module[key] = result[key];\n            });\n            forEach(module.loadQ, function (pseudoPluginResource) {\n                var prid = resolvePluginResourceId(module, pseudoPluginResource.prid, pseudoPluginResource.req);\n                var mid = module.dynamic ? pseudoPluginResource.mid.replace(/\\*$/, prid) : (module.mid + '!' + prid);\n                var pluginResource = mix(mix({}, pseudoPluginResource), { mid: mid, prid: prid });\n                if (!modules[mid]) {\n                    injectPlugin((modules[mid] = pluginResource));\n                }\n                pseudoPluginResource.fix(modules[mid]);\n                --waitingCount;\n                modules[pseudoPluginResource.mid] = undefined;\n            });\n            module.loadQ = undefined;\n            has('loader-debug-circular-dependencies') && circularTrace.pop();\n        }\n        return module.result;\n    }\n    var checkCompleteGuard = 0;\n    function guardCheckComplete(proc) {\n        ++checkCompleteGuard;\n        proc();\n        --checkCompleteGuard;\n        !defArgs && !waitingCount && !execQ.length && !checkCompleteGuard && signal('idle', []);\n    }\n    function checkComplete() {\n        !checkCompleteGuard && guardCheckComplete(function () {\n            for (var module, i = 0; i < execQ.length;) {\n                module = execQ[i];\n                if (module.executed === true) {\n                    execQ.splice(i, 1);\n                }\n                else {\n                    executedSomething = false;\n                    execModule(module);\n                    if (executedSomething) {\n                        i = 0;\n                    }\n                    else {\n                        i++;\n                    }\n                }\n            }\n        });\n    }\n    function injectPlugin(module) {\n        var plugin = module.plugin;\n        var onLoad = function (def) {\n            module.result = def;\n            --waitingCount;\n            module.executed = true;\n            checkComplete();\n        };\n        if (plugin.load) {\n            plugin.load(module.prid, module.req, onLoad);\n        }\n        else if (plugin.loadQ) {\n            plugin.loadQ.push(module);\n        }\n        else {\n            plugin.loadQ = [module];\n            execQ.unshift(plugin);\n            injectModule(module, plugin);\n        }\n    }\n    function injectModule(parent, module) {\n        if (!module) {\n            module = parent;\n            parent = null;\n        }\n        if (module.plugin) {\n            injectPlugin(module);\n        }\n        else if (!module.injected) {\n            var cached;\n            var onLoadCallback = function (node) {\n                consumePendingCacheInsert(module);\n                if (has('loader-ie9-compat') && node) {\n                    defArgs = node.defArgs;\n                }\n                if (!defArgs) {\n                    defArgs = [[], undefined];\n                }\n                defineModule(module, defArgs[0], defArgs[1]);\n                defArgs = null;\n                guardCheckComplete(function () {\n                    forEach(module.deps, injectModule.bind(null, module));\n                });\n                checkComplete();\n            };\n            ++waitingCount;\n            module.injected = true;\n            if ((cached = cache[module.mid])) {\n                try {\n                    cached();\n                    onLoadCallback();\n                    return;\n                }\n                catch (error) {\n                    signal('cachedThrew', [error, module]);\n                }\n            }\n            injectUrl(module.url, onLoadCallback, module, parent);\n        }\n    }\n    function resolveDeps(deps, module, referenceModule) {\n        return deps.map(function (dep, i) {\n            var result = getModule(dep, referenceModule);\n            if (result.fix) {\n                result.fix = function (m) {\n                    module.deps[i] = m;\n                };\n            }\n            return result;\n        });\n    }\n    function defineModule(module, deps, def) {\n        --waitingCount;\n        return mix(module, {\n            def: def,\n            deps: resolveDeps(deps, module, module),\n            cjs: {\n                id: module.mid,\n                uri: module.url,\n                exports: (module.result = {}),\n                setExports: function (exports) {\n                    module.cjs.exports = exports;\n                }\n            }\n        });\n    }\n    has.add('function-bind', Boolean(Function.prototype.bind));\n    if (!has('function-bind')) {\n        injectModule.bind = function (thisArg) {\n            var slice = Array.prototype.slice;\n            var args = slice.call(arguments, 1);\n            return function () {\n                return injectModule.apply(thisArg, args.concat(slice.call(arguments, 0)));\n            };\n        };\n    }\n    var setGlobals;\n    var injectUrl;\n    if (has('host-node')) {\n        var vm = require('vm');\n        var fs = require('fs');\n        req.nodeRequire = require;\n        injectUrl = function (url, callback, module, parent) {\n            fs.readFile(url, 'utf8', function (error, data) {\n                if (error) {\n                    throw new Error('Failed to load module ' + module.mid + ' from ' + url + (parent ? ' (parent: ' + parent.mid + ')' : ''));\n                }\n                var oldModule = this.module;\n                this.module = undefined;\n                try {\n                    vm.runInThisContext(data, url);\n                }\n                finally {\n                    this.module = oldModule;\n                }\n                callback();\n            });\n        };\n        setGlobals = function (require, define) {\n            module.exports = this.require = require;\n            this.define = define;\n        };\n    }\n    else if (has('host-browser')) {\n        injectUrl = function (url, callback, module, parent) {\n            var node = document.createElement('script');\n            var handler = function (event) {\n                document.head.removeChild(node);\n                if (event.type === 'load') {\n                    has('loader-ie9-compat') ? callback(node) : callback();\n                }\n                else {\n                    throw new Error('Failed to load module ' + module.mid + ' from ' + url + (parent ? ' (parent: ' + parent.mid + ')' : ''));\n                }\n            };\n            node.addEventListener('load', handler, false);\n            node.addEventListener('error', handler, false);\n            node.crossOrigin = 'anonymous';\n            node.charset = 'utf-8';\n            node.src = url;\n            document.head.appendChild(node);\n        };\n        setGlobals = function (require, define) {\n            this.require = require;\n            this.define = define;\n        };\n    }\n    else {\n        throw new Error('Unsupported platform');\n    }\n    has.add('loader-debug-internals', true);\n    if (has('loader-debug-internals')) {\n        req.inspect = function (name) {\n            return eval(name);\n        };\n    }\n    has.add('loader-undef', true);\n    if (has('loader-undef')) {\n        req.undef = function (id) {\n            if (modules[id]) {\n                modules[id] = undefined;\n            }\n        };\n    }\n    mix(req, {\n        signal: function () { },\n        toAbsMid: toAbsMid,\n        toUrl: toUrl,\n        cache: function (cache) {\n            consumePendingCacheInsert();\n            pendingCacheInsert = cache;\n        }\n    });\n    Object.defineProperty(req, 'baseUrl', {\n        get: function () {\n            return baseUrl;\n        },\n        enumerable: true\n    });\n    has.add('loader-cjs-wrapping', true);\n    if (has('loader-cjs-wrapping')) {\n        var comments = /\\/\\*[\\s\\S]*?\\*\\/|\\/\\/.*$/mg;\n        var requireCall = /require\\s*\\(\\s*([\"'])(.*?[^\\\\])\\1\\s*\\)/g;\n    }\n    has.add('loader-explicit-mid', true);\n    var define = mix(function (deps, factory) {\n        if (has('loader-explicit-mid') && arguments.length === 3) {\n            var id = deps;\n            deps = factory;\n            factory = arguments[2];\n            if (id != null) {\n                var module = getModule(id);\n                module.injected = true;\n                defineModule(module, deps, factory);\n            }\n        }\n        if (arguments.length === 1) {\n            if (has('loader-cjs-wrapping') && typeof deps === 'function') {\n                factory = deps;\n                deps = ['require', 'exports', 'module'];\n                factory.toString()\n                    .replace(comments, '')\n                    .replace(requireCall, function () {\n                    deps.push(arguments[2]);\n                    return arguments[0];\n                });\n            }\n            else if (!Array.isArray(deps)) {\n                var value = deps;\n                deps = [];\n                factory = function () {\n                    return value;\n                };\n            }\n        }\n        if (has('loader-ie9-compat')) {\n            for (var i = document.scripts.length - 1, script; (script = document.scripts[i]); --i) {\n                if (script.readyState === 'interactive') {\n                    script.defArgs = [deps, factory];\n                    break;\n                }\n            }\n        }\n        else {\n            defArgs = [deps, factory];\n        }\n    }, {\n        amd: { vendor: 'dojotoolkit.org' }\n    });\n    setGlobals(req, define);\n})();\n//# sourceMappingURL=_debug/loader.js.map","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/dojo/nextTick.js":"(function (deps, factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define(deps, factory);\n    }\n})([\"require\", \"exports\", './CallbackQueue', './has'], function (require, exports) {\n    var CallbackQueue = require('./CallbackQueue');\n    var has = require('./has');\n    has.add('dom-mutationobserver', function (global) {\n        return has('host-browser') && Boolean(global.MutationObserver || global.WebKitMutationObserver);\n    });\n    function noop() { }\n    var nextTick;\n    if (typeof setImmediate !== 'undefined' &&\n        (!has('host-node') || (has('host-node') && process.version.indexOf('v0.10.') === 0))) {\n        nextTick = function (callback) {\n            var timer = setImmediate(callback);\n            return {\n                remove: function () {\n                    this.remove = noop;\n                    clearImmediate(timer);\n                }\n            };\n        };\n    }\n    else if (has('host-node')) {\n        nextTick = function (callback) {\n            var removed = false;\n            process.nextTick(function () {\n                if (removed) {\n                    return;\n                }\n                callback();\n            });\n            return {\n                remove: function () {\n                    this.remove = noop;\n                    removed = true;\n                }\n            };\n        };\n    }\n    else {\n        var queue = new CallbackQueue();\n        if (has('dom-mutationobserver')) {\n            nextTick = (function () {\n                var MutationObserver = this.MutationObserver || this.WebKitMutationObserver;\n                var element = document.createElement('div');\n                var observer = new MutationObserver(function () {\n                    queue.drain();\n                });\n                observer.observe(element, { attributes: true });\n                return function (callback) {\n                    var handle = queue.add(callback);\n                    element.setAttribute('drainQueue', '1');\n                    return handle;\n                };\n            })();\n        }\n        else {\n            nextTick = (function () {\n                var timer;\n                return function (callback) {\n                    var handle = queue.add(callback);\n                    if (!timer) {\n                        timer = setTimeout(function () {\n                            clearTimeout(timer);\n                            timer = null;\n                            queue.drain();\n                        }, 0);\n                    }\n                    return handle;\n                };\n            })();\n        }\n    }\n    return nextTick;\n});\n//# sourceMappingURL=_debug/nextTick.js.map","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/dojo/node.js":"(function (deps, factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define(deps, factory);\n    }\n})([\"require\", \"exports\"], function (require, exports) {\n    var global = (function () {\n        return this;\n    })();\n    var nodeRequire = global.require && global.require.nodeRequire;\n    if (!nodeRequire) {\n        throw new Error('Cannot find the Node.js require');\n    }\n    var module = nodeRequire('module');\n    function load(id, contextRequire, load) {\n        /*global define:true */\n        if (module._findPath && module._nodeModulePaths) {\n            var localModulePath = module._findPath(id, module._nodeModulePaths(contextRequire.toUrl('.')));\n            if (localModulePath !== false) {\n                id = localModulePath;\n            }\n        }\n        var oldDefine = global.define;\n        var result;\n        global.define = undefined;\n        try {\n            result = nodeRequire(id);\n        }\n        finally {\n            global.define = oldDefine;\n        }\n        load(result);\n    }\n    exports.load = load;\n    function normalize(id, normalize) {\n        if (id.charAt(0) === '.') {\n            id = require.toUrl(normalize('./' + id));\n        }\n        return id;\n    }\n    exports.normalize = normalize;\n});\n//# sourceMappingURL=_debug/node.js.map","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/dojo/Observable.js":"(function (deps, factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define(deps, factory);\n    }\n})([\"require\", \"exports\", './lang', './Scheduler'], function (require, exports) {\n    var lang = require('./lang');\n    var Scheduler = require('./Scheduler');\n    var Observable = (function () {\n        function Observable(props) {\n            if (props) {\n                lang.mixin(this, props);\n            }\n            Object.defineProperties(this, {\n                _callbacks: {\n                    value: {}\n                },\n                _dispatch: {\n                    configurable: true,\n                    value: this._dispatch.bind(this),\n                    writable: true\n                },\n                _notifications: {\n                    value: Object.create(null),\n                    writable: true\n                },\n                _timer: {\n                    value: null,\n                    writable: true\n                }\n            });\n        }\n        Observable.prototype._dispatch = function () {\n            if (this._timer) {\n                this._timer.remove();\n                this._timer = null;\n            }\n            var notifications = this._notifications;\n            this._notifications = Object.create(null);\n            for (var property in notifications) {\n                var notification = notifications[property];\n                if (this._isEqual(notification.oldValue, notification.newValue)) {\n                    continue;\n                }\n                var callback;\n                for (var i = 0; (callback = notification.callbacks[i]); i++) {\n                    if (!callback.removed) {\n                        callback.callback.call(this, notification.newValue, notification.oldValue);\n                    }\n                }\n            }\n        };\n        Observable.prototype._isEqual = function (a, b) {\n            return lang.isEqual(a, b);\n        };\n        Observable.prototype._notify = function (property, newValue, oldValue) {\n            var callbacks = this._callbacks[property];\n            if (!callbacks || !callbacks.length) {\n                return;\n            }\n            var notification = this._notifications[property];\n            if (notification) {\n                notification.newValue = newValue;\n            }\n            else {\n                this._notifications[property] = {\n                    newValue: newValue,\n                    oldValue: oldValue,\n                    callbacks: callbacks.slice(0)\n                };\n            }\n            this._schedule();\n        };\n        Observable.prototype.observe = function (property, callback) {\n            var callbackObject = {\n                callback: callback\n            };\n            if (!this._callbacks[property]) {\n                var oldDescriptor = lang.getPropertyDescriptor(this, property), currentValue = this[property], descriptor = {\n                    configurable: true,\n                    enumerable: true\n                };\n                if (oldDescriptor && !('value' in oldDescriptor)) {\n                    descriptor.get = oldDescriptor.get;\n                    if (oldDescriptor.set) {\n                        descriptor.set = function (value) {\n                            oldDescriptor.set.apply(this, arguments);\n                            var newValue = descriptor.get.call(this);\n                            this._notify(property, newValue, currentValue);\n                            currentValue = newValue;\n                        };\n                    }\n                }\n                else {\n                    descriptor.get = function () {\n                        return currentValue;\n                    };\n                    if (oldDescriptor.writable) {\n                        descriptor.set = function (newValue) {\n                            this._notify(property, newValue, currentValue);\n                            currentValue = newValue;\n                        };\n                    }\n                }\n                Object.defineProperty(this, property, descriptor);\n                this._callbacks[property] = [callbackObject];\n            }\n            else {\n                this._callbacks[property].push(callbackObject);\n            }\n            var self = this;\n            return {\n                remove: function () {\n                    this.remove = function () { };\n                    callbackObject.removed = true;\n                    lang.pullFromArray(self._callbacks[property], callbackObject);\n                }\n            };\n        };\n        Observable.prototype._schedule = function () {\n            if (!this._timer) {\n                this._timer = Scheduler.schedule(this._dispatch);\n            }\n        };\n        return Observable;\n    })();\n    return Observable;\n});\n//# sourceMappingURL=_debug/Observable.js.map","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/dojo/Scheduler.js":"(function (deps, factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define(deps, factory);\n    }\n})([\"require\", \"exports\", './CallbackQueue', './nextTick'], function (require, exports) {\n    var CallbackQueue = require('./CallbackQueue');\n    var nextTick = require('./nextTick');\n    var Scheduler = (function () {\n        function Scheduler() {\n            this._callbacks = new CallbackQueue();\n        }\n        Scheduler.schedule = function (callback) {\n            return scheduler.schedule(callback);\n        };\n        Scheduler.prototype.schedule = function (callback) {\n            var _this = this;\n            var handle = this._callbacks.add(callback);\n            nextTick(function () {\n                _this._callbacks.drain();\n            });\n            return handle;\n        };\n        return Scheduler;\n    })();\n    var scheduler = new Scheduler();\n    return Scheduler;\n});\n//# sourceMappingURL=_debug/Scheduler.js.map","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/dojo/Promise.js":"(function (deps, factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define(deps, factory);\n    }\n})([\"require\", \"exports\", './nextTick'], function (require, exports) {\n    var nextTick = require('./nextTick');\n    function isPromise(value) {\n        return value && typeof value.then === 'function';\n    }\n    function runCallbacks(callbacks) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        for (var i = 0, callback; callback = callbacks[i]; ++i) {\n            callback.apply(null, args);\n        }\n    }\n    var Promise = (function () {\n        function Promise(initializer) {\n            var state = Promise.State.PENDING;\n            Object.defineProperty(this, 'state', {\n                get: function () {\n                    return state;\n                }\n            });\n            function isResolved() {\n                return state !== Promise.State.PENDING || isChained;\n            }\n            var isChained = false;\n            var resolvedValue;\n            var callbacks = [];\n            var whenFinished = function (callback) {\n                callbacks.push(callback);\n            };\n            var progressCallbacks = [];\n            var whenProgress = function (callback) {\n                progressCallbacks.push(callback);\n            };\n            var canceler;\n            var enqueue = (function () {\n                function originalSchedule() {\n                    schedule = function () { };\n                    nextTick(function run() {\n                        try {\n                            var callback;\n                            while ((callback = queue.shift())) {\n                                callback();\n                            }\n                        }\n                        finally {\n                            if (queue.length) {\n                                run();\n                            }\n                            else {\n                                schedule = originalSchedule;\n                            }\n                        }\n                    });\n                }\n                var queue = [];\n                var schedule = originalSchedule;\n                return function (callback) {\n                    queue.push(callback);\n                    schedule();\n                };\n            })();\n            var resolve = function (newState, value) {\n                if (isResolved()) {\n                    return;\n                }\n                if (isPromise(value)) {\n                    if (value === this) {\n                        settle(Promise.State.REJECTED, new TypeError('Cannot chain a promise to itself'));\n                        return;\n                    }\n                    try {\n                        value.then(settle.bind(null, Promise.State.FULFILLED), settle.bind(null, Promise.State.REJECTED));\n                        isChained = true;\n                        canceler = value.cancel;\n                    }\n                    catch (error) {\n                        settle(Promise.State.REJECTED, error);\n                        return;\n                    }\n                }\n                else {\n                    settle(newState, value);\n                }\n            }.bind(this);\n            function settle(newState, value) {\n                if (state !== Promise.State.PENDING) {\n                    return;\n                }\n                state = newState;\n                resolvedValue = value;\n                whenFinished = enqueue;\n                whenProgress = function () { };\n                enqueue(function () {\n                    runCallbacks(callbacks);\n                    callbacks = progressCallbacks = null;\n                });\n            }\n            this.cancel = function (reason) {\n                if (state !== Promise.State.PENDING) {\n                    return;\n                }\n                if (!reason) {\n                    reason = new Error('Cancelled');\n                    reason.name = 'CancelError';\n                }\n                if (!canceler) {\n                    settle(Promise.State.REJECTED, reason);\n                    return Promise.reject(reason);\n                }\n                try {\n                    resolve(Promise.State.FULFILLED, canceler(reason));\n                }\n                catch (error) {\n                    settle(Promise.State.REJECTED, error);\n                    return Promise.reject(error);\n                }\n            };\n            this.then = function (onFulfilled, onRejected, onProgress) {\n                return new Promise(function (resolve, reject, progress, setCanceler) {\n                    setCanceler(function (reason) {\n                        if (canceler) {\n                            resolve(canceler(reason));\n                        }\n                        else {\n                            throw reason;\n                        }\n                    });\n                    whenProgress(function (data) {\n                        try {\n                            if (typeof onProgress === 'function') {\n                                progress(onProgress(data));\n                            }\n                            else {\n                                progress(data);\n                            }\n                        }\n                        catch (error) {\n                            if (error.name !== 'StopProgressPropagation') {\n                                throw error;\n                            }\n                        }\n                    });\n                    whenFinished(function () {\n                        var callback = state === Promise.State.REJECTED ? onRejected : onFulfilled;\n                        if (typeof callback === 'function') {\n                            try {\n                                resolve(callback(resolvedValue));\n                            }\n                            catch (error) {\n                                reject(error);\n                            }\n                        }\n                        else if (state === Promise.State.REJECTED) {\n                            reject(resolvedValue);\n                        }\n                        else {\n                            resolve(resolvedValue);\n                        }\n                    });\n                });\n            };\n            try {\n                initializer(resolve.bind(null, Promise.State.FULFILLED), resolve.bind(null, Promise.State.REJECTED), function (data) {\n                    if (state === Promise.State.PENDING) {\n                        enqueue(runCallbacks.bind(null, progressCallbacks, data));\n                    }\n                }, function (value) {\n                    if (!isResolved()) {\n                        canceler = value;\n                    }\n                });\n            }\n            catch (error) {\n                settle(Promise.State.REJECTED, error);\n            }\n        }\n        Promise.all = function (iterable) {\n            return new this(function (resolve, reject, progress, setCanceler) {\n                setCanceler(function (reason) {\n                    walkIterable(function (key, value) {\n                        if (value && value.cancel) {\n                            value.cancel(reason);\n                        }\n                    });\n                    throw reason;\n                });\n                function fulfill(key, value) {\n                    values[key] = value;\n                    progress(values);\n                    ++complete;\n                    finish();\n                }\n                function finish() {\n                    if (populating || complete < total) {\n                        return;\n                    }\n                    resolve(values);\n                }\n                function processItem(key, value) {\n                    ++total;\n                    if (isPromise(value)) {\n                        value.then(fulfill.bind(null, key), reject);\n                    }\n                    else {\n                        fulfill(key, value);\n                    }\n                }\n                function walkIterable(callback) {\n                    if (Array.isArray(iterable)) {\n                        for (var i = 0, j = iterable.length; i < j; ++i) {\n                            if (i in iterable) {\n                                callback(String(i), iterable[i]);\n                            }\n                        }\n                    }\n                    else {\n                        for (var key in iterable) {\n                            callback(key, iterable[key]);\n                        }\n                    }\n                }\n                var values = Array.isArray(iterable) ? [] : {};\n                var complete = 0;\n                var total = 0;\n                var populating = true;\n                walkIterable(processItem);\n                populating = false;\n                finish();\n            });\n        };\n        Promise.reject = function (error) {\n            return new this(function (resolve, reject) {\n                reject(error);\n            });\n        };\n        Promise.resolve = function (value) {\n            if (value instanceof Promise) {\n                return value;\n            }\n            return new this(function (resolve) {\n                resolve(value);\n            });\n        };\n        Promise.prototype.catch = function (onRejected) {\n            return this.then(null, onRejected);\n        };\n        Promise.prototype.finally = function (onFulfilledOrRejected) {\n            function getFinalValue(defaultCallback) {\n                var returnValue = onFulfilledOrRejected();\n                if (returnValue === undefined) {\n                    return defaultCallback();\n                }\n                else if (returnValue && returnValue.then) {\n                    return returnValue.then(function (returnValue) {\n                        return returnValue !== undefined ? returnValue : defaultCallback();\n                    });\n                }\n                else {\n                    return returnValue;\n                }\n            }\n            return this.then(function (value) {\n                return getFinalValue(function () {\n                    return value;\n                });\n            }, function (error) {\n                return getFinalValue(function () {\n                    throw error;\n                });\n            });\n        };\n        Promise.prototype.progress = function (onProgress) {\n            return this.then(null, null, onProgress);\n        };\n        return Promise;\n    })();\n    var Promise;\n    (function (Promise) {\n        var Deferred = (function () {\n            function Deferred(canceler) {\n                var _this = this;\n                this.promise = new Promise(function (resolve, reject, progress, setCanceler) {\n                    _this.progress = progress;\n                    _this.reject = reject;\n                    _this.resolve = resolve;\n                    canceler && setCanceler(canceler);\n                });\n            }\n            return Deferred;\n        })();\n        Promise.Deferred = Deferred;\n        (function (State) {\n            State[State[\"PENDING\"] = 0] = \"PENDING\";\n            State[State[\"FULFILLED\"] = 1] = \"FULFILLED\";\n            State[State[\"REJECTED\"] = 2] = \"REJECTED\";\n        })(Promise.State || (Promise.State = {}));\n        var State = Promise.State;\n    })(Promise || (Promise = {}));\n    return Promise;\n});\n//# sourceMappingURL=_debug/Promise.js.map","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/dojo/Registry.js":"(function (deps, factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define(deps, factory);\n    }\n})([\"require\", \"exports\", './lang'], function (require, exports) {\n    var lang = require('./lang');\n    var Registry = (function () {\n        function Registry(defaultValue) {\n            this._entries = [];\n            this._defaultValue = defaultValue;\n        }\n        Registry.prototype.match = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i - 0] = arguments[_i];\n            }\n            var entries = this._entries.slice(0);\n            var entry;\n            for (var i = 0; (entry = entries[i]); ++i) {\n                if (entry.test.apply(null, args)) {\n                    return entry.value;\n                }\n            }\n            if (this._defaultValue !== undefined) {\n                return this._defaultValue;\n            }\n            throw new Error('No match found');\n        };\n        Registry.prototype.register = function (test, value, first) {\n            var entries = this._entries;\n            var entry = {\n                test: test,\n                value: value\n            };\n            entries[first ? 'unshift' : 'push'](entry);\n            return {\n                remove: function () {\n                    this.remove = function () { };\n                    lang.pullFromArray(entries, entry);\n                    test = value = entries = entry = null;\n                }\n            };\n        };\n        return Registry;\n    })();\n    return Registry;\n});\n//# sourceMappingURL=_debug/Registry.js.map","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/dojo/request.js":"(function (deps, factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define(deps, factory);\n    }\n})([\"require\", \"exports\", \"./has!host-browser?./request/xhr:host-node?./request/node\", './has', './Promise', './Registry'], function (require, exports) {\n    var has = require('./has');\n    var Promise = require('./Promise');\n    var Registry = require('./Registry');\n    var defaultProvider;\n    if (has('host-node')) {\n        defaultProvider = require('./request/node');\n    }\n    else if (has('host-browser')) {\n        defaultProvider = require('./request/xhr');\n    }\n    var request = function (url, options) {\n        if (options === void 0) { options = {}; }\n        var args = Array.prototype.slice.call(arguments, 0);\n        var promise = request.providerRegistry.match(arguments).apply(null, arguments).then(function (response) {\n            args.unshift(response);\n            return Promise.resolve(request.filterRegistry.match(args).apply(null, args)).then(function (filterResponse) {\n                response.data = filterResponse.data;\n                return response;\n            });\n        });\n        promise.data = promise.then(function (response) {\n            return response.data;\n        });\n        return promise;\n    };\n    request.providerRegistry = new Registry(defaultProvider);\n    request.filterRegistry = new Registry(function (response) {\n        return response;\n    });\n    request.filterRegistry.register(function (response, url, options) {\n        return typeof response.data === 'string' && options.responseType === 'json';\n    }, function (response, url, options) {\n        return JSON.parse(response.data);\n    });\n    ['delete', 'get', 'post', 'put'].forEach(function (method) {\n        request[method] = function (url, options) {\n            options = Object.create(options);\n            options.method = method.toUpperCase();\n            return request(url, options);\n        };\n    });\n    return request;\n});\n//# sourceMappingURL=_debug/request.js.map","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/dojo/request/node.js":"(function (deps, factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define(deps, factory);\n    }\n})([\"require\", \"exports\", 'http', 'https', '../kernel', '../Promise', 'url'], function (require, exports) {\n    var http = require('http');\n    var https = require('https');\n    var kernel = require('../kernel');\n    var Promise = require('../Promise');\n    var urlUtil = require('url');\n    function node(url, options) {\n        if (options === void 0) { options = {}; }\n        var deferred = new Promise.Deferred(function (reason) {\n            request && request.abort();\n            throw reason;\n        });\n        var promise = deferred.promise;\n        var parsedUrl = urlUtil.parse(options.proxy || url);\n        var requestOptions = {\n            agent: options.agent,\n            auth: parsedUrl.auth || options.auth,\n            ca: options.ca,\n            cert: options.cert,\n            ciphers: options.ciphers,\n            headers: options.headers || {},\n            host: parsedUrl.host,\n            hostname: parsedUrl.hostname,\n            key: options.key,\n            localAddress: options.localAddress,\n            method: options.method ? options.method.toUpperCase() : 'GET',\n            passphrase: options.passphrase,\n            path: parsedUrl.path,\n            pfx: options.pfx,\n            port: +parsedUrl.port,\n            rejectUnauthorized: options.rejectUnauthorized,\n            secureProtocol: options.secureProtocol,\n            socketPath: options.socketPath\n        };\n        if (!('user-agent' in requestOptions.headers)) {\n            requestOptions.headers['user-agent'] = 'dojo/' + kernel.version + ' Node.js/' + process.version.replace(/^v/, '');\n        }\n        if (options.proxy) {\n            requestOptions.path = url;\n            if (parsedUrl.auth) {\n                requestOptions.headers['proxy-authorization'] = 'Basic ' + new Buffer(parsedUrl.auth).toString('base64');\n            }\n            (function () {\n                var parsedUrl = urlUtil.parse(url);\n                requestOptions.headers['host'] = parsedUrl.host;\n                requestOptions.auth = parsedUrl.auth || options.auth;\n            })();\n        }\n        if (!options.auth && (options.user || options.password)) {\n            requestOptions.auth = encodeURIComponent(options.user || '') + ':' + encodeURIComponent(options.password || '');\n        }\n        var request = (parsedUrl.protocol === 'https:' ? https : http).request(requestOptions);\n        var response = {\n            data: null,\n            getHeader: function (name) {\n                return (this.nativeResponse && this.nativeResponse.headers[name.toLowerCase()]) || null;\n            },\n            requestOptions: options,\n            statusCode: null,\n            url: url\n        };\n        if (options.socketOptions) {\n            if ('timeout' in options.socketOptions) {\n                request.setTimeout(options.socketOptions.timeout);\n            }\n            if ('noDelay' in options.socketOptions) {\n                request.setNoDelay(options.socketOptions.noDelay);\n            }\n            if ('keepAlive' in options.socketOptions) {\n                var initialDelay = options.socketOptions.keepAlive;\n                request.setSocketKeepAlive(initialDelay >= 0, initialDelay || 0);\n            }\n        }\n        request.once('response', function (nativeResponse) {\n            var data;\n            var loaded = 0;\n            var total = +nativeResponse.headers['content-length'];\n            response.nativeResponse = nativeResponse;\n            response.statusCode = nativeResponse.statusCode;\n            if (response.statusCode >= 300 && response.statusCode < 400 && response.statusCode !== 304 &&\n                options.followRedirects !== false &&\n                nativeResponse.headers.location) {\n                if (nativeResponse.headers.location === url &&\n                    (response.statusCode !== 303 || requestOptions.method === 'GET')) {\n                    deferred.reject(new Error('Redirect loop detected for URL ' + url));\n                    return;\n                }\n                deferred.progress({\n                    type: 'redirect',\n                    location: nativeResponse.headers.location,\n                    response: nativeResponse\n                });\n                deferred.resolve(node(nativeResponse.headers.location, options));\n                return;\n            }\n            if (!options.streamData) {\n                data = [];\n            }\n            options.streamEncoding && nativeResponse.setEncoding(options.streamEncoding);\n            if (options.streamTarget) {\n                nativeResponse.pipe(options.streamTarget);\n                options.streamTarget.once('error', function (error) {\n                    nativeResponse.unpipe(options.streamTarget);\n                    request.abort();\n                    error.response = response;\n                    deferred.reject(error);\n                });\n                options.streamTarget.once('close', function () {\n                    deferred.resolve(response);\n                });\n            }\n            nativeResponse.on('data', function (chunk) {\n                options.streamData || data.push(chunk);\n                loaded += typeof chunk === 'string' ? Buffer.byteLength(chunk, options.streamEncoding) : chunk.length;\n                deferred.progress({ type: 'data', chunk: chunk, loaded: loaded, total: total });\n            });\n            nativeResponse.once('end', function () {\n                timeout && timeout.remove();\n                if (!options.streamData) {\n                    response.data = options.streamEncoding ? data.join('') : Buffer.concat(data, loaded);\n                }\n                if (!options.streamTarget) {\n                    deferred.resolve(response);\n                }\n            });\n            deferred.progress({ type: 'nativeResponse', response: nativeResponse });\n        });\n        request.once('error', deferred.reject);\n        if (options.data) {\n            if (options.data.pipe) {\n                options.data.pipe(request);\n            }\n            else {\n                request.end(options.data, options.dataEncoding);\n            }\n        }\n        else {\n            request.end();\n        }\n        if (options.timeout > 0 && options.timeout !== Infinity) {\n            var timeout = (function () {\n                var timer = setTimeout(function () {\n                    var error = new Error('Request timed out after ' + options.timeout + 'ms');\n                    error.name = 'RequestTimeoutError';\n                    promise.cancel(error);\n                }, options.timeout);\n                return {\n                    remove: function () {\n                        this.remove = function () { };\n                        clearTimeout(timer);\n                    }\n                };\n            })();\n        }\n        return promise.catch(function (error) {\n            var parsedUrl = urlUtil.parse(url);\n            if (parsedUrl.auth) {\n                parsedUrl.auth = '(redacted)';\n            }\n            var sanitizedUrl = urlUtil.format(parsedUrl);\n            error.message = '[' + requestOptions.method + ' ' + sanitizedUrl + '] ' + error.message;\n            throw error;\n        });\n    }\n    return node;\n});\n//# sourceMappingURL=../_debug/request/node.js.map","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/dojo/text.js":"(function (deps, factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define(deps, factory);\n    }\n})([\"require\", \"exports\", './has'], function (require, exports) {\n    var has = require('./has');\n    var getText;\n    if (has('host-browser')) {\n        getText = function (url, callback) {\n            var xhr = new XMLHttpRequest();\n            xhr.onload = function () {\n                callback(xhr.responseText);\n            };\n            xhr.open('GET', url, true);\n            xhr.send(null);\n        };\n    }\n    else if (has('host-node')) {\n        var fs = require.nodeRequire ? require.nodeRequire('fs') : require('fs');\n        getText = function (url, callback) {\n            fs.readFile(url, { encoding: 'utf8' }, function (error, data) {\n                if (error) {\n                    throw error;\n                }\n                callback(data);\n            });\n        };\n    }\n    else {\n        getText = function () {\n            throw new Error('dojo/text not supported on this platform');\n        };\n    }\n    function load(resourceId, require, load) {\n        getText(require.toUrl(resourceId), load);\n    }\n    exports.load = load;\n});\n//# sourceMappingURL=_debug/text.js.map","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/dojo/topic.js":"(function (deps, factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define(deps, factory);\n    }\n})([\"require\", \"exports\", './Evented'], function (require, exports) {\n    var Evented = require('./Evented');\n    var hub = new Evented();\n    function subscribe(topic, listener) {\n        return hub.on.apply(hub, arguments);\n    }\n    exports.subscribe = subscribe;\n    function publish(topic) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        hub.emit.apply(hub, arguments);\n    }\n    exports.publish = publish;\n});\n//# sourceMappingURL=_debug/topic.js.map","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/add.js":"define(['./_createMathOperation'], function(createMathOperation) {\n\n  /**\n   * Adds two numbers.\n   *\n   * @static\n   * @memberOf _\n   * @since 3.4.0\n   * @category Math\n   * @param {number} augend The first number in an addition.\n   * @param {number} addend The second number in an addition.\n   * @returns {number} Returns the total.\n   * @example\n   *\n   * _.add(6, 4);\n   * // => 10\n   */\n  var add = createMathOperation(function(augend, addend) {\n    return augend + addend;\n  }, 0);\n\n  return add;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_addMapEntry.js":"define([], function() {\n\n  /**\n   * Adds the key-value `pair` to `map`.\n   *\n   * @private\n   * @param {Object} map The map to modify.\n   * @param {Array} pair The key-value pair to add.\n   * @returns {Object} Returns `map`.\n   */\n  function addMapEntry(map, pair) {\n    // Don't return `map.set` because it's not chainable in IE 11.\n    map.set(pair[0], pair[1]);\n    return map;\n  }\n\n  return addMapEntry;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_addSetEntry.js":"define([], function() {\n\n  /**\n   * Adds `value` to `set`.\n   *\n   * @private\n   * @param {Object} set The set to modify.\n   * @param {*} value The value to add.\n   * @returns {Object} Returns `set`.\n   */\n  function addSetEntry(set, value) {\n    // Don't return `set.add` because it's not chainable in IE 11.\n    set.add(value);\n    return set;\n  }\n\n  return addSetEntry;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/after.js":"define(['./toInteger'], function(toInteger) {\n\n  /** Error message constants. */\n  var FUNC_ERROR_TEXT = 'Expected a function';\n\n  /**\n   * The opposite of `_.before`; this method creates a function that invokes\n   * `func` once it's called `n` or more times.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Function\n   * @param {number} n The number of calls before `func` is invoked.\n   * @param {Function} func The function to restrict.\n   * @returns {Function} Returns the new restricted function.\n   * @example\n   *\n   * var saves = ['profile', 'settings'];\n   *\n   * var done = _.after(saves.length, function() {\n   *   console.log('done saving!');\n   * });\n   *\n   * _.forEach(saves, function(type) {\n   *   asyncSave({ 'type': type, 'complete': done });\n   * });\n   * // => Logs 'done saving!' after the two async saves have completed.\n   */\n  function after(n, func) {\n    if (typeof func != 'function') {\n      throw new TypeError(FUNC_ERROR_TEXT);\n    }\n    n = toInteger(n);\n    return function() {\n      if (--n < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  }\n\n  return after;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_apply.js":"define([], function() {\n\n  /**\n   * A faster alternative to `Function#apply`, this function invokes `func`\n   * with the `this` binding of `thisArg` and the arguments of `args`.\n   *\n   * @private\n   * @param {Function} func The function to invoke.\n   * @param {*} thisArg The `this` binding of `func`.\n   * @param {Array} args The arguments to invoke `func` with.\n   * @returns {*} Returns the result of `func`.\n   */\n  function apply(func, thisArg, args) {\n    switch (args.length) {\n      case 0: return func.call(thisArg);\n      case 1: return func.call(thisArg, args[0]);\n      case 2: return func.call(thisArg, args[0], args[1]);\n      case 3: return func.call(thisArg, args[0], args[1], args[2]);\n    }\n    return func.apply(thisArg, args);\n  }\n\n  return apply;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_arrayAggregator.js":"define([], function() {\n\n  /**\n   * A specialized version of `baseAggregator` for arrays.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} setter The function to set `accumulator` values.\n   * @param {Function} iteratee The iteratee to transform keys.\n   * @param {Object} accumulator The initial aggregated object.\n   * @returns {Function} Returns `accumulator`.\n   */\n  function arrayAggregator(array, setter, iteratee, accumulator) {\n    var index = -1,\n        length = array ? array.length : 0;\n\n    while (++index < length) {\n      var value = array[index];\n      setter(accumulator, value, iteratee(value), array);\n    }\n    return accumulator;\n  }\n\n  return arrayAggregator;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_arrayEach.js":"define([], function() {\n\n  /**\n   * A specialized version of `_.forEach` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayEach(array, iteratee) {\n    var index = -1,\n        length = array ? array.length : 0;\n\n    while (++index < length) {\n      if (iteratee(array[index], index, array) === false) {\n        break;\n      }\n    }\n    return array;\n  }\n\n  return arrayEach;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_arrayEachRight.js":"define([], function() {\n\n  /**\n   * A specialized version of `_.forEachRight` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayEachRight(array, iteratee) {\n    var length = array ? array.length : 0;\n\n    while (length--) {\n      if (iteratee(array[length], length, array) === false) {\n        break;\n      }\n    }\n    return array;\n  }\n\n  return arrayEachRight;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_arrayEvery.js":"define([], function() {\n\n  /**\n   * A specialized version of `_.every` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {boolean} Returns `true` if all elements pass the predicate check,\n   *  else `false`.\n   */\n  function arrayEvery(array, predicate) {\n    var index = -1,\n        length = array ? array.length : 0;\n\n    while (++index < length) {\n      if (!predicate(array[index], index, array)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  return arrayEvery;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_arrayFilter.js":"define([], function() {\n\n  /**\n   * A specialized version of `_.filter` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {Array} Returns the new filtered array.\n   */\n  function arrayFilter(array, predicate) {\n    var index = -1,\n        length = array ? array.length : 0,\n        resIndex = 0,\n        result = [];\n\n    while (++index < length) {\n      var value = array[index];\n      if (predicate(value, index, array)) {\n        result[resIndex++] = value;\n      }\n    }\n    return result;\n  }\n\n  return arrayFilter;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_arrayIncludes.js":"define(['./_baseIndexOf'], function(baseIndexOf) {\n\n  /**\n   * A specialized version of `_.includes` for arrays without support for\n   * specifying an index to search from.\n   *\n   * @private\n   * @param {Array} [array] The array to inspect.\n   * @param {*} target The value to search for.\n   * @returns {boolean} Returns `true` if `target` is found, else `false`.\n   */\n  function arrayIncludes(array, value) {\n    var length = array ? array.length : 0;\n    return !!length && baseIndexOf(array, value, 0) > -1;\n  }\n\n  return arrayIncludes;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_arrayIncludesWith.js":"define([], function() {\n\n  /**\n   * This function is like `arrayIncludes` except that it accepts a comparator.\n   *\n   * @private\n   * @param {Array} [array] The array to inspect.\n   * @param {*} target The value to search for.\n   * @param {Function} comparator The comparator invoked per element.\n   * @returns {boolean} Returns `true` if `target` is found, else `false`.\n   */\n  function arrayIncludesWith(array, value, comparator) {\n    var index = -1,\n        length = array ? array.length : 0;\n\n    while (++index < length) {\n      if (comparator(value, array[index])) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  return arrayIncludesWith;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/array.js":"define(['./chunk', './compact', './concat', './difference', './differenceBy', './differenceWith', './drop', './dropRight', './dropRightWhile', './dropWhile', './fill', './findIndex', './findLastIndex', './first', './flatten', './flattenDeep', './flattenDepth', './fromPairs', './head', './indexOf', './initial', './intersection', './intersectionBy', './intersectionWith', './join', './last', './lastIndexOf', './nth', './pull', './pullAll', './pullAllBy', './pullAllWith', './pullAt', './remove', './reverse', './slice', './sortedIndex', './sortedIndexBy', './sortedIndexOf', './sortedLastIndex', './sortedLastIndexBy', './sortedLastIndexOf', './sortedUniq', './sortedUniqBy', './tail', './take', './takeRight', './takeRightWhile', './takeWhile', './union', './unionBy', './unionWith', './uniq', './uniqBy', './uniqWith', './unzip', './unzipWith', './without', './xor', './xorBy', './xorWith', './zip', './zipObject', './zipObjectDeep', './zipWith'], function(chunk, compact, concat, difference, differenceBy, differenceWith, drop, dropRight, dropRightWhile, dropWhile, fill, findIndex, findLastIndex, first, flatten, flattenDeep, flattenDepth, fromPairs, head, indexOf, initial, intersection, intersectionBy, intersectionWith, join, last, lastIndexOf, nth, pull, pullAll, pullAllBy, pullAllWith, pullAt, remove, reverse, slice, sortedIndex, sortedIndexBy, sortedIndexOf, sortedLastIndex, sortedLastIndexBy, sortedLastIndexOf, sortedUniq, sortedUniqBy, tail, take, takeRight, takeRightWhile, takeWhile, union, unionBy, unionWith, uniq, uniqBy, uniqWith, unzip, unzipWith, without, xor, xorBy, xorWith, zip, zipObject, zipObjectDeep, zipWith) {\n  return {\n    'chunk': chunk,\n    'compact': compact,\n    'concat': concat,\n    'difference': difference,\n    'differenceBy': differenceBy,\n    'differenceWith': differenceWith,\n    'drop': drop,\n    'dropRight': dropRight,\n    'dropRightWhile': dropRightWhile,\n    'dropWhile': dropWhile,\n    'fill': fill,\n    'findIndex': findIndex,\n    'findLastIndex': findLastIndex,\n    'first': first,\n    'flatten': flatten,\n    'flattenDeep': flattenDeep,\n    'flattenDepth': flattenDepth,\n    'fromPairs': fromPairs,\n    'head': head,\n    'indexOf': indexOf,\n    'initial': initial,\n    'intersection': intersection,\n    'intersectionBy': intersectionBy,\n    'intersectionWith': intersectionWith,\n    'join': join,\n    'last': last,\n    'lastIndexOf': lastIndexOf,\n    'nth': nth,\n    'pull': pull,\n    'pullAll': pullAll,\n    'pullAllBy': pullAllBy,\n    'pullAllWith': pullAllWith,\n    'pullAt': pullAt,\n    'remove': remove,\n    'reverse': reverse,\n    'slice': slice,\n    'sortedIndex': sortedIndex,\n    'sortedIndexBy': sortedIndexBy,\n    'sortedIndexOf': sortedIndexOf,\n    'sortedLastIndex': sortedLastIndex,\n    'sortedLastIndexBy': sortedLastIndexBy,\n    'sortedLastIndexOf': sortedLastIndexOf,\n    'sortedUniq': sortedUniq,\n    'sortedUniqBy': sortedUniqBy,\n    'tail': tail,\n    'take': take,\n    'takeRight': takeRight,\n    'takeRightWhile': takeRightWhile,\n    'takeWhile': takeWhile,\n    'union': union,\n    'unionBy': unionBy,\n    'unionWith': unionWith,\n    'uniq': uniq,\n    'uniqBy': uniqBy,\n    'uniqWith': uniqWith,\n    'unzip': unzip,\n    'unzipWith': unzipWith,\n    'without': without,\n    'xor': xor,\n    'xorBy': xorBy,\n    'xorWith': xorWith,\n    'zip': zip,\n    'zipObject': zipObject,\n    'zipObjectDeep': zipObjectDeep,\n    'zipWith': zipWith\n  };\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_arrayLikeKeys.js":"define(['./_baseTimes', './isArguments', './isArray', './isBuffer', './_isIndex', './isTypedArray'], function(baseTimes, isArguments, isArray, isBuffer, isIndex, isTypedArray) {\n\n  /** Used for built-in method references. */\n  var objectProto = Object.prototype;\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty = objectProto.hasOwnProperty;\n\n  /**\n   * Creates an array of the enumerable property names of the array-like `value`.\n   *\n   * @private\n   * @param {*} value The value to query.\n   * @param {boolean} inherited Specify returning inherited property names.\n   * @returns {Array} Returns the array of property names.\n   */\n  function arrayLikeKeys(value, inherited) {\n    var isArr = isArray(value),\n        isArg = !isArr && isArguments(value),\n        isBuff = !isArr && !isArg && isBuffer(value),\n        isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n        skipIndexes = isArr || isArg || isBuff || isType,\n        result = skipIndexes ? baseTimes(value.length, String) : [],\n        length = result.length;\n\n    for (var key in value) {\n      if ((inherited || hasOwnProperty.call(value, key)) &&\n          !(skipIndexes && (\n             // Safari 9 has enumerable `arguments.length` in strict mode.\n             key == 'length' ||\n             // Node.js 0.10 has enumerable non-index properties on buffers.\n             (isBuff && (key == 'offset' || key == 'parent')) ||\n             // PhantomJS 2 has enumerable non-index properties on typed arrays.\n             (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n             // Skip index properties.\n             isIndex(key, length)\n          ))) {\n        result.push(key);\n      }\n    }\n    return result;\n  }\n\n  return arrayLikeKeys;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_arrayMap.js":"define([], function() {\n\n  /**\n   * A specialized version of `_.map` for arrays without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the new mapped array.\n   */\n  function arrayMap(array, iteratee) {\n    var index = -1,\n        length = array ? array.length : 0,\n        result = Array(length);\n\n    while (++index < length) {\n      result[index] = iteratee(array[index], index, array);\n    }\n    return result;\n  }\n\n  return arrayMap;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_arrayPush.js":"define([], function() {\n\n  /**\n   * Appends the elements of `values` to `array`.\n   *\n   * @private\n   * @param {Array} array The array to modify.\n   * @param {Array} values The values to append.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayPush(array, values) {\n    var index = -1,\n        length = values.length,\n        offset = array.length;\n\n    while (++index < length) {\n      array[offset + index] = values[index];\n    }\n    return array;\n  }\n\n  return arrayPush;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_arrayReduce.js":"define([], function() {\n\n  /**\n   * A specialized version of `_.reduce` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} [accumulator] The initial value.\n   * @param {boolean} [initAccum] Specify using the first element of `array` as\n   *  the initial value.\n   * @returns {*} Returns the accumulated value.\n   */\n  function arrayReduce(array, iteratee, accumulator, initAccum) {\n    var index = -1,\n        length = array ? array.length : 0;\n\n    if (initAccum && length) {\n      accumulator = array[++index];\n    }\n    while (++index < length) {\n      accumulator = iteratee(accumulator, array[index], index, array);\n    }\n    return accumulator;\n  }\n\n  return arrayReduce;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_arrayReduceRight.js":"define([], function() {\n\n  /**\n   * A specialized version of `_.reduceRight` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} [accumulator] The initial value.\n   * @param {boolean} [initAccum] Specify using the last element of `array` as\n   *  the initial value.\n   * @returns {*} Returns the accumulated value.\n   */\n  function arrayReduceRight(array, iteratee, accumulator, initAccum) {\n    var length = array ? array.length : 0;\n    if (initAccum && length) {\n      accumulator = array[--length];\n    }\n    while (length--) {\n      accumulator = iteratee(accumulator, array[length], length, array);\n    }\n    return accumulator;\n  }\n\n  return arrayReduceRight;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_arraySample.js":"define(['./_baseRandom'], function(baseRandom) {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /**\n   * A specialized version of `_.sample` for arrays.\n   *\n   * @private\n   * @param {Array} array The array to sample.\n   * @returns {*} Returns the random element.\n   */\n  function arraySample(array) {\n    var length = array.length;\n    return length ? array[baseRandom(0, length - 1)] : undefined;\n  }\n\n  return arraySample;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_arraySampleSize.js":"define(['./_baseClamp', './_copyArray', './_shuffleSelf'], function(baseClamp, copyArray, shuffleSelf) {\n\n  /**\n   * A specialized version of `_.sampleSize` for arrays.\n   *\n   * @private\n   * @param {Array} array The array to sample.\n   * @param {number} n The number of elements to sample.\n   * @returns {Array} Returns the random elements.\n   */\n  function arraySampleSize(array, n) {\n    return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));\n  }\n\n  return arraySampleSize;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_arrayShuffle.js":"define(['./_copyArray', './_shuffleSelf'], function(copyArray, shuffleSelf) {\n\n  /**\n   * A specialized version of `_.shuffle` for arrays.\n   *\n   * @private\n   * @param {Array} array The array to shuffle.\n   * @returns {Array} Returns the new shuffled array.\n   */\n  function arrayShuffle(array) {\n    return shuffleSelf(copyArray(array));\n  }\n\n  return arrayShuffle;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_arraySome.js":"define([], function() {\n\n  /**\n   * A specialized version of `_.some` for arrays without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {boolean} Returns `true` if any element passes the predicate check,\n   *  else `false`.\n   */\n  function arraySome(array, predicate) {\n    var index = -1,\n        length = array ? array.length : 0;\n\n    while (++index < length) {\n      if (predicate(array[index], index, array)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  return arraySome;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/ary.js":"define(['./_createWrap'], function(createWrap) {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /** Used to compose bitmasks for function metadata. */\n  var ARY_FLAG = 128;\n\n  /**\n   * Creates a function that invokes `func`, with up to `n` arguments,\n   * ignoring any additional arguments.\n   *\n   * @static\n   * @memberOf _\n   * @since 3.0.0\n   * @category Function\n   * @param {Function} func The function to cap arguments for.\n   * @param {number} [n=func.length] The arity cap.\n   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n   * @returns {Function} Returns the new capped function.\n   * @example\n   *\n   * _.map(['6', '8', '10'], _.ary(parseInt, 1));\n   * // => [6, 8, 10]\n   */\n  function ary(func, n, guard) {\n    n = guard ? undefined : n;\n    n = (func && n == null) ? func.length : n;\n    return createWrap(func, ARY_FLAG, undefined, undefined, undefined, undefined, n);\n  }\n\n  return ary;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_asciiSize.js":"define(['./_baseProperty'], function(baseProperty) {\n\n  /**\n   * Gets the size of an ASCII `string`.\n   *\n   * @private\n   * @param {string} string The string inspect.\n   * @returns {number} Returns the string size.\n   */\n  var asciiSize = baseProperty('length');\n\n  return asciiSize;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_asciiToArray.js":"define([], function() {\n\n  /**\n   * Converts an ASCII `string` to an array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function asciiToArray(string) {\n    return string.split('');\n  }\n\n  return asciiToArray;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_asciiWords.js":"define([], function() {\n\n  /** Used to match words composed of alphanumeric characters. */\n  var reAsciiWord = /[^\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\x7f]+/g;\n\n  /**\n   * Splits an ASCII `string` into an array of its words.\n   *\n   * @private\n   * @param {string} The string to inspect.\n   * @returns {Array} Returns the words of `string`.\n   */\n  function asciiWords(string) {\n    return string.match(reAsciiWord) || [];\n  }\n\n  return asciiWords;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_assignInDefaults.js":"define(['./eq'], function(eq) {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /** Used for built-in method references. */\n  var objectProto = Object.prototype;\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty = objectProto.hasOwnProperty;\n\n  /**\n   * Used by `_.defaults` to customize its `_.assignIn` use.\n   *\n   * @private\n   * @param {*} objValue The destination value.\n   * @param {*} srcValue The source value.\n   * @param {string} key The key of the property to assign.\n   * @param {Object} object The parent object of `objValue`.\n   * @returns {*} Returns the value to assign.\n   */\n  function assignInDefaults(objValue, srcValue, key, object) {\n    if (objValue === undefined ||\n        (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {\n      return srcValue;\n    }\n    return objValue;\n  }\n\n  return assignInDefaults;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/assignIn.js":"define(['./_copyObject', './_createAssigner', './keysIn'], function(copyObject, createAssigner, keysIn) {\n\n  /**\n   * This method is like `_.assign` except that it iterates over own and\n   * inherited source properties.\n   *\n   * **Note:** This method mutates `object`.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @alias extend\n   * @category Object\n   * @param {Object} object The destination object.\n   * @param {...Object} [sources] The source objects.\n   * @returns {Object} Returns `object`.\n   * @see _.assign\n   * @example\n   *\n   * function Foo() {\n   *   this.a = 1;\n   * }\n   *\n   * function Bar() {\n   *   this.c = 3;\n   * }\n   *\n   * Foo.prototype.b = 2;\n   * Bar.prototype.d = 4;\n   *\n   * _.assignIn({ 'a': 0 }, new Foo, new Bar);\n   * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }\n   */\n  var assignIn = createAssigner(function(object, source) {\n    copyObject(source, keysIn(source), object);\n  });\n\n  return assignIn;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/assignInWith.js":"define(['./_copyObject', './_createAssigner', './keysIn'], function(copyObject, createAssigner, keysIn) {\n\n  /**\n   * This method is like `_.assignIn` except that it accepts `customizer`\n   * which is invoked to produce the assigned values. If `customizer` returns\n   * `undefined`, assignment is handled by the method instead. The `customizer`\n   * is invoked with five arguments: (objValue, srcValue, key, object, source).\n   *\n   * **Note:** This method mutates `object`.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @alias extendWith\n   * @category Object\n   * @param {Object} object The destination object.\n   * @param {...Object} sources The source objects.\n   * @param {Function} [customizer] The function to customize assigned values.\n   * @returns {Object} Returns `object`.\n   * @see _.assignWith\n   * @example\n   *\n   * function customizer(objValue, srcValue) {\n   *   return _.isUndefined(objValue) ? srcValue : objValue;\n   * }\n   *\n   * var defaults = _.partialRight(_.assignInWith, customizer);\n   *\n   * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n   * // => { 'a': 1, 'b': 2 }\n   */\n  var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {\n    copyObject(source, keysIn(source), object, customizer);\n  });\n\n  return assignInWith;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/assign.js":"define(['./_assignValue', './_copyObject', './_createAssigner', './isArrayLike', './_isPrototype', './keys'], function(assignValue, copyObject, createAssigner, isArrayLike, isPrototype, keys) {\n\n  /** Used for built-in method references. */\n  var objectProto = Object.prototype;\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty = objectProto.hasOwnProperty;\n\n  /**\n   * Assigns own enumerable string keyed properties of source objects to the\n   * destination object. Source objects are applied from left to right.\n   * Subsequent sources overwrite property assignments of previous sources.\n   *\n   * **Note:** This method mutates `object` and is loosely based on\n   * [`Object.assign`](https://mdn.io/Object/assign).\n   *\n   * @static\n   * @memberOf _\n   * @since 0.10.0\n   * @category Object\n   * @param {Object} object The destination object.\n   * @param {...Object} [sources] The source objects.\n   * @returns {Object} Returns `object`.\n   * @see _.assignIn\n   * @example\n   *\n   * function Foo() {\n   *   this.a = 1;\n   * }\n   *\n   * function Bar() {\n   *   this.c = 3;\n   * }\n   *\n   * Foo.prototype.b = 2;\n   * Bar.prototype.d = 4;\n   *\n   * _.assign({ 'a': 0 }, new Foo, new Bar);\n   * // => { 'a': 1, 'c': 3 }\n   */\n  var assign = createAssigner(function(object, source) {\n    if (isPrototype(source) || isArrayLike(source)) {\n      copyObject(source, keys(source), object);\n      return;\n    }\n    for (var key in source) {\n      if (hasOwnProperty.call(source, key)) {\n        assignValue(object, key, source[key]);\n      }\n    }\n  });\n\n  return assign;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_assignMergeValue.js":"define(['./_baseAssignValue', './eq'], function(baseAssignValue, eq) {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /**\n   * This function is like `assignValue` except that it doesn't assign\n   * `undefined` values.\n   *\n   * @private\n   * @param {Object} object The object to modify.\n   * @param {string} key The key of the property to assign.\n   * @param {*} value The value to assign.\n   */\n  function assignMergeValue(object, key, value) {\n    if ((value !== undefined && !eq(object[key], value)) ||\n        (value === undefined && !(key in object))) {\n      baseAssignValue(object, key, value);\n    }\n  }\n\n  return assignMergeValue;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_assignValue.js":"define(['./_baseAssignValue', './eq'], function(baseAssignValue, eq) {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /** Used for built-in method references. */\n  var objectProto = Object.prototype;\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty = objectProto.hasOwnProperty;\n\n  /**\n   * Assigns `value` to `key` of `object` if the existing value is not equivalent\n   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n   * for equality comparisons.\n   *\n   * @private\n   * @param {Object} object The object to modify.\n   * @param {string} key The key of the property to assign.\n   * @param {*} value The value to assign.\n   */\n  function assignValue(object, key, value) {\n    var objValue = object[key];\n    if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n        (value === undefined && !(key in object))) {\n      baseAssignValue(object, key, value);\n    }\n  }\n\n  return assignValue;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/assignWith.js":"define(['./_copyObject', './_createAssigner', './keys'], function(copyObject, createAssigner, keys) {\n\n  /**\n   * This method is like `_.assign` except that it accepts `customizer`\n   * which is invoked to produce the assigned values. If `customizer` returns\n   * `undefined`, assignment is handled by the method instead. The `customizer`\n   * is invoked with five arguments: (objValue, srcValue, key, object, source).\n   *\n   * **Note:** This method mutates `object`.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Object\n   * @param {Object} object The destination object.\n   * @param {...Object} sources The source objects.\n   * @param {Function} [customizer] The function to customize assigned values.\n   * @returns {Object} Returns `object`.\n   * @see _.assignInWith\n   * @example\n   *\n   * function customizer(objValue, srcValue) {\n   *   return _.isUndefined(objValue) ? srcValue : objValue;\n   * }\n   *\n   * var defaults = _.partialRight(_.assignWith, customizer);\n   *\n   * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n   * // => { 'a': 1, 'b': 2 }\n   */\n  var assignWith = createAssigner(function(object, source, srcIndex, customizer) {\n    copyObject(source, keys(source), object, customizer);\n  });\n\n  return assignWith;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_assocIndexOf.js":"define(['./eq'], function(eq) {\n\n  /**\n   * Gets the index at which the `key` is found in `array` of key-value pairs.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} key The key to search for.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function assocIndexOf(array, key) {\n    var length = array.length;\n    while (length--) {\n      if (eq(array[length][0], key)) {\n        return length;\n      }\n    }\n    return -1;\n  }\n\n  return assocIndexOf;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/at.js":"define(['./_baseAt', './_flatRest'], function(baseAt, flatRest) {\n\n  /**\n   * Creates an array of values corresponding to `paths` of `object`.\n   *\n   * @static\n   * @memberOf _\n   * @since 1.0.0\n   * @category Object\n   * @param {Object} object The object to iterate over.\n   * @param {...(string|string[])} [paths] The property paths of elements to pick.\n   * @returns {Array} Returns the picked values.\n   * @example\n   *\n   * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };\n   *\n   * _.at(object, ['a[0].b.c', 'a[1]']);\n   * // => [3, 4]\n   */\n  var at = flatRest(baseAt);\n\n  return at;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/attempt.js":"define(['./_apply', './_baseRest', './isError'], function(apply, baseRest, isError) {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /**\n   * Attempts to invoke `func`, returning either the result or the caught error\n   * object. Any additional arguments are provided to `func` when it's invoked.\n   *\n   * @static\n   * @memberOf _\n   * @since 3.0.0\n   * @category Util\n   * @param {Function} func The function to attempt.\n   * @param {...*} [args] The arguments to invoke `func` with.\n   * @returns {*} Returns the `func` result or error object.\n   * @example\n   *\n   * // Avoid throwing errors for invalid selectors.\n   * var elements = _.attempt(function(selector) {\n   *   return document.querySelectorAll(selector);\n   * }, '>_>');\n   *\n   * if (_.isError(elements)) {\n   *   elements = [];\n   * }\n   */\n  var attempt = baseRest(function(func, args) {\n    try {\n      return apply(func, undefined, args);\n    } catch (e) {\n      return isError(e) ? e : new Error(e);\n    }\n  });\n\n  return attempt;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseAggregator.js":"define(['./_baseEach'], function(baseEach) {\n\n  /**\n   * Aggregates elements of `collection` on `accumulator` with keys transformed\n   * by `iteratee` and values set by `setter`.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} setter The function to set `accumulator` values.\n   * @param {Function} iteratee The iteratee to transform keys.\n   * @param {Object} accumulator The initial aggregated object.\n   * @returns {Function} Returns `accumulator`.\n   */\n  function baseAggregator(collection, setter, iteratee, accumulator) {\n    baseEach(collection, function(value, key, collection) {\n      setter(accumulator, value, iteratee(value), collection);\n    });\n    return accumulator;\n  }\n\n  return baseAggregator;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseAssign.js":"define(['./_copyObject', './keys'], function(copyObject, keys) {\n\n  /**\n   * The base implementation of `_.assign` without support for multiple sources\n   * or `customizer` functions.\n   *\n   * @private\n   * @param {Object} object The destination object.\n   * @param {Object} source The source object.\n   * @returns {Object} Returns `object`.\n   */\n  function baseAssign(object, source) {\n    return object && copyObject(source, keys(source), object);\n  }\n\n  return baseAssign;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseAssignValue.js":"define(['./_defineProperty'], function(defineProperty) {\n\n  /**\n   * The base implementation of `assignValue` and `assignMergeValue` without\n   * value checks.\n   *\n   * @private\n   * @param {Object} object The object to modify.\n   * @param {string} key The key of the property to assign.\n   * @param {*} value The value to assign.\n   */\n  function baseAssignValue(object, key, value) {\n    if (key == '__proto__' && defineProperty) {\n      defineProperty(object, key, {\n        'configurable': true,\n        'enumerable': true,\n        'value': value,\n        'writable': true\n      });\n    } else {\n      object[key] = value;\n    }\n  }\n\n  return baseAssignValue;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseAt.js":"define(['./get'], function(get) {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /**\n   * The base implementation of `_.at` without support for individual paths.\n   *\n   * @private\n   * @param {Object} object The object to iterate over.\n   * @param {string[]} paths The property paths of elements to pick.\n   * @returns {Array} Returns the picked elements.\n   */\n  function baseAt(object, paths) {\n    var index = -1,\n        isNil = object == null,\n        length = paths.length,\n        result = Array(length);\n\n    while (++index < length) {\n      result[index] = isNil ? undefined : get(object, paths[index]);\n    }\n    return result;\n  }\n\n  return baseAt;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseClamp.js":"define([], function() {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /**\n   * The base implementation of `_.clamp` which doesn't coerce arguments.\n   *\n   * @private\n   * @param {number} number The number to clamp.\n   * @param {number} [lower] The lower bound.\n   * @param {number} upper The upper bound.\n   * @returns {number} Returns the clamped number.\n   */\n  function baseClamp(number, lower, upper) {\n    if (number === number) {\n      if (upper !== undefined) {\n        number = number <= upper ? number : upper;\n      }\n      if (lower !== undefined) {\n        number = number >= lower ? number : lower;\n      }\n    }\n    return number;\n  }\n\n  return baseClamp;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseClone.js":"define(['./_Stack', './_arrayEach', './_assignValue', './_baseAssign', './_cloneBuffer', './_copyArray', './_copySymbols', './_getAllKeys', './_getTag', './_initCloneArray', './_initCloneByTag', './_initCloneObject', './isArray', './isBuffer', './isObject', './keys'], function(Stack, arrayEach, assignValue, baseAssign, cloneBuffer, copyArray, copySymbols, getAllKeys, getTag, initCloneArray, initCloneByTag, initCloneObject, isArray, isBuffer, isObject, keys) {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /** `Object#toString` result references. */\n  var argsTag = '[object Arguments]',\n      arrayTag = '[object Array]',\n      boolTag = '[object Boolean]',\n      dateTag = '[object Date]',\n      errorTag = '[object Error]',\n      funcTag = '[object Function]',\n      genTag = '[object GeneratorFunction]',\n      mapTag = '[object Map]',\n      numberTag = '[object Number]',\n      objectTag = '[object Object]',\n      regexpTag = '[object RegExp]',\n      setTag = '[object Set]',\n      stringTag = '[object String]',\n      symbolTag = '[object Symbol]',\n      weakMapTag = '[object WeakMap]';\n\n  var arrayBufferTag = '[object ArrayBuffer]',\n      dataViewTag = '[object DataView]',\n      float32Tag = '[object Float32Array]',\n      float64Tag = '[object Float64Array]',\n      int8Tag = '[object Int8Array]',\n      int16Tag = '[object Int16Array]',\n      int32Tag = '[object Int32Array]',\n      uint8Tag = '[object Uint8Array]',\n      uint8ClampedTag = '[object Uint8ClampedArray]',\n      uint16Tag = '[object Uint16Array]',\n      uint32Tag = '[object Uint32Array]';\n\n  /** Used to identify `toStringTag` values supported by `_.clone`. */\n  var cloneableTags = {};\n  cloneableTags[argsTag] = cloneableTags[arrayTag] =\n  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\n  cloneableTags[boolTag] = cloneableTags[dateTag] =\n  cloneableTags[float32Tag] = cloneableTags[float64Tag] =\n  cloneableTags[int8Tag] = cloneableTags[int16Tag] =\n  cloneableTags[int32Tag] = cloneableTags[mapTag] =\n  cloneableTags[numberTag] = cloneableTags[objectTag] =\n  cloneableTags[regexpTag] = cloneableTags[setTag] =\n  cloneableTags[stringTag] = cloneableTags[symbolTag] =\n  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\n  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\n  cloneableTags[errorTag] = cloneableTags[funcTag] =\n  cloneableTags[weakMapTag] = false;\n\n  /**\n   * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n   * traversed objects.\n   *\n   * @private\n   * @param {*} value The value to clone.\n   * @param {boolean} [isDeep] Specify a deep clone.\n   * @param {boolean} [isFull] Specify a clone including symbols.\n   * @param {Function} [customizer] The function to customize cloning.\n   * @param {string} [key] The key of `value`.\n   * @param {Object} [object] The parent object of `value`.\n   * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n   * @returns {*} Returns the cloned value.\n   */\n  function baseClone(value, isDeep, isFull, customizer, key, object, stack) {\n    var result;\n    if (customizer) {\n      result = object ? customizer(value, key, object, stack) : customizer(value);\n    }\n    if (result !== undefined) {\n      return result;\n    }\n    if (!isObject(value)) {\n      return value;\n    }\n    var isArr = isArray(value);\n    if (isArr) {\n      result = initCloneArray(value);\n      if (!isDeep) {\n        return copyArray(value, result);\n      }\n    } else {\n      var tag = getTag(value),\n          isFunc = tag == funcTag || tag == genTag;\n\n      if (isBuffer(value)) {\n        return cloneBuffer(value, isDeep);\n      }\n      if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n        result = initCloneObject(isFunc ? {} : value);\n        if (!isDeep) {\n          return copySymbols(value, baseAssign(result, value));\n        }\n      } else {\n        if (!cloneableTags[tag]) {\n          return object ? value : {};\n        }\n        result = initCloneByTag(value, tag, baseClone, isDeep);\n      }\n    }\n    // Check for circular references and return its corresponding clone.\n    stack || (stack = new Stack);\n    var stacked = stack.get(value);\n    if (stacked) {\n      return stacked;\n    }\n    stack.set(value, result);\n\n    var props = isArr ? undefined : (isFull ? getAllKeys : keys)(value);\n    arrayEach(props || value, function(subValue, key) {\n      if (props) {\n        key = subValue;\n        subValue = value[key];\n      }\n      // Recursively populate clone (susceptible to call stack limits).\n      assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));\n    });\n    return result;\n  }\n\n  return baseClone;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseConforms.js":"define(['./_baseConformsTo', './keys'], function(baseConformsTo, keys) {\n\n  /**\n   * The base implementation of `_.conforms` which doesn't clone `source`.\n   *\n   * @private\n   * @param {Object} source The object of property predicates to conform to.\n   * @returns {Function} Returns the new spec function.\n   */\n  function baseConforms(source) {\n    var props = keys(source);\n    return function(object) {\n      return baseConformsTo(object, source, props);\n    };\n  }\n\n  return baseConforms;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseConformsTo.js":"define([], function() {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /**\n   * The base implementation of `_.conformsTo` which accepts `props` to check.\n   *\n   * @private\n   * @param {Object} object The object to inspect.\n   * @param {Object} source The object of property predicates to conform to.\n   * @returns {boolean} Returns `true` if `object` conforms, else `false`.\n   */\n  function baseConformsTo(object, source, props) {\n    var length = props.length;\n    if (object == null) {\n      return !length;\n    }\n    object = Object(object);\n    while (length--) {\n      var key = props[length],\n          predicate = source[key],\n          value = object[key];\n\n      if ((value === undefined && !(key in object)) || !predicate(value)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  return baseConformsTo;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseCreate.js":"define(['./isObject'], function(isObject) {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /** Built-in value references. */\n  var objectCreate = Object.create;\n\n  /**\n   * The base implementation of `_.create` without support for assigning\n   * properties to the created object.\n   *\n   * @private\n   * @param {Object} proto The object to inherit from.\n   * @returns {Object} Returns the new object.\n   */\n  var baseCreate = (function() {\n    function object() {}\n    return function(proto) {\n      if (!isObject(proto)) {\n        return {};\n      }\n      if (objectCreate) {\n        return objectCreate(proto);\n      }\n      object.prototype = proto;\n      var result = new object;\n      object.prototype = undefined;\n      return result;\n    };\n  }());\n\n  return baseCreate;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseDelay.js":"define([], function() {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /** Error message constants. */\n  var FUNC_ERROR_TEXT = 'Expected a function';\n\n  /**\n   * The base implementation of `_.delay` and `_.defer` which accepts `args`\n   * to provide to `func`.\n   *\n   * @private\n   * @param {Function} func The function to delay.\n   * @param {number} wait The number of milliseconds to delay invocation.\n   * @param {Array} args The arguments to provide to `func`.\n   * @returns {number|Object} Returns the timer id or timeout object.\n   */\n  function baseDelay(func, wait, args) {\n    if (typeof func != 'function') {\n      throw new TypeError(FUNC_ERROR_TEXT);\n    }\n    return setTimeout(function() { func.apply(undefined, args); }, wait);\n  }\n\n  return baseDelay;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseDifference.js":"define(['./_SetCache', './_arrayIncludes', './_arrayIncludesWith', './_arrayMap', './_baseUnary', './_cacheHas'], function(SetCache, arrayIncludes, arrayIncludesWith, arrayMap, baseUnary, cacheHas) {\n\n  /** Used as the size to enable large array optimizations. */\n  var LARGE_ARRAY_SIZE = 200;\n\n  /**\n   * The base implementation of methods like `_.difference` without support\n   * for excluding multiple arrays or iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {Array} values The values to exclude.\n   * @param {Function} [iteratee] The iteratee invoked per element.\n   * @param {Function} [comparator] The comparator invoked per element.\n   * @returns {Array} Returns the new array of filtered values.\n   */\n  function baseDifference(array, values, iteratee, comparator) {\n    var index = -1,\n        includes = arrayIncludes,\n        isCommon = true,\n        length = array.length,\n        result = [],\n        valuesLength = values.length;\n\n    if (!length) {\n      return result;\n    }\n    if (iteratee) {\n      values = arrayMap(values, baseUnary(iteratee));\n    }\n    if (comparator) {\n      includes = arrayIncludesWith;\n      isCommon = false;\n    }\n    else if (values.length >= LARGE_ARRAY_SIZE) {\n      includes = cacheHas;\n      isCommon = false;\n      values = new SetCache(values);\n    }\n    outer:\n    while (++index < length) {\n      var value = array[index],\n          computed = iteratee ? iteratee(value) : value;\n\n      value = (comparator || value !== 0) ? value : 0;\n      if (isCommon && computed === computed) {\n        var valuesIndex = valuesLength;\n        while (valuesIndex--) {\n          if (values[valuesIndex] === computed) {\n            continue outer;\n          }\n        }\n        result.push(value);\n      }\n      else if (!includes(values, computed, comparator)) {\n        result.push(value);\n      }\n    }\n    return result;\n  }\n\n  return baseDifference;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseEach.js":"define(['./_baseForOwn', './_createBaseEach'], function(baseForOwn, createBaseEach) {\n\n  /**\n   * The base implementation of `_.forEach` without support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array|Object} Returns `collection`.\n   */\n  var baseEach = createBaseEach(baseForOwn);\n\n  return baseEach;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseEachRight.js":"define(['./_baseForOwnRight', './_createBaseEach'], function(baseForOwnRight, createBaseEach) {\n\n  /**\n   * The base implementation of `_.forEachRight` without support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array|Object} Returns `collection`.\n   */\n  var baseEachRight = createBaseEach(baseForOwnRight, true);\n\n  return baseEachRight;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseEvery.js":"define(['./_baseEach'], function(baseEach) {\n\n  /**\n   * The base implementation of `_.every` without support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {boolean} Returns `true` if all elements pass the predicate check,\n   *  else `false`\n   */\n  function baseEvery(collection, predicate) {\n    var result = true;\n    baseEach(collection, function(value, index, collection) {\n      result = !!predicate(value, index, collection);\n      return result;\n    });\n    return result;\n  }\n\n  return baseEvery;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseExtremum.js":"define(['./isSymbol'], function(isSymbol) {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /**\n   * The base implementation of methods like `_.max` and `_.min` which accepts a\n   * `comparator` to determine the extremum value.\n   *\n   * @private\n   * @param {Array} array The array to iterate over.\n   * @param {Function} iteratee The iteratee invoked per iteration.\n   * @param {Function} comparator The comparator used to compare values.\n   * @returns {*} Returns the extremum value.\n   */\n  function baseExtremum(array, iteratee, comparator) {\n    var index = -1,\n        length = array.length;\n\n    while (++index < length) {\n      var value = array[index],\n          current = iteratee(value);\n\n      if (current != null && (computed === undefined\n            ? (current === current && !isSymbol(current))\n            : comparator(current, computed)\n          )) {\n        var computed = current,\n            result = value;\n      }\n    }\n    return result;\n  }\n\n  return baseExtremum;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseFill.js":"define(['./toInteger', './toLength'], function(toInteger, toLength) {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /**\n   * The base implementation of `_.fill` without an iteratee call guard.\n   *\n   * @private\n   * @param {Array} array The array to fill.\n   * @param {*} value The value to fill `array` with.\n   * @param {number} [start=0] The start position.\n   * @param {number} [end=array.length] The end position.\n   * @returns {Array} Returns `array`.\n   */\n  function baseFill(array, value, start, end) {\n    var length = array.length;\n\n    start = toInteger(start);\n    if (start < 0) {\n      start = -start > length ? 0 : (length + start);\n    }\n    end = (end === undefined || end > length) ? length : toInteger(end);\n    if (end < 0) {\n      end += length;\n    }\n    end = start > end ? 0 : toLength(end);\n    while (start < end) {\n      array[start++] = value;\n    }\n    return array;\n  }\n\n  return baseFill;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseFilter.js":"define(['./_baseEach'], function(baseEach) {\n\n  /**\n   * The base implementation of `_.filter` without support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {Array} Returns the new filtered array.\n   */\n  function baseFilter(collection, predicate) {\n    var result = [];\n    baseEach(collection, function(value, index, collection) {\n      if (predicate(value, index, collection)) {\n        result.push(value);\n      }\n    });\n    return result;\n  }\n\n  return baseFilter;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseFindIndex.js":"define([], function() {\n\n  /**\n   * The base implementation of `_.findIndex` and `_.findLastIndex` without\n   * support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {Function} predicate The function invoked per iteration.\n   * @param {number} fromIndex The index to search from.\n   * @param {boolean} [fromRight] Specify iterating from right to left.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseFindIndex(array, predicate, fromIndex, fromRight) {\n    var length = array.length,\n        index = fromIndex + (fromRight ? 1 : -1);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (predicate(array[index], index, array)) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  return baseFindIndex;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseFindKey.js":"define([], function() {\n\n  /**\n   * The base implementation of methods like `_.findKey` and `_.findLastKey`,\n   * without support for iteratee shorthands, which iterates over `collection`\n   * using `eachFunc`.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to inspect.\n   * @param {Function} predicate The function invoked per iteration.\n   * @param {Function} eachFunc The function to iterate over `collection`.\n   * @returns {*} Returns the found element or its key, else `undefined`.\n   */\n  function baseFindKey(collection, predicate, eachFunc) {\n    var result;\n    eachFunc(collection, function(value, key, collection) {\n      if (predicate(value, key, collection)) {\n        result = key;\n        return false;\n      }\n    });\n    return result;\n  }\n\n  return baseFindKey;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseFlatten.js":"define(['./_arrayPush', './_isFlattenable'], function(arrayPush, isFlattenable) {\n\n  /**\n   * The base implementation of `_.flatten` with support for restricting flattening.\n   *\n   * @private\n   * @param {Array} array The array to flatten.\n   * @param {number} depth The maximum recursion depth.\n   * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n   * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n   * @param {Array} [result=[]] The initial result value.\n   * @returns {Array} Returns the new flattened array.\n   */\n  function baseFlatten(array, depth, predicate, isStrict, result) {\n    var index = -1,\n        length = array.length;\n\n    predicate || (predicate = isFlattenable);\n    result || (result = []);\n\n    while (++index < length) {\n      var value = array[index];\n      if (depth > 0 && predicate(value)) {\n        if (depth > 1) {\n          // Recursively flatten arrays (susceptible to call stack limits).\n          baseFlatten(value, depth - 1, predicate, isStrict, result);\n        } else {\n          arrayPush(result, value);\n        }\n      } else if (!isStrict) {\n        result[result.length] = value;\n      }\n    }\n    return result;\n  }\n\n  return baseFlatten;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseFor.js":"define(['./_createBaseFor'], function(createBaseFor) {\n\n  /**\n   * The base implementation of `baseForOwn` which iterates over `object`\n   * properties returned by `keysFunc` and invokes `iteratee` for each property.\n   * Iteratee functions may exit iteration early by explicitly returning `false`.\n   *\n   * @private\n   * @param {Object} object The object to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {Function} keysFunc The function to get the keys of `object`.\n   * @returns {Object} Returns `object`.\n   */\n  var baseFor = createBaseFor();\n\n  return baseFor;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseForOwn.js":"define(['./_baseFor', './keys'], function(baseFor, keys) {\n\n  /**\n   * The base implementation of `_.forOwn` without support for iteratee shorthands.\n   *\n   * @private\n   * @param {Object} object The object to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Object} Returns `object`.\n   */\n  function baseForOwn(object, iteratee) {\n    return object && baseFor(object, iteratee, keys);\n  }\n\n  return baseForOwn;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseForOwnRight.js":"define(['./_baseForRight', './keys'], function(baseForRight, keys) {\n\n  /**\n   * The base implementation of `_.forOwnRight` without support for iteratee shorthands.\n   *\n   * @private\n   * @param {Object} object The object to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Object} Returns `object`.\n   */\n  function baseForOwnRight(object, iteratee) {\n    return object && baseForRight(object, iteratee, keys);\n  }\n\n  return baseForOwnRight;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseForRight.js":"define(['./_createBaseFor'], function(createBaseFor) {\n\n  /**\n   * This function is like `baseFor` except that it iterates over properties\n   * in the opposite order.\n   *\n   * @private\n   * @param {Object} object The object to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {Function} keysFunc The function to get the keys of `object`.\n   * @returns {Object} Returns `object`.\n   */\n  var baseForRight = createBaseFor(true);\n\n  return baseForRight;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseFunctions.js":"define(['./_arrayFilter', './isFunction'], function(arrayFilter, isFunction) {\n\n  /**\n   * The base implementation of `_.functions` which creates an array of\n   * `object` function property names filtered from `props`.\n   *\n   * @private\n   * @param {Object} object The object to inspect.\n   * @param {Array} props The property names to filter.\n   * @returns {Array} Returns the function names.\n   */\n  function baseFunctions(object, props) {\n    return arrayFilter(props, function(key) {\n      return isFunction(object[key]);\n    });\n  }\n\n  return baseFunctions;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseGetAllKeys.js":"define(['./_arrayPush', './isArray'], function(arrayPush, isArray) {\n\n  /**\n   * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n   * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n   * symbols of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Function} keysFunc The function to get the keys of `object`.\n   * @param {Function} symbolsFunc The function to get the symbols of `object`.\n   * @returns {Array} Returns the array of property names and symbols.\n   */\n  function baseGetAllKeys(object, keysFunc, symbolsFunc) {\n    var result = keysFunc(object);\n    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n  }\n\n  return baseGetAllKeys;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseGet.js":"define(['./_castPath', './_isKey', './_toKey'], function(castPath, isKey, toKey) {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /**\n   * The base implementation of `_.get` without support for default values.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array|string} path The path of the property to get.\n   * @returns {*} Returns the resolved value.\n   */\n  function baseGet(object, path) {\n    path = isKey(path, object) ? [path] : castPath(path);\n\n    var index = 0,\n        length = path.length;\n\n    while (object != null && index < length) {\n      object = object[toKey(path[index++])];\n    }\n    return (index && index == length) ? object : undefined;\n  }\n\n  return baseGet;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseGetTag.js":"define([], function() {\n\n  /** Used for built-in method references. */\n  var objectProto = Object.prototype;\n\n  /**\n   * Used to resolve the\n   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n   * of values.\n   */\n  var objectToString = objectProto.toString;\n\n  /**\n   * The base implementation of `getTag`.\n   *\n   * @private\n   * @param {*} value The value to query.\n   * @returns {string} Returns the `toStringTag`.\n   */\n  function baseGetTag(value) {\n    return objectToString.call(value);\n  }\n\n  return baseGetTag;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseGt.js":"define([], function() {\n\n  /**\n   * The base implementation of `_.gt` which doesn't coerce arguments.\n   *\n   * @private\n   * @param {*} value The value to compare.\n   * @param {*} other The other value to compare.\n   * @returns {boolean} Returns `true` if `value` is greater than `other`,\n   *  else `false`.\n   */\n  function baseGt(value, other) {\n    return value > other;\n  }\n\n  return baseGt;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseHasIn.js":"define([], function() {\n\n  /**\n   * The base implementation of `_.hasIn` without support for deep paths.\n   *\n   * @private\n   * @param {Object} [object] The object to query.\n   * @param {Array|string} key The key to check.\n   * @returns {boolean} Returns `true` if `key` exists, else `false`.\n   */\n  function baseHasIn(object, key) {\n    return object != null && key in Object(object);\n  }\n\n  return baseHasIn;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseHas.js":"define([], function() {\n\n  /** Used for built-in method references. */\n  var objectProto = Object.prototype;\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty = objectProto.hasOwnProperty;\n\n  /**\n   * The base implementation of `_.has` without support for deep paths.\n   *\n   * @private\n   * @param {Object} [object] The object to query.\n   * @param {Array|string} key The key to check.\n   * @returns {boolean} Returns `true` if `key` exists, else `false`.\n   */\n  function baseHas(object, key) {\n    return object != null && hasOwnProperty.call(object, key);\n  }\n\n  return baseHas;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseIndexOf.js":"define(['./_baseFindIndex', './_baseIsNaN', './_strictIndexOf'], function(baseFindIndex, baseIsNaN, strictIndexOf) {\n\n  /**\n   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseIndexOf(array, value, fromIndex) {\n    return value === value\n      ? strictIndexOf(array, value, fromIndex)\n      : baseFindIndex(array, baseIsNaN, fromIndex);\n  }\n\n  return baseIndexOf;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseIndexOfWith.js":"define([], function() {\n\n  /**\n   * This function is like `baseIndexOf` except that it accepts a comparator.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @param {Function} comparator The comparator invoked per element.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseIndexOfWith(array, value, fromIndex, comparator) {\n    var index = fromIndex - 1,\n        length = array.length;\n\n    while (++index < length) {\n      if (comparator(array[index], value)) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  return baseIndexOfWith;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseInRange.js":"define([], function() {\n\n  /* Built-in method references for those with the same name as other `lodash` methods. */\n  var nativeMax = Math.max,\n      nativeMin = Math.min;\n\n  /**\n   * The base implementation of `_.inRange` which doesn't coerce arguments.\n   *\n   * @private\n   * @param {number} number The number to check.\n   * @param {number} start The start of the range.\n   * @param {number} end The end of the range.\n   * @returns {boolean} Returns `true` if `number` is in the range, else `false`.\n   */\n  function baseInRange(number, start, end) {\n    return number >= nativeMin(start, end) && number < nativeMax(start, end);\n  }\n\n  return baseInRange;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseIntersection.js":"define(['./_SetCache', './_arrayIncludes', './_arrayIncludesWith', './_arrayMap', './_baseUnary', './_cacheHas'], function(SetCache, arrayIncludes, arrayIncludesWith, arrayMap, baseUnary, cacheHas) {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /* Built-in method references for those with the same name as other `lodash` methods. */\n  var nativeMin = Math.min;\n\n  /**\n   * The base implementation of methods like `_.intersection`, without support\n   * for iteratee shorthands, that accepts an array of arrays to inspect.\n   *\n   * @private\n   * @param {Array} arrays The arrays to inspect.\n   * @param {Function} [iteratee] The iteratee invoked per element.\n   * @param {Function} [comparator] The comparator invoked per element.\n   * @returns {Array} Returns the new array of shared values.\n   */\n  function baseIntersection(arrays, iteratee, comparator) {\n    var includes = comparator ? arrayIncludesWith : arrayIncludes,\n        length = arrays[0].length,\n        othLength = arrays.length,\n        othIndex = othLength,\n        caches = Array(othLength),\n        maxLength = Infinity,\n        result = [];\n\n    while (othIndex--) {\n      var array = arrays[othIndex];\n      if (othIndex && iteratee) {\n        array = arrayMap(array, baseUnary(iteratee));\n      }\n      maxLength = nativeMin(array.length, maxLength);\n      caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))\n        ? new SetCache(othIndex && array)\n        : undefined;\n    }\n    array = arrays[0];\n\n    var index = -1,\n        seen = caches[0];\n\n    outer:\n    while (++index < length && result.length < maxLength) {\n      var value = array[index],\n          computed = iteratee ? iteratee(value) : value;\n\n      value = (comparator || value !== 0) ? value : 0;\n      if (!(seen\n            ? cacheHas(seen, computed)\n            : includes(result, computed, comparator)\n          )) {\n        othIndex = othLength;\n        while (--othIndex) {\n          var cache = caches[othIndex];\n          if (!(cache\n                ? cacheHas(cache, computed)\n                : includes(arrays[othIndex], computed, comparator))\n              ) {\n            continue outer;\n          }\n        }\n        if (seen) {\n          seen.push(computed);\n        }\n        result.push(value);\n      }\n    }\n    return result;\n  }\n\n  return baseIntersection;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseInverter.js":"define(['./_baseForOwn'], function(baseForOwn) {\n\n  /**\n   * The base implementation of `_.invert` and `_.invertBy` which inverts\n   * `object` with values transformed by `iteratee` and set by `setter`.\n   *\n   * @private\n   * @param {Object} object The object to iterate over.\n   * @param {Function} setter The function to set `accumulator` values.\n   * @param {Function} iteratee The iteratee to transform values.\n   * @param {Object} accumulator The initial inverted object.\n   * @returns {Function} Returns `accumulator`.\n   */\n  function baseInverter(object, setter, iteratee, accumulator) {\n    baseForOwn(object, function(value, key, object) {\n      setter(accumulator, iteratee(value), key, object);\n    });\n    return accumulator;\n  }\n\n  return baseInverter;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseInvoke.js":"define(['./_apply', './_castPath', './_isKey', './last', './_parent', './_toKey'], function(apply, castPath, isKey, last, parent, toKey) {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /**\n   * The base implementation of `_.invoke` without support for individual\n   * method arguments.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array|string} path The path of the method to invoke.\n   * @param {Array} args The arguments to invoke the method with.\n   * @returns {*} Returns the result of the invoked method.\n   */\n  function baseInvoke(object, path, args) {\n    if (!isKey(path, object)) {\n      path = castPath(path);\n      object = parent(object, path);\n      path = last(path);\n    }\n    var func = object == null ? object : object[toKey(path)];\n    return func == null ? undefined : apply(func, object, args);\n  }\n\n  return baseInvoke;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseIsArguments.js":"define(['./isObjectLike'], function(isObjectLike) {\n\n  /** `Object#toString` result references. */\n  var argsTag = '[object Arguments]';\n\n  /** Used for built-in method references. */\n  var objectProto = Object.prototype;\n\n  /**\n   * Used to resolve the\n   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n   * of values.\n   */\n  var objectToString = objectProto.toString;\n\n  /**\n   * The base implementation of `_.isArguments`.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n   */\n  function baseIsArguments(value) {\n    return isObjectLike(value) && objectToString.call(value) == argsTag;\n  }\n\n  return baseIsArguments;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseIsArrayBuffer.js":"define(['./isObjectLike'], function(isObjectLike) {\n\n  var arrayBufferTag = '[object ArrayBuffer]';\n\n  /** Used for built-in method references. */\n  var objectProto = Object.prototype;\n\n  /**\n   * Used to resolve the\n   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n   * of values.\n   */\n  var objectToString = objectProto.toString;\n\n  /**\n   * The base implementation of `_.isArrayBuffer` without Node.js optimizations.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.\n   */\n  function baseIsArrayBuffer(value) {\n    return isObjectLike(value) && objectToString.call(value) == arrayBufferTag;\n  }\n\n  return baseIsArrayBuffer;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseIsDate.js":"define(['./isObjectLike'], function(isObjectLike) {\n\n  /** `Object#toString` result references. */\n  var dateTag = '[object Date]';\n\n  /** Used for built-in method references. */\n  var objectProto = Object.prototype;\n\n  /**\n   * Used to resolve the\n   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n   * of values.\n   */\n  var objectToString = objectProto.toString;\n\n  /**\n   * The base implementation of `_.isDate` without Node.js optimizations.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\n   */\n  function baseIsDate(value) {\n    return isObjectLike(value) && objectToString.call(value) == dateTag;\n  }\n\n  return baseIsDate;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseIsEqualDeep.js":"define(['./_Stack', './_equalArrays', './_equalByTag', './_equalObjects', './_getTag', './isArray', './isBuffer', './isTypedArray'], function(Stack, equalArrays, equalByTag, equalObjects, getTag, isArray, isBuffer, isTypedArray) {\n\n  /** Used to compose bitmasks for comparison styles. */\n  var PARTIAL_COMPARE_FLAG = 2;\n\n  /** `Object#toString` result references. */\n  var argsTag = '[object Arguments]',\n      arrayTag = '[object Array]',\n      objectTag = '[object Object]';\n\n  /** Used for built-in method references. */\n  var objectProto = Object.prototype;\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty = objectProto.hasOwnProperty;\n\n  /**\n   * A specialized version of `baseIsEqual` for arrays and objects which performs\n   * deep comparisons and tracks traversed objects enabling objects with circular\n   * references to be compared.\n   *\n   * @private\n   * @param {Object} object The object to compare.\n   * @param {Object} other The other object to compare.\n   * @param {Function} equalFunc The function to determine equivalents of values.\n   * @param {Function} [customizer] The function to customize comparisons.\n   * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`\n   *  for more details.\n   * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n   */\n  function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {\n    var objIsArr = isArray(object),\n        othIsArr = isArray(other),\n        objTag = arrayTag,\n        othTag = arrayTag;\n\n    if (!objIsArr) {\n      objTag = getTag(object);\n      objTag = objTag == argsTag ? objectTag : objTag;\n    }\n    if (!othIsArr) {\n      othTag = getTag(other);\n      othTag = othTag == argsTag ? objectTag : othTag;\n    }\n    var objIsObj = objTag == objectTag,\n        othIsObj = othTag == objectTag,\n        isSameTag = objTag == othTag;\n\n    if (isSameTag && isBuffer(object)) {\n      if (!isBuffer(other)) {\n        return false;\n      }\n      objIsArr = true;\n      objIsObj = false;\n    }\n    if (isSameTag && !objIsObj) {\n      stack || (stack = new Stack);\n      return (objIsArr || isTypedArray(object))\n        ? equalArrays(object, other, equalFunc, customizer, bitmask, stack)\n        : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);\n    }\n    if (!(bitmask & PARTIAL_COMPARE_FLAG)) {\n      var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n          othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n      if (objIsWrapped || othIsWrapped) {\n        var objUnwrapped = objIsWrapped ? object.value() : object,\n            othUnwrapped = othIsWrapped ? other.value() : other;\n\n        stack || (stack = new Stack);\n        return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);\n      }\n    }\n    if (!isSameTag) {\n      return false;\n    }\n    stack || (stack = new Stack);\n    return equalObjects(object, other, equalFunc, customizer, bitmask, stack);\n  }\n\n  return baseIsEqualDeep;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseIsEqual.js":"define(['./_baseIsEqualDeep', './isObject', './isObjectLike'], function(baseIsEqualDeep, isObject, isObjectLike) {\n\n  /**\n   * The base implementation of `_.isEqual` which supports partial comparisons\n   * and tracks traversed objects.\n   *\n   * @private\n   * @param {*} value The value to compare.\n   * @param {*} other The other value to compare.\n   * @param {Function} [customizer] The function to customize comparisons.\n   * @param {boolean} [bitmask] The bitmask of comparison flags.\n   *  The bitmask may be composed of the following flags:\n   *     1 - Unordered comparison\n   *     2 - Partial comparison\n   * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n   */\n  function baseIsEqual(value, other, customizer, bitmask, stack) {\n    if (value === other) {\n      return true;\n    }\n    if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {\n      return value !== value && other !== other;\n    }\n    return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);\n  }\n\n  return baseIsEqual;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseIsMap.js":"define(['./_getTag', './isObjectLike'], function(getTag, isObjectLike) {\n\n  /** `Object#toString` result references. */\n  var mapTag = '[object Map]';\n\n  /**\n   * The base implementation of `_.isMap` without Node.js optimizations.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n   */\n  function baseIsMap(value) {\n    return isObjectLike(value) && getTag(value) == mapTag;\n  }\n\n  return baseIsMap;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseIsMatch.js":"define(['./_Stack', './_baseIsEqual'], function(Stack, baseIsEqual) {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /** Used to compose bitmasks for comparison styles. */\n  var UNORDERED_COMPARE_FLAG = 1,\n      PARTIAL_COMPARE_FLAG = 2;\n\n  /**\n   * The base implementation of `_.isMatch` without support for iteratee shorthands.\n   *\n   * @private\n   * @param {Object} object The object to inspect.\n   * @param {Object} source The object of property values to match.\n   * @param {Array} matchData The property names, values, and compare flags to match.\n   * @param {Function} [customizer] The function to customize comparisons.\n   * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n   */\n  function baseIsMatch(object, source, matchData, customizer) {\n    var index = matchData.length,\n        length = index,\n        noCustomizer = !customizer;\n\n    if (object == null) {\n      return !length;\n    }\n    object = Object(object);\n    while (index--) {\n      var data = matchData[index];\n      if ((noCustomizer && data[2])\n            ? data[1] !== object[data[0]]\n            : !(data[0] in object)\n          ) {\n        return false;\n      }\n    }\n    while (++index < length) {\n      data = matchData[index];\n      var key = data[0],\n          objValue = object[key],\n          srcValue = data[1];\n\n      if (noCustomizer && data[2]) {\n        if (objValue === undefined && !(key in object)) {\n          return false;\n        }\n      } else {\n        var stack = new Stack;\n        if (customizer) {\n          var result = customizer(objValue, srcValue, key, object, source, stack);\n        }\n        if (!(result === undefined\n              ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack)\n              : result\n            )) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  return baseIsMatch;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseIsNaN.js":"define([], function() {\n\n  /**\n   * The base implementation of `_.isNaN` without support for number objects.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n   */\n  function baseIsNaN(value) {\n    return value !== value;\n  }\n\n  return baseIsNaN;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseIsNative.js":"define(['./isFunction', './_isMasked', './isObject', './_toSource'], function(isFunction, isMasked, isObject, toSource) {\n\n  /**\n   * Used to match `RegExp`\n   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n   */\n  var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n  /** Used to detect host constructors (Safari). */\n  var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n  /** Used for built-in method references. */\n  var funcProto = Function.prototype,\n      objectProto = Object.prototype;\n\n  /** Used to resolve the decompiled source of functions. */\n  var funcToString = funcProto.toString;\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty = objectProto.hasOwnProperty;\n\n  /** Used to detect if a method is native. */\n  var reIsNative = RegExp('^' +\n    funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n    .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n  );\n\n  /**\n   * The base implementation of `_.isNative` without bad shim checks.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a native function,\n   *  else `false`.\n   */\n  function baseIsNative(value) {\n    if (!isObject(value) || isMasked(value)) {\n      return false;\n    }\n    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n    return pattern.test(toSource(value));\n  }\n\n  return baseIsNative;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseIsRegExp.js":"define(['./isObject'], function(isObject) {\n\n  /** `Object#toString` result references. */\n  var regexpTag = '[object RegExp]';\n\n  /** Used for built-in method references. */\n  var objectProto = Object.prototype;\n\n  /**\n   * Used to resolve the\n   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n   * of values.\n   */\n  var objectToString = objectProto.toString;\n\n  /**\n   * The base implementation of `_.isRegExp` without Node.js optimizations.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n   */\n  function baseIsRegExp(value) {\n    return isObject(value) && objectToString.call(value) == regexpTag;\n  }\n\n  return baseIsRegExp;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseIsSet.js":"define(['./_getTag', './isObjectLike'], function(getTag, isObjectLike) {\n\n  /** `Object#toString` result references. */\n  var setTag = '[object Set]';\n\n  /**\n   * The base implementation of `_.isSet` without Node.js optimizations.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n   */\n  function baseIsSet(value) {\n    return isObjectLike(value) && getTag(value) == setTag;\n  }\n\n  return baseIsSet;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseIsTypedArray.js":"define(['./isLength', './isObjectLike'], function(isLength, isObjectLike) {\n\n  /** `Object#toString` result references. */\n  var argsTag = '[object Arguments]',\n      arrayTag = '[object Array]',\n      boolTag = '[object Boolean]',\n      dateTag = '[object Date]',\n      errorTag = '[object Error]',\n      funcTag = '[object Function]',\n      mapTag = '[object Map]',\n      numberTag = '[object Number]',\n      objectTag = '[object Object]',\n      regexpTag = '[object RegExp]',\n      setTag = '[object Set]',\n      stringTag = '[object String]',\n      weakMapTag = '[object WeakMap]';\n\n  var arrayBufferTag = '[object ArrayBuffer]',\n      dataViewTag = '[object DataView]',\n      float32Tag = '[object Float32Array]',\n      float64Tag = '[object Float64Array]',\n      int8Tag = '[object Int8Array]',\n      int16Tag = '[object Int16Array]',\n      int32Tag = '[object Int32Array]',\n      uint8Tag = '[object Uint8Array]',\n      uint8ClampedTag = '[object Uint8ClampedArray]',\n      uint16Tag = '[object Uint16Array]',\n      uint32Tag = '[object Uint32Array]';\n\n  /** Used to identify `toStringTag` values of typed arrays. */\n  var typedArrayTags = {};\n  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\n  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\n  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\n  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\n  typedArrayTags[uint32Tag] = true;\n  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =\n  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\n  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\n  typedArrayTags[errorTag] = typedArrayTags[funcTag] =\n  typedArrayTags[mapTag] = typedArrayTags[numberTag] =\n  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =\n  typedArrayTags[setTag] = typedArrayTags[stringTag] =\n  typedArrayTags[weakMapTag] = false;\n\n  /** Used for built-in method references. */\n  var objectProto = Object.prototype;\n\n  /**\n   * Used to resolve the\n   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n   * of values.\n   */\n  var objectToString = objectProto.toString;\n\n  /**\n   * The base implementation of `_.isTypedArray` without Node.js optimizations.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n   */\n  function baseIsTypedArray(value) {\n    return isObjectLike(value) &&\n      isLength(value.length) && !!typedArrayTags[objectToString.call(value)];\n  }\n\n  return baseIsTypedArray;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseIteratee.js":"define(['./_baseMatches', './_baseMatchesProperty', './identity', './isArray', './property'], function(baseMatches, baseMatchesProperty, identity, isArray, property) {\n\n  /**\n   * The base implementation of `_.iteratee`.\n   *\n   * @private\n   * @param {*} [value=_.identity] The value to convert to an iteratee.\n   * @returns {Function} Returns the iteratee.\n   */\n  function baseIteratee(value) {\n    // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n    // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n    if (typeof value == 'function') {\n      return value;\n    }\n    if (value == null) {\n      return identity;\n    }\n    if (typeof value == 'object') {\n      return isArray(value)\n        ? baseMatchesProperty(value[0], value[1])\n        : baseMatches(value);\n    }\n    return property(value);\n  }\n\n  return baseIteratee;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseKeysIn.js":"define(['./isObject', './_isPrototype', './_nativeKeysIn'], function(isObject, isPrototype, nativeKeysIn) {\n\n  /** Used for built-in method references. */\n  var objectProto = Object.prototype;\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty = objectProto.hasOwnProperty;\n\n  /**\n   * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property names.\n   */\n  function baseKeysIn(object) {\n    if (!isObject(object)) {\n      return nativeKeysIn(object);\n    }\n    var isProto = isPrototype(object),\n        result = [];\n\n    for (var key in object) {\n      if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n        result.push(key);\n      }\n    }\n    return result;\n  }\n\n  return baseKeysIn;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseKeys.js":"define(['./_isPrototype', './_nativeKeys'], function(isPrototype, nativeKeys) {\n\n  /** Used for built-in method references. */\n  var objectProto = Object.prototype;\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty = objectProto.hasOwnProperty;\n\n  /**\n   * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property names.\n   */\n  function baseKeys(object) {\n    if (!isPrototype(object)) {\n      return nativeKeys(object);\n    }\n    var result = [];\n    for (var key in Object(object)) {\n      if (hasOwnProperty.call(object, key) && key != 'constructor') {\n        result.push(key);\n      }\n    }\n    return result;\n  }\n\n  return baseKeys;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseLodash.js":"define([], function() {\n\n  /**\n   * The function whose prototype chain sequence wrappers inherit from.\n   *\n   * @private\n   */\n  function baseLodash() {\n    // No operation performed.\n  }\n\n  return baseLodash;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseLt.js":"define([], function() {\n\n  /**\n   * The base implementation of `_.lt` which doesn't coerce arguments.\n   *\n   * @private\n   * @param {*} value The value to compare.\n   * @param {*} other The other value to compare.\n   * @returns {boolean} Returns `true` if `value` is less than `other`,\n   *  else `false`.\n   */\n  function baseLt(value, other) {\n    return value < other;\n  }\n\n  return baseLt;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseMap.js":"define(['./_baseEach', './isArrayLike'], function(baseEach, isArrayLike) {\n\n  /**\n   * The base implementation of `_.map` without support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the new mapped array.\n   */\n  function baseMap(collection, iteratee) {\n    var index = -1,\n        result = isArrayLike(collection) ? Array(collection.length) : [];\n\n    baseEach(collection, function(value, key, collection) {\n      result[++index] = iteratee(value, key, collection);\n    });\n    return result;\n  }\n\n  return baseMap;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseMatches.js":"define(['./_baseIsMatch', './_getMatchData', './_matchesStrictComparable'], function(baseIsMatch, getMatchData, matchesStrictComparable) {\n\n  /**\n   * The base implementation of `_.matches` which doesn't clone `source`.\n   *\n   * @private\n   * @param {Object} source The object of property values to match.\n   * @returns {Function} Returns the new spec function.\n   */\n  function baseMatches(source) {\n    var matchData = getMatchData(source);\n    if (matchData.length == 1 && matchData[0][2]) {\n      return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n    }\n    return function(object) {\n      return object === source || baseIsMatch(object, source, matchData);\n    };\n  }\n\n  return baseMatches;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseMatchesProperty.js":"define(['./_baseIsEqual', './get', './hasIn', './_isKey', './_isStrictComparable', './_matchesStrictComparable', './_toKey'], function(baseIsEqual, get, hasIn, isKey, isStrictComparable, matchesStrictComparable, toKey) {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /** Used to compose bitmasks for comparison styles. */\n  var UNORDERED_COMPARE_FLAG = 1,\n      PARTIAL_COMPARE_FLAG = 2;\n\n  /**\n   * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n   *\n   * @private\n   * @param {string} path The path of the property to get.\n   * @param {*} srcValue The value to match.\n   * @returns {Function} Returns the new spec function.\n   */\n  function baseMatchesProperty(path, srcValue) {\n    if (isKey(path) && isStrictComparable(srcValue)) {\n      return matchesStrictComparable(toKey(path), srcValue);\n    }\n    return function(object) {\n      var objValue = get(object, path);\n      return (objValue === undefined && objValue === srcValue)\n        ? hasIn(object, path)\n        : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);\n    };\n  }\n\n  return baseMatchesProperty;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseMean.js":"define(['./_baseSum'], function(baseSum) {\n\n  /** Used as references for various `Number` constants. */\n  var NAN = 0 / 0;\n\n  /**\n   * The base implementation of `_.mean` and `_.meanBy` without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {number} Returns the mean.\n   */\n  function baseMean(array, iteratee) {\n    var length = array ? array.length : 0;\n    return length ? (baseSum(array, iteratee) / length) : NAN;\n  }\n\n  return baseMean;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseMergeDeep.js":"define(['./_assignMergeValue', './_cloneBuffer', './_cloneTypedArray', './_copyArray', './_initCloneObject', './isArguments', './isArray', './isArrayLikeObject', './isBuffer', './isFunction', './isObject', './isPlainObject', './isTypedArray', './toPlainObject'], function(assignMergeValue, cloneBuffer, cloneTypedArray, copyArray, initCloneObject, isArguments, isArray, isArrayLikeObject, isBuffer, isFunction, isObject, isPlainObject, isTypedArray, toPlainObject) {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /**\n   * A specialized version of `baseMerge` for arrays and objects which performs\n   * deep merges and tracks traversed objects enabling objects with circular\n   * references to be merged.\n   *\n   * @private\n   * @param {Object} object The destination object.\n   * @param {Object} source The source object.\n   * @param {string} key The key of the value to merge.\n   * @param {number} srcIndex The index of `source`.\n   * @param {Function} mergeFunc The function to merge values.\n   * @param {Function} [customizer] The function to customize assigned values.\n   * @param {Object} [stack] Tracks traversed source values and their merged\n   *  counterparts.\n   */\n  function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {\n    var objValue = object[key],\n        srcValue = source[key],\n        stacked = stack.get(srcValue);\n\n    if (stacked) {\n      assignMergeValue(object, key, stacked);\n      return;\n    }\n    var newValue = customizer\n      ? customizer(objValue, srcValue, (key + ''), object, source, stack)\n      : undefined;\n\n    var isCommon = newValue === undefined;\n\n    if (isCommon) {\n      var isArr = isArray(srcValue),\n          isBuff = !isArr && isBuffer(srcValue),\n          isTyped = !isArr && !isBuff && isTypedArray(srcValue);\n\n      newValue = srcValue;\n      if (isArr || isBuff || isTyped) {\n        if (isArray(objValue)) {\n          newValue = objValue;\n        }\n        else if (isArrayLikeObject(objValue)) {\n          newValue = copyArray(objValue);\n        }\n        else if (isBuff) {\n          isCommon = false;\n          newValue = cloneBuffer(srcValue, true);\n        }\n        else if (isTyped) {\n          isCommon = false;\n          newValue = cloneTypedArray(srcValue, true);\n        }\n        else {\n          newValue = [];\n        }\n      }\n      else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n        newValue = objValue;\n        if (isArguments(objValue)) {\n          newValue = toPlainObject(objValue);\n        }\n        else if (!isObject(objValue) || (srcIndex && isFunction(objValue))) {\n          newValue = initCloneObject(srcValue);\n        }\n      }\n      else {\n        isCommon = false;\n      }\n    }\n    if (isCommon) {\n      // Recursively merge objects and arrays (susceptible to call stack limits).\n      stack.set(srcValue, newValue);\n      mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n      stack['delete'](srcValue);\n    }\n    assignMergeValue(object, key, newValue);\n  }\n\n  return baseMergeDeep;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseMerge.js":"define(['./_Stack', './_assignMergeValue', './_baseFor', './_baseMergeDeep', './isObject', './keysIn'], function(Stack, assignMergeValue, baseFor, baseMergeDeep, isObject, keysIn) {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /**\n   * The base implementation of `_.merge` without support for multiple sources.\n   *\n   * @private\n   * @param {Object} object The destination object.\n   * @param {Object} source The source object.\n   * @param {number} srcIndex The index of `source`.\n   * @param {Function} [customizer] The function to customize merged values.\n   * @param {Object} [stack] Tracks traversed source values and their merged\n   *  counterparts.\n   */\n  function baseMerge(object, source, srcIndex, customizer, stack) {\n    if (object === source) {\n      return;\n    }\n    baseFor(source, function(srcValue, key) {\n      if (isObject(srcValue)) {\n        stack || (stack = new Stack);\n        baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n      }\n      else {\n        var newValue = customizer\n          ? customizer(object[key], srcValue, (key + ''), object, source, stack)\n          : undefined;\n\n        if (newValue === undefined) {\n          newValue = srcValue;\n        }\n        assignMergeValue(object, key, newValue);\n      }\n    }, keysIn);\n  }\n\n  return baseMerge;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseNth.js":"define(['./_isIndex'], function(isIndex) {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /**\n   * The base implementation of `_.nth` which doesn't coerce arguments.\n   *\n   * @private\n   * @param {Array} array The array to query.\n   * @param {number} n The index of the element to return.\n   * @returns {*} Returns the nth element of `array`.\n   */\n  function baseNth(array, n) {\n    var length = array.length;\n    if (!length) {\n      return;\n    }\n    n += n < 0 ? length : 0;\n    return isIndex(n, length) ? array[n] : undefined;\n  }\n\n  return baseNth;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseOrderBy.js":"define(['./_arrayMap', './_baseIteratee', './_baseMap', './_baseSortBy', './_baseUnary', './_compareMultiple', './identity'], function(arrayMap, baseIteratee, baseMap, baseSortBy, baseUnary, compareMultiple, identity) {\n\n  /**\n   * The base implementation of `_.orderBy` without param guards.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.\n   * @param {string[]} orders The sort orders of `iteratees`.\n   * @returns {Array} Returns the new sorted array.\n   */\n  function baseOrderBy(collection, iteratees, orders) {\n    var index = -1;\n    iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(baseIteratee));\n\n    var result = baseMap(collection, function(value, key, collection) {\n      var criteria = arrayMap(iteratees, function(iteratee) {\n        return iteratee(value);\n      });\n      return { 'criteria': criteria, 'index': ++index, 'value': value };\n    });\n\n    return baseSortBy(result, function(object, other) {\n      return compareMultiple(object, other, orders);\n    });\n  }\n\n  return baseOrderBy;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_basePickBy.js":"define(['./_baseAssignValue'], function(baseAssignValue) {\n\n  /**\n   * The base implementation of  `_.pickBy` without support for iteratee shorthands.\n   *\n   * @private\n   * @param {Object} object The source object.\n   * @param {string[]} props The property identifiers to pick from.\n   * @param {Function} predicate The function invoked per property.\n   * @returns {Object} Returns the new object.\n   */\n  function basePickBy(object, props, predicate) {\n    var index = -1,\n        length = props.length,\n        result = {};\n\n    while (++index < length) {\n      var key = props[index],\n          value = object[key];\n\n      if (predicate(value, key)) {\n        baseAssignValue(result, key, value);\n      }\n    }\n    return result;\n  }\n\n  return basePickBy;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_basePick.js":"define(['./_basePickBy'], function(basePickBy) {\n\n  /**\n   * The base implementation of `_.pick` without support for individual\n   * property identifiers.\n   *\n   * @private\n   * @param {Object} object The source object.\n   * @param {string[]} props The property identifiers to pick.\n   * @returns {Object} Returns the new object.\n   */\n  function basePick(object, props) {\n    object = Object(object);\n    return basePickBy(object, props, function(value, key) {\n      return key in object;\n    });\n  }\n\n  return basePick;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_basePropertyDeep.js":"define(['./_baseGet'], function(baseGet) {\n\n  /**\n   * A specialized version of `baseProperty` which supports deep paths.\n   *\n   * @private\n   * @param {Array|string} path The path of the property to get.\n   * @returns {Function} Returns the new accessor function.\n   */\n  function basePropertyDeep(path) {\n    return function(object) {\n      return baseGet(object, path);\n    };\n  }\n\n  return basePropertyDeep;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseProperty.js":"define([], function() {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /**\n   * The base implementation of `_.property` without support for deep paths.\n   *\n   * @private\n   * @param {string} key The key of the property to get.\n   * @returns {Function} Returns the new accessor function.\n   */\n  function baseProperty(key) {\n    return function(object) {\n      return object == null ? undefined : object[key];\n    };\n  }\n\n  return baseProperty;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_basePropertyOf.js":"define([], function() {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /**\n   * The base implementation of `_.propertyOf` without support for deep paths.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Function} Returns the new accessor function.\n   */\n  function basePropertyOf(object) {\n    return function(key) {\n      return object == null ? undefined : object[key];\n    };\n  }\n\n  return basePropertyOf;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_basePullAll.js":"define(['./_arrayMap', './_baseIndexOf', './_baseIndexOfWith', './_baseUnary', './_copyArray'], function(arrayMap, baseIndexOf, baseIndexOfWith, baseUnary, copyArray) {\n\n  /** Used for built-in method references. */\n  var arrayProto = Array.prototype;\n\n  /** Built-in value references. */\n  var splice = arrayProto.splice;\n\n  /**\n   * The base implementation of `_.pullAllBy` without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} array The array to modify.\n   * @param {Array} values The values to remove.\n   * @param {Function} [iteratee] The iteratee invoked per element.\n   * @param {Function} [comparator] The comparator invoked per element.\n   * @returns {Array} Returns `array`.\n   */\n  function basePullAll(array, values, iteratee, comparator) {\n    var indexOf = comparator ? baseIndexOfWith : baseIndexOf,\n        index = -1,\n        length = values.length,\n        seen = array;\n\n    if (array === values) {\n      values = copyArray(values);\n    }\n    if (iteratee) {\n      seen = arrayMap(array, baseUnary(iteratee));\n    }\n    while (++index < length) {\n      var fromIndex = 0,\n          value = values[index],\n          computed = iteratee ? iteratee(value) : value;\n\n      while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {\n        if (seen !== array) {\n          splice.call(seen, fromIndex, 1);\n        }\n        splice.call(array, fromIndex, 1);\n      }\n    }\n    return array;\n  }\n\n  return basePullAll;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_basePullAt.js":"define(['./_castPath', './_isIndex', './_isKey', './last', './_parent', './_toKey'], function(castPath, isIndex, isKey, last, parent, toKey) {\n\n  /** Used for built-in method references. */\n  var arrayProto = Array.prototype;\n\n  /** Built-in value references. */\n  var splice = arrayProto.splice;\n\n  /**\n   * The base implementation of `_.pullAt` without support for individual\n   * indexes or capturing the removed elements.\n   *\n   * @private\n   * @param {Array} array The array to modify.\n   * @param {number[]} indexes The indexes of elements to remove.\n   * @returns {Array} Returns `array`.\n   */\n  function basePullAt(array, indexes) {\n    var length = array ? indexes.length : 0,\n        lastIndex = length - 1;\n\n    while (length--) {\n      var index = indexes[length];\n      if (length == lastIndex || index !== previous) {\n        var previous = index;\n        if (isIndex(index)) {\n          splice.call(array, index, 1);\n        }\n        else if (!isKey(index, array)) {\n          var path = castPath(index),\n              object = parent(array, path);\n\n          if (object != null) {\n            delete object[toKey(last(path))];\n          }\n        }\n        else {\n          delete array[toKey(index)];\n        }\n      }\n    }\n    return array;\n  }\n\n  return basePullAt;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseRandom.js":"define([], function() {\n\n  /* Built-in method references for those with the same name as other `lodash` methods. */\n  var nativeFloor = Math.floor,\n      nativeRandom = Math.random;\n\n  /**\n   * The base implementation of `_.random` without support for returning\n   * floating-point numbers.\n   *\n   * @private\n   * @param {number} lower The lower bound.\n   * @param {number} upper The upper bound.\n   * @returns {number} Returns the random number.\n   */\n  function baseRandom(lower, upper) {\n    return lower + nativeFloor(nativeRandom() * (upper - lower + 1));\n  }\n\n  return baseRandom;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseRange.js":"define([], function() {\n\n  /* Built-in method references for those with the same name as other `lodash` methods. */\n  var nativeCeil = Math.ceil,\n      nativeMax = Math.max;\n\n  /**\n   * The base implementation of `_.range` and `_.rangeRight` which doesn't\n   * coerce arguments.\n   *\n   * @private\n   * @param {number} start The start of the range.\n   * @param {number} end The end of the range.\n   * @param {number} step The value to increment or decrement by.\n   * @param {boolean} [fromRight] Specify iterating from right to left.\n   * @returns {Array} Returns the range of numbers.\n   */\n  function baseRange(start, end, step, fromRight) {\n    var index = -1,\n        length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),\n        result = Array(length);\n\n    while (length--) {\n      result[fromRight ? length : ++index] = start;\n      start += step;\n    }\n    return result;\n  }\n\n  return baseRange;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseReduce.js":"define([], function() {\n\n  /**\n   * The base implementation of `_.reduce` and `_.reduceRight`, without support\n   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} accumulator The initial value.\n   * @param {boolean} initAccum Specify using the first or last element of\n   *  `collection` as the initial value.\n   * @param {Function} eachFunc The function to iterate over `collection`.\n   * @returns {*} Returns the accumulated value.\n   */\n  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {\n    eachFunc(collection, function(value, index, collection) {\n      accumulator = initAccum\n        ? (initAccum = false, value)\n        : iteratee(accumulator, value, index, collection);\n    });\n    return accumulator;\n  }\n\n  return baseReduce;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseRepeat.js":"define([], function() {\n\n  /** Used as references for various `Number` constants. */\n  var MAX_SAFE_INTEGER = 9007199254740991;\n\n  /* Built-in method references for those with the same name as other `lodash` methods. */\n  var nativeFloor = Math.floor;\n\n  /**\n   * The base implementation of `_.repeat` which doesn't coerce arguments.\n   *\n   * @private\n   * @param {string} string The string to repeat.\n   * @param {number} n The number of times to repeat the string.\n   * @returns {string} Returns the repeated string.\n   */\n  function baseRepeat(string, n) {\n    var result = '';\n    if (!string || n < 1 || n > MAX_SAFE_INTEGER) {\n      return result;\n    }\n    // Leverage the exponentiation by squaring algorithm for a faster repeat.\n    // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.\n    do {\n      if (n % 2) {\n        result += string;\n      }\n      n = nativeFloor(n / 2);\n      if (n) {\n        string += string;\n      }\n    } while (n);\n\n    return result;\n  }\n\n  return baseRepeat;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseRest.js":"define(['./identity', './_overRest', './_setToString'], function(identity, overRest, setToString) {\n\n  /**\n   * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n   *\n   * @private\n   * @param {Function} func The function to apply a rest parameter to.\n   * @param {number} [start=func.length-1] The start position of the rest parameter.\n   * @returns {Function} Returns the new function.\n   */\n  function baseRest(func, start) {\n    return setToString(overRest(func, start, identity), func + '');\n  }\n\n  return baseRest;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseSample.js":"define(['./_arraySample', './values'], function(arraySample, values) {\n\n  /**\n   * The base implementation of `_.sample`.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to sample.\n   * @returns {*} Returns the random element.\n   */\n  function baseSample(collection) {\n    return arraySample(values(collection));\n  }\n\n  return baseSample;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseSampleSize.js":"define(['./_baseClamp', './_shuffleSelf', './values'], function(baseClamp, shuffleSelf, values) {\n\n  /**\n   * The base implementation of `_.sampleSize` without param guards.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to sample.\n   * @param {number} n The number of elements to sample.\n   * @returns {Array} Returns the random elements.\n   */\n  function baseSampleSize(collection, n) {\n    var array = values(collection);\n    return shuffleSelf(array, baseClamp(n, 0, array.length));\n  }\n\n  return baseSampleSize;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseSetData.js":"define(['./identity', './_metaMap'], function(identity, metaMap) {\n\n  /**\n   * The base implementation of `setData` without support for hot loop shorting.\n   *\n   * @private\n   * @param {Function} func The function to associate metadata with.\n   * @param {*} data The metadata.\n   * @returns {Function} Returns `func`.\n   */\n  var baseSetData = !metaMap ? identity : function(func, data) {\n    metaMap.set(func, data);\n    return func;\n  };\n\n  return baseSetData;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseSet.js":"define(['./_assignValue', './_castPath', './_isIndex', './_isKey', './isObject', './_toKey'], function(assignValue, castPath, isIndex, isKey, isObject, toKey) {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /**\n   * The base implementation of `_.set`.\n   *\n   * @private\n   * @param {Object} object The object to modify.\n   * @param {Array|string} path The path of the property to set.\n   * @param {*} value The value to set.\n   * @param {Function} [customizer] The function to customize path creation.\n   * @returns {Object} Returns `object`.\n   */\n  function baseSet(object, path, value, customizer) {\n    if (!isObject(object)) {\n      return object;\n    }\n    path = isKey(path, object) ? [path] : castPath(path);\n\n    var index = -1,\n        length = path.length,\n        lastIndex = length - 1,\n        nested = object;\n\n    while (nested != null && ++index < length) {\n      var key = toKey(path[index]),\n          newValue = value;\n\n      if (index != lastIndex) {\n        var objValue = nested[key];\n        newValue = customizer ? customizer(objValue, key, nested) : undefined;\n        if (newValue === undefined) {\n          newValue = isObject(objValue)\n            ? objValue\n            : (isIndex(path[index + 1]) ? [] : {});\n        }\n      }\n      assignValue(nested, key, newValue);\n      nested = nested[key];\n    }\n    return object;\n  }\n\n  return baseSet;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseSetToString.js":"define(['./constant', './_defineProperty', './identity'], function(constant, defineProperty, identity) {\n\n  /**\n   * The base implementation of `setToString` without support for hot loop shorting.\n   *\n   * @private\n   * @param {Function} func The function to modify.\n   * @param {Function} string The `toString` result.\n   * @returns {Function} Returns `func`.\n   */\n  var baseSetToString = !defineProperty ? identity : function(func, string) {\n    return defineProperty(func, 'toString', {\n      'configurable': true,\n      'enumerable': false,\n      'value': constant(string),\n      'writable': true\n    });\n  };\n\n  return baseSetToString;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseShuffle.js":"define(['./_shuffleSelf', './values'], function(shuffleSelf, values) {\n\n  /**\n   * The base implementation of `_.shuffle`.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to shuffle.\n   * @returns {Array} Returns the new shuffled array.\n   */\n  function baseShuffle(collection) {\n    return shuffleSelf(values(collection));\n  }\n\n  return baseShuffle;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseSlice.js":"define([], function() {\n\n  /**\n   * The base implementation of `_.slice` without an iteratee call guard.\n   *\n   * @private\n   * @param {Array} array The array to slice.\n   * @param {number} [start=0] The start position.\n   * @param {number} [end=array.length] The end position.\n   * @returns {Array} Returns the slice of `array`.\n   */\n  function baseSlice(array, start, end) {\n    var index = -1,\n        length = array.length;\n\n    if (start < 0) {\n      start = -start > length ? 0 : (length + start);\n    }\n    end = end > length ? length : end;\n    if (end < 0) {\n      end += length;\n    }\n    length = start > end ? 0 : ((end - start) >>> 0);\n    start >>>= 0;\n\n    var result = Array(length);\n    while (++index < length) {\n      result[index] = array[index + start];\n    }\n    return result;\n  }\n\n  return baseSlice;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseSome.js":"define(['./_baseEach'], function(baseEach) {\n\n  /**\n   * The base implementation of `_.some` without support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {boolean} Returns `true` if any element passes the predicate check,\n   *  else `false`.\n   */\n  function baseSome(collection, predicate) {\n    var result;\n\n    baseEach(collection, function(value, index, collection) {\n      result = predicate(value, index, collection);\n      return !result;\n    });\n    return !!result;\n  }\n\n  return baseSome;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseSortBy.js":"define([], function() {\n\n  /**\n   * The base implementation of `_.sortBy` which uses `comparer` to define the\n   * sort order of `array` and replaces criteria objects with their corresponding\n   * values.\n   *\n   * @private\n   * @param {Array} array The array to sort.\n   * @param {Function} comparer The function to define sort order.\n   * @returns {Array} Returns `array`.\n   */\n  function baseSortBy(array, comparer) {\n    var length = array.length;\n\n    array.sort(comparer);\n    while (length--) {\n      array[length] = array[length].value;\n    }\n    return array;\n  }\n\n  return baseSortBy;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseSortedIndexBy.js":"define(['./isSymbol'], function(isSymbol) {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /** Used as references for the maximum length and index of an array. */\n  var MAX_ARRAY_LENGTH = 4294967295,\n      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1;\n\n  /* Built-in method references for those with the same name as other `lodash` methods. */\n  var nativeFloor = Math.floor,\n      nativeMin = Math.min;\n\n  /**\n   * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`\n   * which invokes `iteratee` for `value` and each element of `array` to compute\n   * their sort ranking. The iteratee is invoked with one argument; (value).\n   *\n   * @private\n   * @param {Array} array The sorted array to inspect.\n   * @param {*} value The value to evaluate.\n   * @param {Function} iteratee The iteratee invoked per element.\n   * @param {boolean} [retHighest] Specify returning the highest qualified index.\n   * @returns {number} Returns the index at which `value` should be inserted\n   *  into `array`.\n   */\n  function baseSortedIndexBy(array, value, iteratee, retHighest) {\n    value = iteratee(value);\n\n    var low = 0,\n        high = array ? array.length : 0,\n        valIsNaN = value !== value,\n        valIsNull = value === null,\n        valIsSymbol = isSymbol(value),\n        valIsUndefined = value === undefined;\n\n    while (low < high) {\n      var mid = nativeFloor((low + high) / 2),\n          computed = iteratee(array[mid]),\n          othIsDefined = computed !== undefined,\n          othIsNull = computed === null,\n          othIsReflexive = computed === computed,\n          othIsSymbol = isSymbol(computed);\n\n      if (valIsNaN) {\n        var setLow = retHighest || othIsReflexive;\n      } else if (valIsUndefined) {\n        setLow = othIsReflexive && (retHighest || othIsDefined);\n      } else if (valIsNull) {\n        setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);\n      } else if (valIsSymbol) {\n        setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);\n      } else if (othIsNull || othIsSymbol) {\n        setLow = false;\n      } else {\n        setLow = retHighest ? (computed <= value) : (computed < value);\n      }\n      if (setLow) {\n        low = mid + 1;\n      } else {\n        high = mid;\n      }\n    }\n    return nativeMin(high, MAX_ARRAY_INDEX);\n  }\n\n  return baseSortedIndexBy;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseSortedIndex.js":"define(['./_baseSortedIndexBy', './identity', './isSymbol'], function(baseSortedIndexBy, identity, isSymbol) {\n\n  /** Used as references for the maximum length and index of an array. */\n  var MAX_ARRAY_LENGTH = 4294967295,\n      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;\n\n  /**\n   * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which\n   * performs a binary search of `array` to determine the index at which `value`\n   * should be inserted into `array` in order to maintain its sort order.\n   *\n   * @private\n   * @param {Array} array The sorted array to inspect.\n   * @param {*} value The value to evaluate.\n   * @param {boolean} [retHighest] Specify returning the highest qualified index.\n   * @returns {number} Returns the index at which `value` should be inserted\n   *  into `array`.\n   */\n  function baseSortedIndex(array, value, retHighest) {\n    var low = 0,\n        high = array ? array.length : low;\n\n    if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {\n      while (low < high) {\n        var mid = (low + high) >>> 1,\n            computed = array[mid];\n\n        if (computed !== null && !isSymbol(computed) &&\n            (retHighest ? (computed <= value) : (computed < value))) {\n          low = mid + 1;\n        } else {\n          high = mid;\n        }\n      }\n      return high;\n    }\n    return baseSortedIndexBy(array, value, identity, retHighest);\n  }\n\n  return baseSortedIndex;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseSortedUniq.js":"define(['./eq'], function(eq) {\n\n  /**\n   * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without\n   * support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {Function} [iteratee] The iteratee invoked per element.\n   * @returns {Array} Returns the new duplicate free array.\n   */\n  function baseSortedUniq(array, iteratee) {\n    var index = -1,\n        length = array.length,\n        resIndex = 0,\n        result = [];\n\n    while (++index < length) {\n      var value = array[index],\n          computed = iteratee ? iteratee(value) : value;\n\n      if (!index || !eq(computed, seen)) {\n        var seen = computed;\n        result[resIndex++] = value === 0 ? 0 : value;\n      }\n    }\n    return result;\n  }\n\n  return baseSortedUniq;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseSum.js":"define([], function() {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /**\n   * The base implementation of `_.sum` and `_.sumBy` without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {number} Returns the sum.\n   */\n  function baseSum(array, iteratee) {\n    var result,\n        index = -1,\n        length = array.length;\n\n    while (++index < length) {\n      var current = iteratee(array[index]);\n      if (current !== undefined) {\n        result = result === undefined ? current : (result + current);\n      }\n    }\n    return result;\n  }\n\n  return baseSum;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseTimes.js":"define([], function() {\n\n  /**\n   * The base implementation of `_.times` without support for iteratee shorthands\n   * or max array length checks.\n   *\n   * @private\n   * @param {number} n The number of times to invoke `iteratee`.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the array of results.\n   */\n  function baseTimes(n, iteratee) {\n    var index = -1,\n        result = Array(n);\n\n    while (++index < n) {\n      result[index] = iteratee(index);\n    }\n    return result;\n  }\n\n  return baseTimes;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseToNumber.js":"define(['./isSymbol'], function(isSymbol) {\n\n  /** Used as references for various `Number` constants. */\n  var NAN = 0 / 0;\n\n  /**\n   * The base implementation of `_.toNumber` which doesn't ensure correct\n   * conversions of binary, hexadecimal, or octal string values.\n   *\n   * @private\n   * @param {*} value The value to process.\n   * @returns {number} Returns the number.\n   */\n  function baseToNumber(value) {\n    if (typeof value == 'number') {\n      return value;\n    }\n    if (isSymbol(value)) {\n      return NAN;\n    }\n    return +value;\n  }\n\n  return baseToNumber;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseToPairs.js":"define(['./_arrayMap'], function(arrayMap) {\n\n  /**\n   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array\n   * of key-value pairs for `object` corresponding to the property names of `props`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array} props The property names to get values for.\n   * @returns {Object} Returns the key-value pairs.\n   */\n  function baseToPairs(object, props) {\n    return arrayMap(props, function(key) {\n      return [key, object[key]];\n    });\n  }\n\n  return baseToPairs;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseToString.js":"define(['./_Symbol', './_arrayMap', './isArray', './isSymbol'], function(Symbol, arrayMap, isArray, isSymbol) {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /** Used as references for various `Number` constants. */\n  var INFINITY = 1 / 0;\n\n  /** Used to convert symbols to primitives and strings. */\n  var symbolProto = Symbol ? Symbol.prototype : undefined,\n      symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n  /**\n   * The base implementation of `_.toString` which doesn't convert nullish\n   * values to empty strings.\n   *\n   * @private\n   * @param {*} value The value to process.\n   * @returns {string} Returns the string.\n   */\n  function baseToString(value) {\n    // Exit early for strings to avoid a performance hit in some environments.\n    if (typeof value == 'string') {\n      return value;\n    }\n    if (isArray(value)) {\n      // Recursively convert values (susceptible to call stack limits).\n      return arrayMap(value, baseToString) + '';\n    }\n    if (isSymbol(value)) {\n      return symbolToString ? symbolToString.call(value) : '';\n    }\n    var result = (value + '');\n    return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n  }\n\n  return baseToString;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseUnary.js":"define([], function() {\n\n  /**\n   * The base implementation of `_.unary` without support for storing metadata.\n   *\n   * @private\n   * @param {Function} func The function to cap arguments for.\n   * @returns {Function} Returns the new capped function.\n   */\n  function baseUnary(func) {\n    return function(value) {\n      return func(value);\n    };\n  }\n\n  return baseUnary;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseUniq.js":"define(['./_SetCache', './_arrayIncludes', './_arrayIncludesWith', './_cacheHas', './_createSet', './_setToArray'], function(SetCache, arrayIncludes, arrayIncludesWith, cacheHas, createSet, setToArray) {\n\n  /** Used as the size to enable large array optimizations. */\n  var LARGE_ARRAY_SIZE = 200;\n\n  /**\n   * The base implementation of `_.uniqBy` without support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {Function} [iteratee] The iteratee invoked per element.\n   * @param {Function} [comparator] The comparator invoked per element.\n   * @returns {Array} Returns the new duplicate free array.\n   */\n  function baseUniq(array, iteratee, comparator) {\n    var index = -1,\n        includes = arrayIncludes,\n        length = array.length,\n        isCommon = true,\n        result = [],\n        seen = result;\n\n    if (comparator) {\n      isCommon = false;\n      includes = arrayIncludesWith;\n    }\n    else if (length >= LARGE_ARRAY_SIZE) {\n      var set = iteratee ? null : createSet(array);\n      if (set) {\n        return setToArray(set);\n      }\n      isCommon = false;\n      includes = cacheHas;\n      seen = new SetCache;\n    }\n    else {\n      seen = iteratee ? [] : result;\n    }\n    outer:\n    while (++index < length) {\n      var value = array[index],\n          computed = iteratee ? iteratee(value) : value;\n\n      value = (comparator || value !== 0) ? value : 0;\n      if (isCommon && computed === computed) {\n        var seenIndex = seen.length;\n        while (seenIndex--) {\n          if (seen[seenIndex] === computed) {\n            continue outer;\n          }\n        }\n        if (iteratee) {\n          seen.push(computed);\n        }\n        result.push(value);\n      }\n      else if (!includes(seen, computed, comparator)) {\n        if (seen !== result) {\n          seen.push(computed);\n        }\n        result.push(value);\n      }\n    }\n    return result;\n  }\n\n  return baseUniq;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseUnset.js":"define(['./_castPath', './_isKey', './last', './_parent', './_toKey'], function(castPath, isKey, last, parent, toKey) {\n\n  /** Used for built-in method references. */\n  var objectProto = Object.prototype;\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty = objectProto.hasOwnProperty;\n\n  /**\n   * The base implementation of `_.unset`.\n   *\n   * @private\n   * @param {Object} object The object to modify.\n   * @param {Array|string} path The path of the property to unset.\n   * @returns {boolean} Returns `true` if the property is deleted, else `false`.\n   */\n  function baseUnset(object, path) {\n    path = isKey(path, object) ? [path] : castPath(path);\n    object = parent(object, path);\n\n    var key = toKey(last(path));\n    return !(object != null && hasOwnProperty.call(object, key)) || delete object[key];\n  }\n\n  return baseUnset;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseUpdate.js":"define(['./_baseGet', './_baseSet'], function(baseGet, baseSet) {\n\n  /**\n   * The base implementation of `_.update`.\n   *\n   * @private\n   * @param {Object} object The object to modify.\n   * @param {Array|string} path The path of the property to update.\n   * @param {Function} updater The function to produce the updated value.\n   * @param {Function} [customizer] The function to customize path creation.\n   * @returns {Object} Returns `object`.\n   */\n  function baseUpdate(object, path, updater, customizer) {\n    return baseSet(object, path, updater(baseGet(object, path)), customizer);\n  }\n\n  return baseUpdate;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseValues.js":"define(['./_arrayMap'], function(arrayMap) {\n\n  /**\n   * The base implementation of `_.values` and `_.valuesIn` which creates an\n   * array of `object` property values corresponding to the property names\n   * of `props`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array} props The property names to get values for.\n   * @returns {Object} Returns the array of property values.\n   */\n  function baseValues(object, props) {\n    return arrayMap(props, function(key) {\n      return object[key];\n    });\n  }\n\n  return baseValues;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseWhile.js":"define(['./_baseSlice'], function(baseSlice) {\n\n  /**\n   * The base implementation of methods like `_.dropWhile` and `_.takeWhile`\n   * without support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to query.\n   * @param {Function} predicate The function invoked per iteration.\n   * @param {boolean} [isDrop] Specify dropping elements instead of taking them.\n   * @param {boolean} [fromRight] Specify iterating from right to left.\n   * @returns {Array} Returns the slice of `array`.\n   */\n  function baseWhile(array, predicate, isDrop, fromRight) {\n    var length = array.length,\n        index = fromRight ? length : -1;\n\n    while ((fromRight ? index-- : ++index < length) &&\n      predicate(array[index], index, array)) {}\n\n    return isDrop\n      ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))\n      : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));\n  }\n\n  return baseWhile;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseWrapperValue.js":"define(['./_LazyWrapper', './_arrayPush', './_arrayReduce'], function(LazyWrapper, arrayPush, arrayReduce) {\n\n  /**\n   * The base implementation of `wrapperValue` which returns the result of\n   * performing a sequence of actions on the unwrapped `value`, where each\n   * successive action is supplied the return value of the previous.\n   *\n   * @private\n   * @param {*} value The unwrapped value.\n   * @param {Array} actions Actions to perform to resolve the unwrapped value.\n   * @returns {*} Returns the resolved value.\n   */\n  function baseWrapperValue(value, actions) {\n    var result = value;\n    if (result instanceof LazyWrapper) {\n      result = result.value();\n    }\n    return arrayReduce(actions, function(result, action) {\n      return action.func.apply(action.thisArg, arrayPush([result], action.args));\n    }, result);\n  }\n\n  return baseWrapperValue;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseXor.js":"define(['./_arrayPush', './_baseDifference', './_baseUniq'], function(arrayPush, baseDifference, baseUniq) {\n\n  /**\n   * The base implementation of methods like `_.xor`, without support for\n   * iteratee shorthands, that accepts an array of arrays to inspect.\n   *\n   * @private\n   * @param {Array} arrays The arrays to inspect.\n   * @param {Function} [iteratee] The iteratee invoked per element.\n   * @param {Function} [comparator] The comparator invoked per element.\n   * @returns {Array} Returns the new array of values.\n   */\n  function baseXor(arrays, iteratee, comparator) {\n    var index = -1,\n        length = arrays.length;\n\n    while (++index < length) {\n      var result = result\n        ? arrayPush(\n            baseDifference(result, arrays[index], iteratee, comparator),\n            baseDifference(arrays[index], result, iteratee, comparator)\n          )\n        : arrays[index];\n    }\n    return (result && result.length) ? baseUniq(result, iteratee, comparator) : [];\n  }\n\n  return baseXor;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_baseZipObject.js":"define([], function() {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /**\n   * This base implementation of `_.zipObject` which assigns values using `assignFunc`.\n   *\n   * @private\n   * @param {Array} props The property identifiers.\n   * @param {Array} values The property values.\n   * @param {Function} assignFunc The function to assign values.\n   * @returns {Object} Returns the new object.\n   */\n  function baseZipObject(props, values, assignFunc) {\n    var index = -1,\n        length = props.length,\n        valsLength = values.length,\n        result = {};\n\n    while (++index < length) {\n      var value = index < valsLength ? values[index] : undefined;\n      assignFunc(result, props[index], value);\n    }\n    return result;\n  }\n\n  return baseZipObject;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/before.js":"define(['./toInteger'], function(toInteger) {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /** Error message constants. */\n  var FUNC_ERROR_TEXT = 'Expected a function';\n\n  /**\n   * Creates a function that invokes `func`, with the `this` binding and arguments\n   * of the created function, while it's called less than `n` times. Subsequent\n   * calls to the created function return the result of the last `func` invocation.\n   *\n   * @static\n   * @memberOf _\n   * @since 3.0.0\n   * @category Function\n   * @param {number} n The number of calls at which `func` is no longer invoked.\n   * @param {Function} func The function to restrict.\n   * @returns {Function} Returns the new restricted function.\n   * @example\n   *\n   * jQuery(element).on('click', _.before(5, addContactToList));\n   * // => Allows adding up to 4 contacts to the list.\n   */\n  function before(n, func) {\n    var result;\n    if (typeof func != 'function') {\n      throw new TypeError(FUNC_ERROR_TEXT);\n    }\n    n = toInteger(n);\n    return function() {\n      if (--n > 0) {\n        result = func.apply(this, arguments);\n      }\n      if (n <= 1) {\n        func = undefined;\n      }\n      return result;\n    };\n  }\n\n  return before;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/bindAll.js":"define(['./_arrayEach', './_baseAssignValue', './bind', './_flatRest', './_toKey'], function(arrayEach, baseAssignValue, bind, flatRest, toKey) {\n\n  /**\n   * Binds methods of an object to the object itself, overwriting the existing\n   * method.\n   *\n   * **Note:** This method doesn't set the \"length\" property of bound functions.\n   *\n   * @static\n   * @since 0.1.0\n   * @memberOf _\n   * @category Util\n   * @param {Object} object The object to bind and assign the bound methods to.\n   * @param {...(string|string[])} methodNames The object method names to bind.\n   * @returns {Object} Returns `object`.\n   * @example\n   *\n   * var view = {\n   *   'label': 'docs',\n   *   'click': function() {\n   *     console.log('clicked ' + this.label);\n   *   }\n   * };\n   *\n   * _.bindAll(view, ['click']);\n   * jQuery(element).on('click', view.click);\n   * // => Logs 'clicked docs' when clicked.\n   */\n  var bindAll = flatRest(function(object, methodNames) {\n    arrayEach(methodNames, function(key) {\n      key = toKey(key);\n      baseAssignValue(object, key, bind(object[key], object));\n    });\n    return object;\n  });\n\n  return bindAll;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/bind.js":"define(['./_baseRest', './_createWrap', './_getHolder', './_replaceHolders'], function(baseRest, createWrap, getHolder, replaceHolders) {\n\n  /** Used to compose bitmasks for function metadata. */\n  var BIND_FLAG = 1,\n      PARTIAL_FLAG = 32;\n\n  /**\n   * Creates a function that invokes `func` with the `this` binding of `thisArg`\n   * and `partials` prepended to the arguments it receives.\n   *\n   * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,\n   * may be used as a placeholder for partially applied arguments.\n   *\n   * **Note:** Unlike native `Function#bind`, this method doesn't set the \"length\"\n   * property of bound functions.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Function\n   * @param {Function} func The function to bind.\n   * @param {*} thisArg The `this` binding of `func`.\n   * @param {...*} [partials] The arguments to be partially applied.\n   * @returns {Function} Returns the new bound function.\n   * @example\n   *\n   * function greet(greeting, punctuation) {\n   *   return greeting + ' ' + this.user + punctuation;\n   * }\n   *\n   * var object = { 'user': 'fred' };\n   *\n   * var bound = _.bind(greet, object, 'hi');\n   * bound('!');\n   * // => 'hi fred!'\n   *\n   * // Bound with placeholders.\n   * var bound = _.bind(greet, object, _, '!');\n   * bound('hi');\n   * // => 'hi fred!'\n   */\n  var bind = baseRest(function(func, thisArg, partials) {\n    var bitmask = BIND_FLAG;\n    if (partials.length) {\n      var holders = replaceHolders(partials, getHolder(bind));\n      bitmask |= PARTIAL_FLAG;\n    }\n    return createWrap(func, bitmask, thisArg, partials, holders);\n  });\n\n  // Assign default placeholders.\n  bind.placeholder = {};\n\n  return bind;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/bindKey.js":"define(['./_baseRest', './_createWrap', './_getHolder', './_replaceHolders'], function(baseRest, createWrap, getHolder, replaceHolders) {\n\n  /** Used to compose bitmasks for function metadata. */\n  var BIND_FLAG = 1,\n      BIND_KEY_FLAG = 2,\n      PARTIAL_FLAG = 32;\n\n  /**\n   * Creates a function that invokes the method at `object[key]` with `partials`\n   * prepended to the arguments it receives.\n   *\n   * This method differs from `_.bind` by allowing bound functions to reference\n   * methods that may be redefined or don't yet exist. See\n   * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)\n   * for more details.\n   *\n   * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic\n   * builds, may be used as a placeholder for partially applied arguments.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.10.0\n   * @category Function\n   * @param {Object} object The object to invoke the method on.\n   * @param {string} key The key of the method.\n   * @param {...*} [partials] The arguments to be partially applied.\n   * @returns {Function} Returns the new bound function.\n   * @example\n   *\n   * var object = {\n   *   'user': 'fred',\n   *   'greet': function(greeting, punctuation) {\n   *     return greeting + ' ' + this.user + punctuation;\n   *   }\n   * };\n   *\n   * var bound = _.bindKey(object, 'greet', 'hi');\n   * bound('!');\n   * // => 'hi fred!'\n   *\n   * object.greet = function(greeting, punctuation) {\n   *   return greeting + 'ya ' + this.user + punctuation;\n   * };\n   *\n   * bound('!');\n   * // => 'hiya fred!'\n   *\n   * // Bound with placeholders.\n   * var bound = _.bindKey(object, 'greet', _, '!');\n   * bound('hi');\n   * // => 'hiya fred!'\n   */\n  var bindKey = baseRest(function(object, key, partials) {\n    var bitmask = BIND_FLAG | BIND_KEY_FLAG;\n    if (partials.length) {\n      var holders = replaceHolders(partials, getHolder(bindKey));\n      bitmask |= PARTIAL_FLAG;\n    }\n    return createWrap(key, bitmask, object, partials, holders);\n  });\n\n  // Assign default placeholders.\n  bindKey.placeholder = {};\n\n  return bindKey;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_cacheHas.js":"define([], function() {\n\n  /**\n   * Checks if a `cache` value for `key` exists.\n   *\n   * @private\n   * @param {Object} cache The cache to query.\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n  function cacheHas(cache, key) {\n    return cache.has(key);\n  }\n\n  return cacheHas;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/camelCase.js":"define(['./capitalize', './_createCompounder'], function(capitalize, createCompounder) {\n\n  /**\n   * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).\n   *\n   * @static\n   * @memberOf _\n   * @since 3.0.0\n   * @category String\n   * @param {string} [string=''] The string to convert.\n   * @returns {string} Returns the camel cased string.\n   * @example\n   *\n   * _.camelCase('Foo Bar');\n   * // => 'fooBar'\n   *\n   * _.camelCase('--foo-bar--');\n   * // => 'fooBar'\n   *\n   * _.camelCase('__FOO_BAR__');\n   * // => 'fooBar'\n   */\n  var camelCase = createCompounder(function(result, word, index) {\n    word = word.toLowerCase();\n    return result + (index ? capitalize(word) : word);\n  });\n\n  return camelCase;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/capitalize.js":"define(['./toString', './upperFirst'], function(toString, upperFirst) {\n\n  /**\n   * Converts the first character of `string` to upper case and the remaining\n   * to lower case.\n   *\n   * @static\n   * @memberOf _\n   * @since 3.0.0\n   * @category String\n   * @param {string} [string=''] The string to capitalize.\n   * @returns {string} Returns the capitalized string.\n   * @example\n   *\n   * _.capitalize('FRED');\n   * // => 'Fred'\n   */\n  function capitalize(string) {\n    return upperFirst(toString(string).toLowerCase());\n  }\n\n  return capitalize;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/castArray.js":"define(['./isArray'], function(isArray) {\n\n  /**\n   * Casts `value` as an array if it's not one.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.4.0\n   * @category Lang\n   * @param {*} value The value to inspect.\n   * @returns {Array} Returns the cast array.\n   * @example\n   *\n   * _.castArray(1);\n   * // => [1]\n   *\n   * _.castArray({ 'a': 1 });\n   * // => [{ 'a': 1 }]\n   *\n   * _.castArray('abc');\n   * // => ['abc']\n   *\n   * _.castArray(null);\n   * // => [null]\n   *\n   * _.castArray(undefined);\n   * // => [undefined]\n   *\n   * _.castArray();\n   * // => []\n   *\n   * var array = [1, 2, 3];\n   * console.log(_.castArray(array) === array);\n   * // => true\n   */\n  function castArray() {\n    if (!arguments.length) {\n      return [];\n    }\n    var value = arguments[0];\n    return isArray(value) ? value : [value];\n  }\n\n  return castArray;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_castArrayLikeObject.js":"define(['./isArrayLikeObject'], function(isArrayLikeObject) {\n\n  /**\n   * Casts `value` to an empty array if it's not an array like object.\n   *\n   * @private\n   * @param {*} value The value to inspect.\n   * @returns {Array|Object} Returns the cast array-like object.\n   */\n  function castArrayLikeObject(value) {\n    return isArrayLikeObject(value) ? value : [];\n  }\n\n  return castArrayLikeObject;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_castFunction.js":"define(['./identity'], function(identity) {\n\n  /**\n   * Casts `value` to `identity` if it's not a function.\n   *\n   * @private\n   * @param {*} value The value to inspect.\n   * @returns {Function} Returns cast function.\n   */\n  function castFunction(value) {\n    return typeof value == 'function' ? value : identity;\n  }\n\n  return castFunction;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_castPath.js":"define(['./isArray', './_stringToPath'], function(isArray, stringToPath) {\n\n  /**\n   * Casts `value` to a path array if it's not one.\n   *\n   * @private\n   * @param {*} value The value to inspect.\n   * @returns {Array} Returns the cast property path array.\n   */\n  function castPath(value) {\n    return isArray(value) ? value : stringToPath(value);\n  }\n\n  return castPath;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_castRest.js":"define(['./_baseRest'], function(baseRest) {\n\n  /**\n   * A `baseRest` alias which can be replaced with `identity` by module\n   * replacement plugins.\n   *\n   * @private\n   * @type {Function}\n   * @param {Function} func The function to apply a rest parameter to.\n   * @returns {Function} Returns the new function.\n   */\n  var castRest = baseRest;\n\n  return castRest;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_castSlice.js":"define(['./_baseSlice'], function(baseSlice) {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /**\n   * Casts `array` to a slice if it's needed.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {number} start The start position.\n   * @param {number} [end=array.length] The end position.\n   * @returns {Array} Returns the cast slice.\n   */\n  function castSlice(array, start, end) {\n    var length = array.length;\n    end = end === undefined ? length : end;\n    return (!start && end >= length) ? array : baseSlice(array, start, end);\n  }\n\n  return castSlice;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/ceil.js":"define(['./_createRound'], function(createRound) {\n\n  /**\n   * Computes `number` rounded up to `precision`.\n   *\n   * @static\n   * @memberOf _\n   * @since 3.10.0\n   * @category Math\n   * @param {number} number The number to round up.\n   * @param {number} [precision=0] The precision to round up to.\n   * @returns {number} Returns the rounded up number.\n   * @example\n   *\n   * _.ceil(4.006);\n   * // => 5\n   *\n   * _.ceil(6.004, 2);\n   * // => 6.01\n   *\n   * _.ceil(6040, -2);\n   * // => 6100\n   */\n  var ceil = createRound('ceil');\n\n  return ceil;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/chain.js":"define(['./wrapperLodash'], function(lodash) {\n\n  /**\n   * Creates a `lodash` wrapper instance that wraps `value` with explicit method\n   * chain sequences enabled. The result of such sequences must be unwrapped\n   * with `_#value`.\n   *\n   * @static\n   * @memberOf _\n   * @since 1.3.0\n   * @category Seq\n   * @param {*} value The value to wrap.\n   * @returns {Object} Returns the new `lodash` wrapper instance.\n   * @example\n   *\n   * var users = [\n   *   { 'user': 'barney',  'age': 36 },\n   *   { 'user': 'fred',    'age': 40 },\n   *   { 'user': 'pebbles', 'age': 1 }\n   * ];\n   *\n   * var youngest = _\n   *   .chain(users)\n   *   .sortBy('age')\n   *   .map(function(o) {\n   *     return o.user + ' is ' + o.age;\n   *   })\n   *   .head()\n   *   .value();\n   * // => 'pebbles is 1'\n   */\n  function chain(value) {\n    var result = lodash(value);\n    result.__chain__ = true;\n    return result;\n  }\n\n  return chain;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_charsEndIndex.js":"define(['./_baseIndexOf'], function(baseIndexOf) {\n\n  /**\n   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol\n   * that is not found in the character symbols.\n   *\n   * @private\n   * @param {Array} strSymbols The string symbols to inspect.\n   * @param {Array} chrSymbols The character symbols to find.\n   * @returns {number} Returns the index of the last unmatched string symbol.\n   */\n  function charsEndIndex(strSymbols, chrSymbols) {\n    var index = strSymbols.length;\n\n    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n    return index;\n  }\n\n  return charsEndIndex;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_charsStartIndex.js":"define(['./_baseIndexOf'], function(baseIndexOf) {\n\n  /**\n   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol\n   * that is not found in the character symbols.\n   *\n   * @private\n   * @param {Array} strSymbols The string symbols to inspect.\n   * @param {Array} chrSymbols The character symbols to find.\n   * @returns {number} Returns the index of the first unmatched string symbol.\n   */\n  function charsStartIndex(strSymbols, chrSymbols) {\n    var index = -1,\n        length = strSymbols.length;\n\n    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n    return index;\n  }\n\n  return charsStartIndex;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/chunk.js":"define(['./_baseSlice', './_isIterateeCall', './toInteger'], function(baseSlice, isIterateeCall, toInteger) {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /* Built-in method references for those with the same name as other `lodash` methods. */\n  var nativeCeil = Math.ceil,\n      nativeMax = Math.max;\n\n  /**\n   * Creates an array of elements split into groups the length of `size`.\n   * If `array` can't be split evenly, the final chunk will be the remaining\n   * elements.\n   *\n   * @static\n   * @memberOf _\n   * @since 3.0.0\n   * @category Array\n   * @param {Array} array The array to process.\n   * @param {number} [size=1] The length of each chunk\n   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n   * @returns {Array} Returns the new array of chunks.\n   * @example\n   *\n   * _.chunk(['a', 'b', 'c', 'd'], 2);\n   * // => [['a', 'b'], ['c', 'd']]\n   *\n   * _.chunk(['a', 'b', 'c', 'd'], 3);\n   * // => [['a', 'b', 'c'], ['d']]\n   */\n  function chunk(array, size, guard) {\n    if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {\n      size = 1;\n    } else {\n      size = nativeMax(toInteger(size), 0);\n    }\n    var length = array ? array.length : 0;\n    if (!length || size < 1) {\n      return [];\n    }\n    var index = 0,\n        resIndex = 0,\n        result = Array(nativeCeil(length / size));\n\n    while (index < length) {\n      result[resIndex++] = baseSlice(array, index, (index += size));\n    }\n    return result;\n  }\n\n  return chunk;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/clamp.js":"define(['./_baseClamp', './toNumber'], function(baseClamp, toNumber) {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /**\n   * Clamps `number` within the inclusive `lower` and `upper` bounds.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Number\n   * @param {number} number The number to clamp.\n   * @param {number} [lower] The lower bound.\n   * @param {number} upper The upper bound.\n   * @returns {number} Returns the clamped number.\n   * @example\n   *\n   * _.clamp(-10, -5, 5);\n   * // => -5\n   *\n   * _.clamp(10, -5, 5);\n   * // => 5\n   */\n  function clamp(number, lower, upper) {\n    if (upper === undefined) {\n      upper = lower;\n      lower = undefined;\n    }\n    if (upper !== undefined) {\n      upper = toNumber(upper);\n      upper = upper === upper ? upper : 0;\n    }\n    if (lower !== undefined) {\n      lower = toNumber(lower);\n      lower = lower === lower ? lower : 0;\n    }\n    return baseClamp(toNumber(number), lower, upper);\n  }\n\n  return clamp;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_cloneArrayBuffer.js":"define(['./_Uint8Array'], function(Uint8Array) {\n\n  /**\n   * Creates a clone of `arrayBuffer`.\n   *\n   * @private\n   * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n   * @returns {ArrayBuffer} Returns the cloned array buffer.\n   */\n  function cloneArrayBuffer(arrayBuffer) {\n    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n    new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n    return result;\n  }\n\n  return cloneArrayBuffer;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_cloneBuffer.js":"define(['./_root'], function(root) {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /** Detect free variable `exports`. */\n  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n  /** Detect free variable `module`. */\n  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n  /** Detect the popular CommonJS extension `module.exports`. */\n  var moduleExports = freeModule && freeModule.exports === freeExports;\n\n  /** Built-in value references. */\n  var Buffer = moduleExports ? root.Buffer : undefined,\n      allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;\n\n  /**\n   * Creates a clone of  `buffer`.\n   *\n   * @private\n   * @param {Buffer} buffer The buffer to clone.\n   * @param {boolean} [isDeep] Specify a deep clone.\n   * @returns {Buffer} Returns the cloned buffer.\n   */\n  function cloneBuffer(buffer, isDeep) {\n    if (isDeep) {\n      return buffer.slice();\n    }\n    var length = buffer.length,\n        result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n\n    buffer.copy(result);\n    return result;\n  }\n\n  return cloneBuffer;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_cloneDataView.js":"define(['./_cloneArrayBuffer'], function(cloneArrayBuffer) {\n\n  /**\n   * Creates a clone of `dataView`.\n   *\n   * @private\n   * @param {Object} dataView The data view to clone.\n   * @param {boolean} [isDeep] Specify a deep clone.\n   * @returns {Object} Returns the cloned data view.\n   */\n  function cloneDataView(dataView, isDeep) {\n    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n  }\n\n  return cloneDataView;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/cloneDeep.js":"define(['./_baseClone'], function(baseClone) {\n\n  /**\n   * This method is like `_.clone` except that it recursively clones `value`.\n   *\n   * @static\n   * @memberOf _\n   * @since 1.0.0\n   * @category Lang\n   * @param {*} value The value to recursively clone.\n   * @returns {*} Returns the deep cloned value.\n   * @see _.clone\n   * @example\n   *\n   * var objects = [{ 'a': 1 }, { 'b': 2 }];\n   *\n   * var deep = _.cloneDeep(objects);\n   * console.log(deep[0] === objects[0]);\n   * // => false\n   */\n  function cloneDeep(value) {\n    return baseClone(value, true, true);\n  }\n\n  return cloneDeep;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/cloneDeepWith.js":"define(['./_baseClone'], function(baseClone) {\n\n  /**\n   * This method is like `_.cloneWith` except that it recursively clones `value`.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to recursively clone.\n   * @param {Function} [customizer] The function to customize cloning.\n   * @returns {*} Returns the deep cloned value.\n   * @see _.cloneWith\n   * @example\n   *\n   * function customizer(value) {\n   *   if (_.isElement(value)) {\n   *     return value.cloneNode(true);\n   *   }\n   * }\n   *\n   * var el = _.cloneDeepWith(document.body, customizer);\n   *\n   * console.log(el === document.body);\n   * // => false\n   * console.log(el.nodeName);\n   * // => 'BODY'\n   * console.log(el.childNodes.length);\n   * // => 20\n   */\n  function cloneDeepWith(value, customizer) {\n    return baseClone(value, true, true, customizer);\n  }\n\n  return cloneDeepWith;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/clone.js":"define(['./_baseClone'], function(baseClone) {\n\n  /**\n   * Creates a shallow clone of `value`.\n   *\n   * **Note:** This method is loosely based on the\n   * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)\n   * and supports cloning arrays, array buffers, booleans, date objects, maps,\n   * numbers, `Object` objects, regexes, sets, strings, symbols, and typed\n   * arrays. The own enumerable properties of `arguments` objects are cloned\n   * as plain objects. An empty object is returned for uncloneable values such\n   * as error objects, functions, DOM nodes, and WeakMaps.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to clone.\n   * @returns {*} Returns the cloned value.\n   * @see _.cloneDeep\n   * @example\n   *\n   * var objects = [{ 'a': 1 }, { 'b': 2 }];\n   *\n   * var shallow = _.clone(objects);\n   * console.log(shallow[0] === objects[0]);\n   * // => true\n   */\n  function clone(value) {\n    return baseClone(value, false, true);\n  }\n\n  return clone;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_cloneMap.js":"define(['./_addMapEntry', './_arrayReduce', './_mapToArray'], function(addMapEntry, arrayReduce, mapToArray) {\n\n  /**\n   * Creates a clone of `map`.\n   *\n   * @private\n   * @param {Object} map The map to clone.\n   * @param {Function} cloneFunc The function to clone values.\n   * @param {boolean} [isDeep] Specify a deep clone.\n   * @returns {Object} Returns the cloned map.\n   */\n  function cloneMap(map, isDeep, cloneFunc) {\n    var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);\n    return arrayReduce(array, addMapEntry, new map.constructor);\n  }\n\n  return cloneMap;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_cloneRegExp.js":"define([], function() {\n\n  /** Used to match `RegExp` flags from their coerced string values. */\n  var reFlags = /\\w*$/;\n\n  /**\n   * Creates a clone of `regexp`.\n   *\n   * @private\n   * @param {Object} regexp The regexp to clone.\n   * @returns {Object} Returns the cloned regexp.\n   */\n  function cloneRegExp(regexp) {\n    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n    result.lastIndex = regexp.lastIndex;\n    return result;\n  }\n\n  return cloneRegExp;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_cloneSet.js":"define(['./_addSetEntry', './_arrayReduce', './_setToArray'], function(addSetEntry, arrayReduce, setToArray) {\n\n  /**\n   * Creates a clone of `set`.\n   *\n   * @private\n   * @param {Object} set The set to clone.\n   * @param {Function} cloneFunc The function to clone values.\n   * @param {boolean} [isDeep] Specify a deep clone.\n   * @returns {Object} Returns the cloned set.\n   */\n  function cloneSet(set, isDeep, cloneFunc) {\n    var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);\n    return arrayReduce(array, addSetEntry, new set.constructor);\n  }\n\n  return cloneSet;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_cloneSymbol.js":"define(['./_Symbol'], function(Symbol) {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /** Used to convert symbols to primitives and strings. */\n  var symbolProto = Symbol ? Symbol.prototype : undefined,\n      symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n  /**\n   * Creates a clone of the `symbol` object.\n   *\n   * @private\n   * @param {Object} symbol The symbol object to clone.\n   * @returns {Object} Returns the cloned symbol object.\n   */\n  function cloneSymbol(symbol) {\n    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n  }\n\n  return cloneSymbol;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_cloneTypedArray.js":"define(['./_cloneArrayBuffer'], function(cloneArrayBuffer) {\n\n  /**\n   * Creates a clone of `typedArray`.\n   *\n   * @private\n   * @param {Object} typedArray The typed array to clone.\n   * @param {boolean} [isDeep] Specify a deep clone.\n   * @returns {Object} Returns the cloned typed array.\n   */\n  function cloneTypedArray(typedArray, isDeep) {\n    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n  }\n\n  return cloneTypedArray;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/cloneWith.js":"define(['./_baseClone'], function(baseClone) {\n\n  /**\n   * This method is like `_.clone` except that it accepts `customizer` which\n   * is invoked to produce the cloned value. If `customizer` returns `undefined`,\n   * cloning is handled by the method instead. The `customizer` is invoked with\n   * up to four arguments; (value [, index|key, object, stack]).\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to clone.\n   * @param {Function} [customizer] The function to customize cloning.\n   * @returns {*} Returns the cloned value.\n   * @see _.cloneDeepWith\n   * @example\n   *\n   * function customizer(value) {\n   *   if (_.isElement(value)) {\n   *     return value.cloneNode(false);\n   *   }\n   * }\n   *\n   * var el = _.cloneWith(document.body, customizer);\n   *\n   * console.log(el === document.body);\n   * // => false\n   * console.log(el.nodeName);\n   * // => 'BODY'\n   * console.log(el.childNodes.length);\n   * // => 0\n   */\n  function cloneWith(value, customizer) {\n    return baseClone(value, false, true, customizer);\n  }\n\n  return cloneWith;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/collection.js":"define(['./countBy', './each', './eachRight', './every', './filter', './find', './findLast', './flatMap', './flatMapDeep', './flatMapDepth', './forEach', './forEachRight', './groupBy', './includes', './invokeMap', './keyBy', './map', './orderBy', './partition', './reduce', './reduceRight', './reject', './sample', './sampleSize', './shuffle', './size', './some', './sortBy'], function(countBy, each, eachRight, every, filter, find, findLast, flatMap, flatMapDeep, flatMapDepth, forEach, forEachRight, groupBy, includes, invokeMap, keyBy, map, orderBy, partition, reduce, reduceRight, reject, sample, sampleSize, shuffle, size, some, sortBy) {\n  return {\n    'countBy': countBy,\n    'each': each,\n    'eachRight': eachRight,\n    'every': every,\n    'filter': filter,\n    'find': find,\n    'findLast': findLast,\n    'flatMap': flatMap,\n    'flatMapDeep': flatMapDeep,\n    'flatMapDepth': flatMapDepth,\n    'forEach': forEach,\n    'forEachRight': forEachRight,\n    'groupBy': groupBy,\n    'includes': includes,\n    'invokeMap': invokeMap,\n    'keyBy': keyBy,\n    'map': map,\n    'orderBy': orderBy,\n    'partition': partition,\n    'reduce': reduce,\n    'reduceRight': reduceRight,\n    'reject': reject,\n    'sample': sample,\n    'sampleSize': sampleSize,\n    'shuffle': shuffle,\n    'size': size,\n    'some': some,\n    'sortBy': sortBy\n  };\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/commit.js":"define(['./_LodashWrapper'], function(LodashWrapper) {\n\n  /**\n   * Executes the chain sequence and returns the wrapped result.\n   *\n   * @name commit\n   * @memberOf _\n   * @since 3.2.0\n   * @category Seq\n   * @returns {Object} Returns the new `lodash` wrapper instance.\n   * @example\n   *\n   * var array = [1, 2];\n   * var wrapped = _(array).push(3);\n   *\n   * console.log(array);\n   * // => [1, 2]\n   *\n   * wrapped = wrapped.commit();\n   * console.log(array);\n   * // => [1, 2, 3]\n   *\n   * wrapped.last();\n   * // => 3\n   *\n   * console.log(array);\n   * // => [1, 2, 3]\n   */\n  function wrapperCommit() {\n    return new LodashWrapper(this.value(), this.__chain__);\n  }\n\n  return wrapperCommit;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/compact.js":"define([], function() {\n\n  /**\n   * Creates an array with all falsey values removed. The values `false`, `null`,\n   * `0`, `\"\"`, `undefined`, and `NaN` are falsey.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Array\n   * @param {Array} array The array to compact.\n   * @returns {Array} Returns the new array of filtered values.\n   * @example\n   *\n   * _.compact([0, 1, false, 2, '', 3]);\n   * // => [1, 2, 3]\n   */\n  function compact(array) {\n    var index = -1,\n        length = array ? array.length : 0,\n        resIndex = 0,\n        result = [];\n\n    while (++index < length) {\n      var value = array[index];\n      if (value) {\n        result[resIndex++] = value;\n      }\n    }\n    return result;\n  }\n\n  return compact;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_compareAscending.js":"define(['./isSymbol'], function(isSymbol) {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /**\n   * Compares values to sort them in ascending order.\n   *\n   * @private\n   * @param {*} value The value to compare.\n   * @param {*} other The other value to compare.\n   * @returns {number} Returns the sort order indicator for `value`.\n   */\n  function compareAscending(value, other) {\n    if (value !== other) {\n      var valIsDefined = value !== undefined,\n          valIsNull = value === null,\n          valIsReflexive = value === value,\n          valIsSymbol = isSymbol(value);\n\n      var othIsDefined = other !== undefined,\n          othIsNull = other === null,\n          othIsReflexive = other === other,\n          othIsSymbol = isSymbol(other);\n\n      if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||\n          (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||\n          (valIsNull && othIsDefined && othIsReflexive) ||\n          (!valIsDefined && othIsReflexive) ||\n          !valIsReflexive) {\n        return 1;\n      }\n      if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||\n          (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||\n          (othIsNull && valIsDefined && valIsReflexive) ||\n          (!othIsDefined && valIsReflexive) ||\n          !othIsReflexive) {\n        return -1;\n      }\n    }\n    return 0;\n  }\n\n  return compareAscending;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_compareMultiple.js":"define(['./_compareAscending'], function(compareAscending) {\n\n  /**\n   * Used by `_.orderBy` to compare multiple properties of a value to another\n   * and stable sort them.\n   *\n   * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,\n   * specify an order of \"desc\" for descending or \"asc\" for ascending sort order\n   * of corresponding values.\n   *\n   * @private\n   * @param {Object} object The object to compare.\n   * @param {Object} other The other object to compare.\n   * @param {boolean[]|string[]} orders The order to sort by for each property.\n   * @returns {number} Returns the sort order indicator for `object`.\n   */\n  function compareMultiple(object, other, orders) {\n    var index = -1,\n        objCriteria = object.criteria,\n        othCriteria = other.criteria,\n        length = objCriteria.length,\n        ordersLength = orders.length;\n\n    while (++index < length) {\n      var result = compareAscending(objCriteria[index], othCriteria[index]);\n      if (result) {\n        if (index >= ordersLength) {\n          return result;\n        }\n        var order = orders[index];\n        return result * (order == 'desc' ? -1 : 1);\n      }\n    }\n    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\n    // that causes it, under certain circumstances, to provide the same value for\n    // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247\n    // for more details.\n    //\n    // This also ensures a stable sort in V8 and other engines.\n    // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.\n    return object.index - other.index;\n  }\n\n  return compareMultiple;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_composeArgs.js":"define([], function() {\n\n  /* Built-in method references for those with the same name as other `lodash` methods. */\n  var nativeMax = Math.max;\n\n  /**\n   * Creates an array that is the composition of partially applied arguments,\n   * placeholders, and provided arguments into a single array of arguments.\n   *\n   * @private\n   * @param {Array} args The provided arguments.\n   * @param {Array} partials The arguments to prepend to those provided.\n   * @param {Array} holders The `partials` placeholder indexes.\n   * @params {boolean} [isCurried] Specify composing for a curried function.\n   * @returns {Array} Returns the new array of composed arguments.\n   */\n  function composeArgs(args, partials, holders, isCurried) {\n    var argsIndex = -1,\n        argsLength = args.length,\n        holdersLength = holders.length,\n        leftIndex = -1,\n        leftLength = partials.length,\n        rangeLength = nativeMax(argsLength - holdersLength, 0),\n        result = Array(leftLength + rangeLength),\n        isUncurried = !isCurried;\n\n    while (++leftIndex < leftLength) {\n      result[leftIndex] = partials[leftIndex];\n    }\n    while (++argsIndex < holdersLength) {\n      if (isUncurried || argsIndex < argsLength) {\n        result[holders[argsIndex]] = args[argsIndex];\n      }\n    }\n    while (rangeLength--) {\n      result[leftIndex++] = args[argsIndex++];\n    }\n    return result;\n  }\n\n  return composeArgs;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_composeArgsRight.js":"define([], function() {\n\n  /* Built-in method references for those with the same name as other `lodash` methods. */\n  var nativeMax = Math.max;\n\n  /**\n   * This function is like `composeArgs` except that the arguments composition\n   * is tailored for `_.partialRight`.\n   *\n   * @private\n   * @param {Array} args The provided arguments.\n   * @param {Array} partials The arguments to append to those provided.\n   * @param {Array} holders The `partials` placeholder indexes.\n   * @params {boolean} [isCurried] Specify composing for a curried function.\n   * @returns {Array} Returns the new array of composed arguments.\n   */\n  function composeArgsRight(args, partials, holders, isCurried) {\n    var argsIndex = -1,\n        argsLength = args.length,\n        holdersIndex = -1,\n        holdersLength = holders.length,\n        rightIndex = -1,\n        rightLength = partials.length,\n        rangeLength = nativeMax(argsLength - holdersLength, 0),\n        result = Array(rangeLength + rightLength),\n        isUncurried = !isCurried;\n\n    while (++argsIndex < rangeLength) {\n      result[argsIndex] = args[argsIndex];\n    }\n    var offset = argsIndex;\n    while (++rightIndex < rightLength) {\n      result[offset + rightIndex] = partials[rightIndex];\n    }\n    while (++holdersIndex < holdersLength) {\n      if (isUncurried || argsIndex < argsLength) {\n        result[offset + holders[holdersIndex]] = args[argsIndex++];\n      }\n    }\n    return result;\n  }\n\n  return composeArgsRight;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/concat.js":"define(['./_arrayPush', './_baseFlatten', './_copyArray', './isArray'], function(arrayPush, baseFlatten, copyArray, isArray) {\n\n  /**\n   * Creates a new array concatenating `array` with any additional arrays\n   * and/or values.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Array\n   * @param {Array} array The array to concatenate.\n   * @param {...*} [values] The values to concatenate.\n   * @returns {Array} Returns the new concatenated array.\n   * @example\n   *\n   * var array = [1];\n   * var other = _.concat(array, 2, [3], [[4]]);\n   *\n   * console.log(other);\n   * // => [1, 2, 3, [4]]\n   *\n   * console.log(array);\n   * // => [1]\n   */\n  function concat() {\n    var length = arguments.length;\n    if (!length) {\n      return [];\n    }\n    var args = Array(length - 1),\n        array = arguments[0],\n        index = length;\n\n    while (index--) {\n      args[index - 1] = arguments[index];\n    }\n    return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));\n  }\n\n  return concat;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/cond.js":"define(['./_apply', './_arrayMap', './_baseIteratee', './_baseRest'], function(apply, arrayMap, baseIteratee, baseRest) {\n\n  /** Error message constants. */\n  var FUNC_ERROR_TEXT = 'Expected a function';\n\n  /**\n   * Creates a function that iterates over `pairs` and invokes the corresponding\n   * function of the first predicate to return truthy. The predicate-function\n   * pairs are invoked with the `this` binding and arguments of the created\n   * function.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Util\n   * @param {Array} pairs The predicate-function pairs.\n   * @returns {Function} Returns the new composite function.\n   * @example\n   *\n   * var func = _.cond([\n   *   [_.matches({ 'a': 1 }),           _.constant('matches A')],\n   *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],\n   *   [_.stubTrue,                      _.constant('no match')]\n   * ]);\n   *\n   * func({ 'a': 1, 'b': 2 });\n   * // => 'matches A'\n   *\n   * func({ 'a': 0, 'b': 1 });\n   * // => 'matches B'\n   *\n   * func({ 'a': '1', 'b': '2' });\n   * // => 'no match'\n   */\n  function cond(pairs) {\n    var length = pairs ? pairs.length : 0,\n        toIteratee = baseIteratee;\n\n    pairs = !length ? [] : arrayMap(pairs, function(pair) {\n      if (typeof pair[1] != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      return [toIteratee(pair[0]), pair[1]];\n    });\n\n    return baseRest(function(args) {\n      var index = -1;\n      while (++index < length) {\n        var pair = pairs[index];\n        if (apply(pair[0], this, args)) {\n          return apply(pair[1], this, args);\n        }\n      }\n    });\n  }\n\n  return cond;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/conforms.js":"define(['./_baseClone', './_baseConforms'], function(baseClone, baseConforms) {\n\n  /**\n   * Creates a function that invokes the predicate properties of `source` with\n   * the corresponding property values of a given object, returning `true` if\n   * all predicates return truthy, else `false`.\n   *\n   * **Note:** The created function is equivalent to `_.conformsTo` with\n   * `source` partially applied.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Util\n   * @param {Object} source The object of property predicates to conform to.\n   * @returns {Function} Returns the new spec function.\n   * @example\n   *\n   * var objects = [\n   *   { 'a': 2, 'b': 1 },\n   *   { 'a': 1, 'b': 2 }\n   * ];\n   *\n   * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));\n   * // => [{ 'a': 1, 'b': 2 }]\n   */\n  function conforms(source) {\n    return baseConforms(baseClone(source, true));\n  }\n\n  return conforms;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/conformsTo.js":"define(['./_baseConformsTo', './keys'], function(baseConformsTo, keys) {\n\n  /**\n   * Checks if `object` conforms to `source` by invoking the predicate\n   * properties of `source` with the corresponding property values of `object`.\n   *\n   * **Note:** This method is equivalent to `_.conforms` when `source` is\n   * partially applied.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.14.0\n   * @category Lang\n   * @param {Object} object The object to inspect.\n   * @param {Object} source The object of property predicates to conform to.\n   * @returns {boolean} Returns `true` if `object` conforms, else `false`.\n   * @example\n   *\n   * var object = { 'a': 1, 'b': 2 };\n   *\n   * _.conformsTo(object, { 'b': function(n) { return n > 1; } });\n   * // => true\n   *\n   * _.conformsTo(object, { 'b': function(n) { return n > 2; } });\n   * // => false\n   */\n  function conformsTo(object, source) {\n    return source == null || baseConformsTo(object, source, keys(source));\n  }\n\n  return conformsTo;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/constant.js":"define([], function() {\n\n  /**\n   * Creates a function that returns `value`.\n   *\n   * @static\n   * @memberOf _\n   * @since 2.4.0\n   * @category Util\n   * @param {*} value The value to return from the new function.\n   * @returns {Function} Returns the new constant function.\n   * @example\n   *\n   * var objects = _.times(2, _.constant({ 'a': 1 }));\n   *\n   * console.log(objects);\n   * // => [{ 'a': 1 }, { 'a': 1 }]\n   *\n   * console.log(objects[0] === objects[1]);\n   * // => true\n   */\n  function constant(value) {\n    return function() {\n      return value;\n    };\n  }\n\n  return constant;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_copyArray.js":"define([], function() {\n\n  /**\n   * Copies the values of `source` to `array`.\n   *\n   * @private\n   * @param {Array} source The array to copy values from.\n   * @param {Array} [array=[]] The array to copy values to.\n   * @returns {Array} Returns `array`.\n   */\n  function copyArray(source, array) {\n    var index = -1,\n        length = source.length;\n\n    array || (array = Array(length));\n    while (++index < length) {\n      array[index] = source[index];\n    }\n    return array;\n  }\n\n  return copyArray;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_copyObject.js":"define(['./_assignValue', './_baseAssignValue'], function(assignValue, baseAssignValue) {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /**\n   * Copies properties of `source` to `object`.\n   *\n   * @private\n   * @param {Object} source The object to copy properties from.\n   * @param {Array} props The property identifiers to copy.\n   * @param {Object} [object={}] The object to copy properties to.\n   * @param {Function} [customizer] The function to customize copied values.\n   * @returns {Object} Returns `object`.\n   */\n  function copyObject(source, props, object, customizer) {\n    var isNew = !object;\n    object || (object = {});\n\n    var index = -1,\n        length = props.length;\n\n    while (++index < length) {\n      var key = props[index];\n\n      var newValue = customizer\n        ? customizer(object[key], source[key], key, object, source)\n        : undefined;\n\n      if (newValue === undefined) {\n        newValue = source[key];\n      }\n      if (isNew) {\n        baseAssignValue(object, key, newValue);\n      } else {\n        assignValue(object, key, newValue);\n      }\n    }\n    return object;\n  }\n\n  return copyObject;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_copySymbols.js":"define(['./_copyObject', './_getSymbols'], function(copyObject, getSymbols) {\n\n  /**\n   * Copies own symbol properties of `source` to `object`.\n   *\n   * @private\n   * @param {Object} source The object to copy symbols from.\n   * @param {Object} [object={}] The object to copy symbols to.\n   * @returns {Object} Returns `object`.\n   */\n  function copySymbols(source, object) {\n    return copyObject(source, getSymbols(source), object);\n  }\n\n  return copySymbols;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_coreJsData.js":"define(['./_root'], function(root) {\n\n  /** Used to detect overreaching core-js shims. */\n  var coreJsData = root['__core-js_shared__'];\n\n  return coreJsData;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/countBy.js":"define(['./_baseAssignValue', './_createAggregator'], function(baseAssignValue, createAggregator) {\n\n  /** Used for built-in method references. */\n  var objectProto = Object.prototype;\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty = objectProto.hasOwnProperty;\n\n  /**\n   * Creates an object composed of keys generated from the results of running\n   * each element of `collection` thru `iteratee`. The corresponding value of\n   * each key is the number of times the key was returned by `iteratee`. The\n   * iteratee is invoked with one argument: (value).\n   *\n   * @static\n   * @memberOf _\n   * @since 0.5.0\n   * @category Collection\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} [iteratee=_.identity]\n   *  The iteratee to transform keys.\n   * @returns {Object} Returns the composed aggregate object.\n   * @example\n   *\n   * _.countBy([6.1, 4.2, 6.3], Math.floor);\n   * // => { '4': 1, '6': 2 }\n   *\n   * // The `_.property` iteratee shorthand.\n   * _.countBy(['one', 'two', 'three'], 'length');\n   * // => { '3': 2, '5': 1 }\n   */\n  var countBy = createAggregator(function(result, value, key) {\n    if (hasOwnProperty.call(result, key)) {\n      ++result[key];\n    } else {\n      baseAssignValue(result, key, 1);\n    }\n  });\n\n  return countBy;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_countHolders.js":"define([], function() {\n\n  /**\n   * Gets the number of `placeholder` occurrences in `array`.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} placeholder The placeholder to search for.\n   * @returns {number} Returns the placeholder count.\n   */\n  function countHolders(array, placeholder) {\n    var length = array.length,\n        result = 0;\n\n    while (length--) {\n      if (array[length] === placeholder) {\n        ++result;\n      }\n    }\n    return result;\n  }\n\n  return countHolders;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_createAggregator.js":"define(['./_arrayAggregator', './_baseAggregator', './_baseIteratee', './isArray'], function(arrayAggregator, baseAggregator, baseIteratee, isArray) {\n\n  /**\n   * Creates a function like `_.groupBy`.\n   *\n   * @private\n   * @param {Function} setter The function to set accumulator values.\n   * @param {Function} [initializer] The accumulator object initializer.\n   * @returns {Function} Returns the new aggregator function.\n   */\n  function createAggregator(setter, initializer) {\n    return function(collection, iteratee) {\n      var func = isArray(collection) ? arrayAggregator : baseAggregator,\n          accumulator = initializer ? initializer() : {};\n\n      return func(collection, setter, baseIteratee(iteratee, 2), accumulator);\n    };\n  }\n\n  return createAggregator;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_createAssigner.js":"define(['./_baseRest', './_isIterateeCall'], function(baseRest, isIterateeCall) {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /**\n   * Creates a function like `_.assign`.\n   *\n   * @private\n   * @param {Function} assigner The function to assign values.\n   * @returns {Function} Returns the new assigner function.\n   */\n  function createAssigner(assigner) {\n    return baseRest(function(object, sources) {\n      var index = -1,\n          length = sources.length,\n          customizer = length > 1 ? sources[length - 1] : undefined,\n          guard = length > 2 ? sources[2] : undefined;\n\n      customizer = (assigner.length > 3 && typeof customizer == 'function')\n        ? (length--, customizer)\n        : undefined;\n\n      if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n        customizer = length < 3 ? undefined : customizer;\n        length = 1;\n      }\n      object = Object(object);\n      while (++index < length) {\n        var source = sources[index];\n        if (source) {\n          assigner(object, source, index, customizer);\n        }\n      }\n      return object;\n    });\n  }\n\n  return createAssigner;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_createBaseEach.js":"define(['./isArrayLike'], function(isArrayLike) {\n\n  /**\n   * Creates a `baseEach` or `baseEachRight` function.\n   *\n   * @private\n   * @param {Function} eachFunc The function to iterate over a collection.\n   * @param {boolean} [fromRight] Specify iterating from right to left.\n   * @returns {Function} Returns the new base function.\n   */\n  function createBaseEach(eachFunc, fromRight) {\n    return function(collection, iteratee) {\n      if (collection == null) {\n        return collection;\n      }\n      if (!isArrayLike(collection)) {\n        return eachFunc(collection, iteratee);\n      }\n      var length = collection.length,\n          index = fromRight ? length : -1,\n          iterable = Object(collection);\n\n      while ((fromRight ? index-- : ++index < length)) {\n        if (iteratee(iterable[index], index, iterable) === false) {\n          break;\n        }\n      }\n      return collection;\n    };\n  }\n\n  return createBaseEach;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_createBaseFor.js":"define([], function() {\n\n  /**\n   * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n   *\n   * @private\n   * @param {boolean} [fromRight] Specify iterating from right to left.\n   * @returns {Function} Returns the new base function.\n   */\n  function createBaseFor(fromRight) {\n    return function(object, iteratee, keysFunc) {\n      var index = -1,\n          iterable = Object(object),\n          props = keysFunc(object),\n          length = props.length;\n\n      while (length--) {\n        var key = props[fromRight ? length : ++index];\n        if (iteratee(iterable[key], key, iterable) === false) {\n          break;\n        }\n      }\n      return object;\n    };\n  }\n\n  return createBaseFor;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_createBind.js":"define(['./_createCtor', './_root'], function(createCtor, root) {\n\n  /** Used to compose bitmasks for function metadata. */\n  var BIND_FLAG = 1;\n\n  /**\n   * Creates a function that wraps `func` to invoke it with the optional `this`\n   * binding of `thisArg`.\n   *\n   * @private\n   * @param {Function} func The function to wrap.\n   * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n   * @param {*} [thisArg] The `this` binding of `func`.\n   * @returns {Function} Returns the new wrapped function.\n   */\n  function createBind(func, bitmask, thisArg) {\n    var isBind = bitmask & BIND_FLAG,\n        Ctor = createCtor(func);\n\n    function wrapper() {\n      var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n      return fn.apply(isBind ? thisArg : this, arguments);\n    }\n    return wrapper;\n  }\n\n  return createBind;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_createCaseFirst.js":"define(['./_castSlice', './_hasUnicode', './_stringToArray', './toString'], function(castSlice, hasUnicode, stringToArray, toString) {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /**\n   * Creates a function like `_.lowerFirst`.\n   *\n   * @private\n   * @param {string} methodName The name of the `String` case method to use.\n   * @returns {Function} Returns the new case function.\n   */\n  function createCaseFirst(methodName) {\n    return function(string) {\n      string = toString(string);\n\n      var strSymbols = hasUnicode(string)\n        ? stringToArray(string)\n        : undefined;\n\n      var chr = strSymbols\n        ? strSymbols[0]\n        : string.charAt(0);\n\n      var trailing = strSymbols\n        ? castSlice(strSymbols, 1).join('')\n        : string.slice(1);\n\n      return chr[methodName]() + trailing;\n    };\n  }\n\n  return createCaseFirst;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_createCompounder.js":"define(['./_arrayReduce', './deburr', './words'], function(arrayReduce, deburr, words) {\n\n  /** Used to compose unicode capture groups. */\n  var rsApos = \"['\\u2019]\";\n\n  /** Used to match apostrophes. */\n  var reApos = RegExp(rsApos, 'g');\n\n  /**\n   * Creates a function like `_.camelCase`.\n   *\n   * @private\n   * @param {Function} callback The function to combine each word.\n   * @returns {Function} Returns the new compounder function.\n   */\n  function createCompounder(callback) {\n    return function(string) {\n      return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');\n    };\n  }\n\n  return createCompounder;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_createCtor.js":"define(['./_baseCreate', './isObject'], function(baseCreate, isObject) {\n\n  /**\n   * Creates a function that produces an instance of `Ctor` regardless of\n   * whether it was invoked as part of a `new` expression or by `call` or `apply`.\n   *\n   * @private\n   * @param {Function} Ctor The constructor to wrap.\n   * @returns {Function} Returns the new wrapped function.\n   */\n  function createCtor(Ctor) {\n    return function() {\n      // Use a `switch` statement to work with class constructors. See\n      // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist\n      // for more details.\n      var args = arguments;\n      switch (args.length) {\n        case 0: return new Ctor;\n        case 1: return new Ctor(args[0]);\n        case 2: return new Ctor(args[0], args[1]);\n        case 3: return new Ctor(args[0], args[1], args[2]);\n        case 4: return new Ctor(args[0], args[1], args[2], args[3]);\n        case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);\n        case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);\n        case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);\n      }\n      var thisBinding = baseCreate(Ctor.prototype),\n          result = Ctor.apply(thisBinding, args);\n\n      // Mimic the constructor's `return` behavior.\n      // See https://es5.github.io/#x13.2.2 for more details.\n      return isObject(result) ? result : thisBinding;\n    };\n  }\n\n  return createCtor;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_createCurry.js":"define(['./_apply', './_createCtor', './_createHybrid', './_createRecurry', './_getHolder', './_replaceHolders', './_root'], function(apply, createCtor, createHybrid, createRecurry, getHolder, replaceHolders, root) {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /**\n   * Creates a function that wraps `func` to enable currying.\n   *\n   * @private\n   * @param {Function} func The function to wrap.\n   * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n   * @param {number} arity The arity of `func`.\n   * @returns {Function} Returns the new wrapped function.\n   */\n  function createCurry(func, bitmask, arity) {\n    var Ctor = createCtor(func);\n\n    function wrapper() {\n      var length = arguments.length,\n          args = Array(length),\n          index = length,\n          placeholder = getHolder(wrapper);\n\n      while (index--) {\n        args[index] = arguments[index];\n      }\n      var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)\n        ? []\n        : replaceHolders(args, placeholder);\n\n      length -= holders.length;\n      if (length < arity) {\n        return createRecurry(\n          func, bitmask, createHybrid, wrapper.placeholder, undefined,\n          args, holders, undefined, undefined, arity - length);\n      }\n      var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n      return apply(fn, this, args);\n    }\n    return wrapper;\n  }\n\n  return createCurry;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_createFind.js":"define(['./_baseIteratee', './isArrayLike', './keys'], function(baseIteratee, isArrayLike, keys) {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /**\n   * Creates a `_.find` or `_.findLast` function.\n   *\n   * @private\n   * @param {Function} findIndexFunc The function to find the collection index.\n   * @returns {Function} Returns the new find function.\n   */\n  function createFind(findIndexFunc) {\n    return function(collection, predicate, fromIndex) {\n      var iterable = Object(collection);\n      if (!isArrayLike(collection)) {\n        var iteratee = baseIteratee(predicate, 3);\n        collection = keys(collection);\n        predicate = function(key) { return iteratee(iterable[key], key, iterable); };\n      }\n      var index = findIndexFunc(collection, predicate, fromIndex);\n      return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;\n    };\n  }\n\n  return createFind;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_createFlow.js":"define(['./_LodashWrapper', './_flatRest', './_getData', './_getFuncName', './isArray', './_isLaziable'], function(LodashWrapper, flatRest, getData, getFuncName, isArray, isLaziable) {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /** Used as the size to enable large array optimizations. */\n  var LARGE_ARRAY_SIZE = 200;\n\n  /** Error message constants. */\n  var FUNC_ERROR_TEXT = 'Expected a function';\n\n  /** Used to compose bitmasks for function metadata. */\n  var CURRY_FLAG = 8,\n      PARTIAL_FLAG = 32,\n      ARY_FLAG = 128,\n      REARG_FLAG = 256;\n\n  /**\n   * Creates a `_.flow` or `_.flowRight` function.\n   *\n   * @private\n   * @param {boolean} [fromRight] Specify iterating from right to left.\n   * @returns {Function} Returns the new flow function.\n   */\n  function createFlow(fromRight) {\n    return flatRest(function(funcs) {\n      var length = funcs.length,\n          index = length,\n          prereq = LodashWrapper.prototype.thru;\n\n      if (fromRight) {\n        funcs.reverse();\n      }\n      while (index--) {\n        var func = funcs[index];\n        if (typeof func != 'function') {\n          throw new TypeError(FUNC_ERROR_TEXT);\n        }\n        if (prereq && !wrapper && getFuncName(func) == 'wrapper') {\n          var wrapper = new LodashWrapper([], true);\n        }\n      }\n      index = wrapper ? index : length;\n      while (++index < length) {\n        func = funcs[index];\n\n        var funcName = getFuncName(func),\n            data = funcName == 'wrapper' ? getData(func) : undefined;\n\n        if (data && isLaziable(data[0]) &&\n              data[1] == (ARY_FLAG | CURRY_FLAG | PARTIAL_FLAG | REARG_FLAG) &&\n              !data[4].length && data[9] == 1\n            ) {\n          wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);\n        } else {\n          wrapper = (func.length == 1 && isLaziable(func))\n            ? wrapper[funcName]()\n            : wrapper.thru(func);\n        }\n      }\n      return function() {\n        var args = arguments,\n            value = args[0];\n\n        if (wrapper && args.length == 1 &&\n            isArray(value) && value.length >= LARGE_ARRAY_SIZE) {\n          return wrapper.plant(value).value();\n        }\n        var index = 0,\n            result = length ? funcs[index].apply(this, args) : value;\n\n        while (++index < length) {\n          result = funcs[index].call(this, result);\n        }\n        return result;\n      };\n    });\n  }\n\n  return createFlow;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_createHybrid.js":"define(['./_composeArgs', './_composeArgsRight', './_countHolders', './_createCtor', './_createRecurry', './_getHolder', './_reorder', './_replaceHolders', './_root'], function(composeArgs, composeArgsRight, countHolders, createCtor, createRecurry, getHolder, reorder, replaceHolders, root) {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /** Used to compose bitmasks for function metadata. */\n  var BIND_FLAG = 1,\n      BIND_KEY_FLAG = 2,\n      CURRY_FLAG = 8,\n      CURRY_RIGHT_FLAG = 16,\n      ARY_FLAG = 128,\n      FLIP_FLAG = 512;\n\n  /**\n   * Creates a function that wraps `func` to invoke it with optional `this`\n   * binding of `thisArg`, partial application, and currying.\n   *\n   * @private\n   * @param {Function|string} func The function or method name to wrap.\n   * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n   * @param {*} [thisArg] The `this` binding of `func`.\n   * @param {Array} [partials] The arguments to prepend to those provided to\n   *  the new function.\n   * @param {Array} [holders] The `partials` placeholder indexes.\n   * @param {Array} [partialsRight] The arguments to append to those provided\n   *  to the new function.\n   * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.\n   * @param {Array} [argPos] The argument positions of the new function.\n   * @param {number} [ary] The arity cap of `func`.\n   * @param {number} [arity] The arity of `func`.\n   * @returns {Function} Returns the new wrapped function.\n   */\n  function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {\n    var isAry = bitmask & ARY_FLAG,\n        isBind = bitmask & BIND_FLAG,\n        isBindKey = bitmask & BIND_KEY_FLAG,\n        isCurried = bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG),\n        isFlip = bitmask & FLIP_FLAG,\n        Ctor = isBindKey ? undefined : createCtor(func);\n\n    function wrapper() {\n      var length = arguments.length,\n          args = Array(length),\n          index = length;\n\n      while (index--) {\n        args[index] = arguments[index];\n      }\n      if (isCurried) {\n        var placeholder = getHolder(wrapper),\n            holdersCount = countHolders(args, placeholder);\n      }\n      if (partials) {\n        args = composeArgs(args, partials, holders, isCurried);\n      }\n      if (partialsRight) {\n        args = composeArgsRight(args, partialsRight, holdersRight, isCurried);\n      }\n      length -= holdersCount;\n      if (isCurried && length < arity) {\n        var newHolders = replaceHolders(args, placeholder);\n        return createRecurry(\n          func, bitmask, createHybrid, wrapper.placeholder, thisArg,\n          args, newHolders, argPos, ary, arity - length\n        );\n      }\n      var thisBinding = isBind ? thisArg : this,\n          fn = isBindKey ? thisBinding[func] : func;\n\n      length = args.length;\n      if (argPos) {\n        args = reorder(args, argPos);\n      } else if (isFlip && length > 1) {\n        args.reverse();\n      }\n      if (isAry && ary < length) {\n        args.length = ary;\n      }\n      if (this && this !== root && this instanceof wrapper) {\n        fn = Ctor || createCtor(fn);\n      }\n      return fn.apply(thisBinding, args);\n    }\n    return wrapper;\n  }\n\n  return createHybrid;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_createInverter.js":"define(['./_baseInverter'], function(baseInverter) {\n\n  /**\n   * Creates a function like `_.invertBy`.\n   *\n   * @private\n   * @param {Function} setter The function to set accumulator values.\n   * @param {Function} toIteratee The function to resolve iteratees.\n   * @returns {Function} Returns the new inverter function.\n   */\n  function createInverter(setter, toIteratee) {\n    return function(object, iteratee) {\n      return baseInverter(object, setter, toIteratee(iteratee), {});\n    };\n  }\n\n  return createInverter;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/create.js":"define(['./_baseAssign', './_baseCreate'], function(baseAssign, baseCreate) {\n\n  /**\n   * Creates an object that inherits from the `prototype` object. If a\n   * `properties` object is given, its own enumerable string keyed properties\n   * are assigned to the created object.\n   *\n   * @static\n   * @memberOf _\n   * @since 2.3.0\n   * @category Object\n   * @param {Object} prototype The object to inherit from.\n   * @param {Object} [properties] The properties to assign to the object.\n   * @returns {Object} Returns the new object.\n   * @example\n   *\n   * function Shape() {\n   *   this.x = 0;\n   *   this.y = 0;\n   * }\n   *\n   * function Circle() {\n   *   Shape.call(this);\n   * }\n   *\n   * Circle.prototype = _.create(Shape.prototype, {\n   *   'constructor': Circle\n   * });\n   *\n   * var circle = new Circle;\n   * circle instanceof Circle;\n   * // => true\n   *\n   * circle instanceof Shape;\n   * // => true\n   */\n  function create(prototype, properties) {\n    var result = baseCreate(prototype);\n    return properties ? baseAssign(result, properties) : result;\n  }\n\n  return create;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_createMathOperation.js":"define(['./_baseToNumber', './_baseToString'], function(baseToNumber, baseToString) {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /**\n   * Creates a function that performs a mathematical operation on two values.\n   *\n   * @private\n   * @param {Function} operator The function to perform the operation.\n   * @param {number} [defaultValue] The value used for `undefined` arguments.\n   * @returns {Function} Returns the new mathematical operation function.\n   */\n  function createMathOperation(operator, defaultValue) {\n    return function(value, other) {\n      var result;\n      if (value === undefined && other === undefined) {\n        return defaultValue;\n      }\n      if (value !== undefined) {\n        result = value;\n      }\n      if (other !== undefined) {\n        if (result === undefined) {\n          return other;\n        }\n        if (typeof value == 'string' || typeof other == 'string') {\n          value = baseToString(value);\n          other = baseToString(other);\n        } else {\n          value = baseToNumber(value);\n          other = baseToNumber(other);\n        }\n        result = operator(value, other);\n      }\n      return result;\n    };\n  }\n\n  return createMathOperation;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_createOver.js":"define(['./_apply', './_arrayMap', './_baseIteratee', './_baseRest', './_baseUnary', './_flatRest'], function(apply, arrayMap, baseIteratee, baseRest, baseUnary, flatRest) {\n\n  /**\n   * Creates a function like `_.over`.\n   *\n   * @private\n   * @param {Function} arrayFunc The function to iterate over iteratees.\n   * @returns {Function} Returns the new over function.\n   */\n  function createOver(arrayFunc) {\n    return flatRest(function(iteratees) {\n      iteratees = arrayMap(iteratees, baseUnary(baseIteratee));\n      return baseRest(function(args) {\n        var thisArg = this;\n        return arrayFunc(iteratees, function(iteratee) {\n          return apply(iteratee, thisArg, args);\n        });\n      });\n    });\n  }\n\n  return createOver;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_createPadding.js":"define(['./_baseRepeat', './_baseToString', './_castSlice', './_hasUnicode', './_stringSize', './_stringToArray'], function(baseRepeat, baseToString, castSlice, hasUnicode, stringSize, stringToArray) {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /* Built-in method references for those with the same name as other `lodash` methods. */\n  var nativeCeil = Math.ceil;\n\n  /**\n   * Creates the padding for `string` based on `length`. The `chars` string\n   * is truncated if the number of characters exceeds `length`.\n   *\n   * @private\n   * @param {number} length The padding length.\n   * @param {string} [chars=' '] The string used as padding.\n   * @returns {string} Returns the padding for `string`.\n   */\n  function createPadding(length, chars) {\n    chars = chars === undefined ? ' ' : baseToString(chars);\n\n    var charsLength = chars.length;\n    if (charsLength < 2) {\n      return charsLength ? baseRepeat(chars, length) : chars;\n    }\n    var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));\n    return hasUnicode(chars)\n      ? castSlice(stringToArray(result), 0, length).join('')\n      : result.slice(0, length);\n  }\n\n  return createPadding;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_createPartial.js":"define(['./_apply', './_createCtor', './_root'], function(apply, createCtor, root) {\n\n  /** Used to compose bitmasks for function metadata. */\n  var BIND_FLAG = 1;\n\n  /**\n   * Creates a function that wraps `func` to invoke it with the `this` binding\n   * of `thisArg` and `partials` prepended to the arguments it receives.\n   *\n   * @private\n   * @param {Function} func The function to wrap.\n   * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n   * @param {*} thisArg The `this` binding of `func`.\n   * @param {Array} partials The arguments to prepend to those provided to\n   *  the new function.\n   * @returns {Function} Returns the new wrapped function.\n   */\n  function createPartial(func, bitmask, thisArg, partials) {\n    var isBind = bitmask & BIND_FLAG,\n        Ctor = createCtor(func);\n\n    function wrapper() {\n      var argsIndex = -1,\n          argsLength = arguments.length,\n          leftIndex = -1,\n          leftLength = partials.length,\n          args = Array(leftLength + argsLength),\n          fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n\n      while (++leftIndex < leftLength) {\n        args[leftIndex] = partials[leftIndex];\n      }\n      while (argsLength--) {\n        args[leftIndex++] = arguments[++argsIndex];\n      }\n      return apply(fn, isBind ? thisArg : this, args);\n    }\n    return wrapper;\n  }\n\n  return createPartial;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_createRange.js":"define(['./_baseRange', './_isIterateeCall', './toFinite'], function(baseRange, isIterateeCall, toFinite) {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /**\n   * Creates a `_.range` or `_.rangeRight` function.\n   *\n   * @private\n   * @param {boolean} [fromRight] Specify iterating from right to left.\n   * @returns {Function} Returns the new range function.\n   */\n  function createRange(fromRight) {\n    return function(start, end, step) {\n      if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {\n        end = step = undefined;\n      }\n      // Ensure the sign of `-0` is preserved.\n      start = toFinite(start);\n      if (end === undefined) {\n        end = start;\n        start = 0;\n      } else {\n        end = toFinite(end);\n      }\n      step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);\n      return baseRange(start, end, step, fromRight);\n    };\n  }\n\n  return createRange;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_createRecurry.js":"define(['./_isLaziable', './_setData', './_setWrapToString'], function(isLaziable, setData, setWrapToString) {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /** Used to compose bitmasks for function metadata. */\n  var BIND_FLAG = 1,\n      BIND_KEY_FLAG = 2,\n      CURRY_BOUND_FLAG = 4,\n      CURRY_FLAG = 8,\n      PARTIAL_FLAG = 32,\n      PARTIAL_RIGHT_FLAG = 64;\n\n  /**\n   * Creates a function that wraps `func` to continue currying.\n   *\n   * @private\n   * @param {Function} func The function to wrap.\n   * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n   * @param {Function} wrapFunc The function to create the `func` wrapper.\n   * @param {*} placeholder The placeholder value.\n   * @param {*} [thisArg] The `this` binding of `func`.\n   * @param {Array} [partials] The arguments to prepend to those provided to\n   *  the new function.\n   * @param {Array} [holders] The `partials` placeholder indexes.\n   * @param {Array} [argPos] The argument positions of the new function.\n   * @param {number} [ary] The arity cap of `func`.\n   * @param {number} [arity] The arity of `func`.\n   * @returns {Function} Returns the new wrapped function.\n   */\n  function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {\n    var isCurry = bitmask & CURRY_FLAG,\n        newHolders = isCurry ? holders : undefined,\n        newHoldersRight = isCurry ? undefined : holders,\n        newPartials = isCurry ? partials : undefined,\n        newPartialsRight = isCurry ? undefined : partials;\n\n    bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);\n    bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);\n\n    if (!(bitmask & CURRY_BOUND_FLAG)) {\n      bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);\n    }\n    var newData = [\n      func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,\n      newHoldersRight, argPos, ary, arity\n    ];\n\n    var result = wrapFunc.apply(undefined, newData);\n    if (isLaziable(func)) {\n      setData(result, newData);\n    }\n    result.placeholder = placeholder;\n    return setWrapToString(result, func, bitmask);\n  }\n\n  return createRecurry;\n});\n","/home/travis/build/npmtest/node-npmtest-intern/node_modules/intern/browser_modules/lodash-amd/_createRelationalOperation.js":"define(['./toNumber'], function(toNumber) {\n\n  /**\n   * Creates a function that performs a relational operation on two values.\n   *\n   * @private\n   * @param {Function} operator The function to perform the operation.\n   * @returns {Function} Returns the new relational operation function.\n   */\n  function createRelationalOperation(operator) {\n    return function(value, other) {\n      if (!(typeof value == 'string' && typeof other == 'string')) {\n        value = toNumber(value);\n        other = toNumber(other);\n      }\n      return operator(value, other);\n    };\n  }\n\n  return createRelationalOperation;\n});\n"}